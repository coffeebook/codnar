<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Code narrator - an inverse literate programming tool.</title>
<style type="text/css">
/*
 * Copyright (c) 2010, Yahoo! Inc. All rights reserved.
 * Code licensed under the BSD License:
 * http://developer.yahoo.com/yui/license.html
 * version: 2.8.2r1
 */
/*
 * YUI Reset
 * @module reset
 * @namespace
 * @requires 
 */
html {
	color: #000;
	background: #FFF;
}

body,
div,
dl,
dt,
dd,
ul,
ol,
li,
h1,
h2,
h3,
h4,
h5,
h6,
pre,
code,
form,
fieldset,
legend,
input,
button,
textarea,
p,
blockquote,
th,
td {
	margin: 0;
	padding: 0;
}

table {
	border-collapse: collapse;
	border-spacing: 0;
}

fieldset,
img {
	border: 0;
}

address,
caption,
cite,
code,
dfn,
em,
strong,
th,
var,
optgroup {
	font-style: inherit;
	font-weight: inherit;
}

del,
ins {
	text-decoration: none;
}

li {
	list-style: none;
}

caption,
th {
	text-align: left;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-size: 100%;
	font-weight: normal;
}

q:before,
q:after {
	content: '';
}

abbr,
acronym {
	border: 0;
	font-variant: normal;
}

sup {
	vertical-align: baseline;
}

sub {
	vertical-align: baseline;
}

/*because legend doesn't inherit in IE */
legend {
	color: #000;
}

input,
button,
textarea,
select,
optgroup,
option {
	font-family: inherit;
	font-size: inherit;
	font-style: inherit;
	font-weight: inherit;
}

/*@purpose To enable resizing for IE */
/*@branch For IE6-Win, IE7-Win */
input,
button,
textarea,
select {
	*font-size: 100%;
}



/*
 * Copyright (c) 2010, Yahoo! Inc. All rights reserved.
 * Code licensed under the BSD License:
 * http://developer.yahoo.com/yui/license.html
 * version: 2.8.2r1
 */

/*
 * YUI Base
 * @module base
 * @namespace yui-
 * @requires reset, fonts
 */

body {
	/* For breathing room between content and viewport. */
	margin:10px;
}

h1 {
	/* 18px via YUI Fonts CSS foundation. */
	font-size: 138.5%;
}

h2 {
	/* 16px via YUI Fonts CSS foundation. */
	font-size: 123.1%;
}

h3 {
	/* 14px via YUI Fonts CSS foundation. */
	font-size: 108%;
}

h1,h2,h3 {
	/* Top & bottom margin based on font size. */
	margin: 1em 0;
}

h1,h2,h3,h4,h5,h6,strong,dt {
	/* Bringing boldness back to headers and the strong element. */
	font-weight: bold;
}
optgroup {
	font-weight:normal;
}

abbr,acronym {
	/* Indicating to users that more info is available. */
	border-bottom: 1px dotted #000;
	cursor: help;
}

em {
	/* Bringing italics back to the em element. */
	font-style: italic;
}

del {
	/* Striking deleted phrases. */
	text-decoration: line-through;
}

blockquote,ul,ol,dl {
	/* Giving blockquotes and lists room to breath. */
	margin: 1em;
}

ol,ul,dl {
	/* Bringing lists on to the page with breathing room. */
	margin-left: 2em;
}

ol li {
	/* Giving OL's LIs generated numbers. */
	list-style: decimal outside;
}

ul li {
	/* Giving UL's LIs generated disc markers. */
	list-style: disc outside;
}

dl dd {
	/* Giving UL's LIs generated numbers. */
	margin-left: 1em;
}

th,td {
	/* Borders and padding to make the table readable. */
	border: 1px solid #000;
	padding: .5em;
}

th {
	/* Distinguishing table headers from data cells. */
	font-weight: bold;
	text-align: center;
}

caption {
	/* Coordinated margin to match cell's padding. */
	margin-bottom: .5em;
	/* Centered so it doesn't blend in to other content. */
	text-align: center;
}

sup {
	/* to preserve line-height and selector appearance */
	vertical-align: super;
}

sub {
	/* to preserve line-height and selector appearance */
	vertical-align: sub;
}

p,
fieldset,
table,
pre {
	/* So things don't run into each other. */
	margin-bottom: 1em;
}
/* Opera requires 1px of passing to render with contemporary native chrome */
button,
input[type="checkbox"],
input[type="radio"],
input[type="reset"],
input[type="submit"] {
	padding:1px;
}
/* Margin & Padding */

div.chunk.name,
div.chunk.html,
div.chunk.containers,
div.chunk table,
div.chunk td,
div.chunk pre {
  margin: 0;
  padding: 0;
}
div.chunk *:last-child {
  margin-bottom: 0;
}
h4, h5, h6,
div.chunk,
div.comment pre {
  margin: 1em 0;
}
pre,
div.comment,
div.chunk.html {
  padding: 0.33em;
}

span.control.chunk {
  padding-left: 0.25em;
  padding-right: 0.25em;
}

/* Table of content */

div#contents ul {
  margin-top: 0;
  margin-bottom: 0;
  padding: 0;
}

div#contents li {
  list-style-type: none;
}

/* Lists */

ul.chunk.containers {
  padding: 0;
  margin: 0;
  display: inline;
}
ul.chunk.containers li {
  display: inline;
  list-style-type: none;
}

/* Borders */

pre,
span.control.chunk,
div.chunk.html {
  border: 1px solid #000;
}

table.layout td.indentation,
div.chunk pre {
  border: none;
}

/* Colors */

span.control.chunk,
table.layout td.html {
  background-color: Beige;
}

/* Colors for GVim classes */

span.Constant   { color: Crimson; }
span.Identifier { color: Teal; }
span.PreProc    { color: Indigo; }
span.Special    { color: Navy; }
span.Statement  { color: Maroon; }
span.Type       { color: Green; }
span.Comment    { color: Purple; }

/* Fonts */

body {
  font-family: Sans-Serif;
}
pre {
  font-family: Consolas, Inconsolata, Monaco, "Courier New", Monospace;
}
div.chunk.name {
  font-weight: bold;
}
/* global styles */
.sunlight-container {
	clear: both;
	border: 1px solid #969696 !important;
	position: relative;
	background-color: #FFFFFF !important;
}
.sunlight-highlighted, .sunlight-container {
	color: #000000 !important;
        /*! Commented out for for Codnar - these are handled by the Codnar CSS.
	font-family: Consolas, Inconsolata, Monaco, "Courier New", Monospace !important;
	font-size: 12px !important;
	line-height: 15px !important;
        !*/
	margin: 0 !important;
}
.sunlight-container > .sunlight-highlighted {
	white-space: pre;
	overflow-x: auto;
}
span.sunlight-highlighted {
	z-index: 1;
	position: relative;
}
span.sunlight-highlighted * {
	background: transparent;
}
.sunlight-line-number-margin {
	float: left !important;
	margin-right: 5px !important;
	margin-top: 0 !important;
	padding: 0 !important;
	padding-right: 4px !important;
	padding-left: 4px !important;
	border-right: 1px solid #CCCCCC !important;
	background-color: #EEEEEE !important;
	color: #848484 !important;
	text-align: right !important;
	position: relative;
	z-index: 3;
}
.sunlight-highlighted a, .sunlight-line-number-margin a  {
	border: none !important;
	text-decoration: none !important;
	font-weight: normal !important;
	font-style: normal !important;
	padding: 0 !important;
}
.sunlight-line-number-margin a {
	color: inherit !important;
}
.sunlight-line-highlight-overlay {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	z-index: 0;
}
.sunlight-line-highlight-overlay div {
	height: 15px;
	width: 100%;
}
.sunlight-line-highlight-overlay .sunlight-line-highlight-active {
	background-color: #E7FCFA;
}




.sunlight-string, 
.sunlight-heredoc, 
.sunlight-heredocDeclaration, 
.sunlight-nowdoc, 
.sunlight-longString, 
.sunlight-rawString, 
.sunlight-binaryString, 
.sunlight-rawLongString, 
.sunlight-binaryLongString {
	color: #990000 !important;
}

.sunlight-ident, 
.sunlight-operator, 
.sunlight-punctuation, 
.sunlight-delimiter {
	color: #000000 !important;
}

.sunlight-comment, 
.sunlight-xmlDocCommentContent {
	color: #009900 !important;
}
.sunlight-number {
	color: #CC6600 !important;
}

.sunlight-named-ident, 
.sunlight-constant, 
.sunlight-javascript .sunlight-globalVariable, 
.sunlight-globalObject, 
.sunlight-python .sunlight-attribute {
	color: #2B91AF !important;
}
.sunlight-keyword, 
.sunlight-languageConstruct, 
.sunlight-css 
.sunlight-element, 
.sunlight-bash .sunlight-command,
.sunlight-ruby .sunlight-specialOperator {
	color: #0000FF !important;
}
.sunlight-shortOpenTag, 
.sunlight-openTag, 
.sunlight-closeTag, 
.sunlight-xmlOpenTag, 
.sunlight-xmlCloseTag {
	background-color: #FFFF99 !important;
	color: #000000 !important;
}
.sunlight-content {
	color: #000000 !important;
}
.sunlight-function, 
.sunlight-globalFunction,
.sunlight-ruby .sunlight-specialFunction {
	color: #B069AF !important;
}

.sunlight-php .sunlight-variable,
.sunlight-ruby .sunlight-globalVariable,
.sunlight-ruby .sunlight-instanceVariable {
	color: #8F41AA !important;
}
.sunlight-regexLiteral {
	color: #FF00B2 !important;
}



/* html/xml */
.sunlight-html .sunlight-string, 
.sunlight-xml .sunlight-string {
	color: #990099 !important;
}
.sunlight-cdata {
	color: #CC6600 !important;
}
.sunlight-html .sunlight-ident, 
.sunlight-html .sunlight-operator, 
.sunlight-xml .sunlight-ident, 
.sunlight-xml .sunlight-operator {
	color: #0000FF !important;
}
.sunlight-html .sunlight-named-ident, .sunlight-xml .sunlight-named-ident {
	color: #FF0000 !important;
}
.sunlight-html .sunlight-entity, 
.sunlight-xml .sunlight-entity {
	background-color: #EEEEEE !important;
	color: #000000 !important;
	border: 1px solid #000000 !important;
}

/* html */
.sunlight-html .sunlight-doctype {
	color: #2B91AF !important;
}

/* c# */
.sunlight-csharp .sunlight-pragma {
	color: #999999 !important;
	font-style: italic !important;
}
.sunlight-csharp .sunlight-xmlDocCommentMeta,
.sunlight-java .sunlight-annotation,
.sunlight-ruby .sunlight-docComment {
	color: #808080 !important;
}

/* javascript */
.sunlight-javascript .sunlight-reservedWord {
	font-style: italic !important;
}

/* sql */
.sunlight-quotedIdent {
	color: #999900 !important;
}

/* css */
.sunlight-css .sunlight-microsoftFilterPrefix {
	color: #FF00FF !important;
}
.sunlight-css .sunlight-rule {
	color: #0099FF !important;
}
.sunlight-css .sunlight-keyword {
	color: #4E65B8 !important;
}
.sunlight-css .sunlight-class {
	color: #FF0000 !important;
}
.sunlight-css .sunlight-id {
	color: #8A8E13 !important;
}
.sunlight-css .sunlight-pseudoClass, 
.sunlight-css .sunlight-pseudoElement {
	color: #368B87 !important;
}

/* bash */
.sunlight-bash .sunlight-hashBang {
	color: #3D97F5 !important;
}
.sunlight-bash .sunlight-specialVariable {
	font-style: italic !important;
	font-weight: bold !important;
}
.sunlight-bash .sunlight-verbatimCommand {
	color: #999900 !important;
}
.sunlight-bash .sunlight-variable, 
.sunlight-bash .sunlight-specialVariable {
	color: #FF0000 !important;
}

/* python */
.sunlight-python .sunlight-specialMethod {
	font-weight: bold !important;
	color: #A07DD3;
}

/* ruby */
.sunlight-ruby .sunlight-subshellCommand {
	color: #999900 !important;
}
</style>
</head>
<body>
<div id="contents"></div>
<div class='rdoc doc markup'>
<h1>Codnar</h1>
<p>
Code Narrator - an inverse literate programming tool.
</p>
<h2>TL;DR</h2>

<h3>Description</h3>
<p>
Code Narrator (Codnar) is an inverse literate programming tool. It splits
the source files into “chunks” (including structured comments) and
weaves them back into a narrative that describes the overall system.
</p>
<h3>Installation</h3>
<p>
A simple <tt>gem install codnar</tt> should do the trick, assuming you have
Ruby gems set up. If you want to use the VIM-based syntax highlighting, you
also need to install <tt>gvim</tt>.
</p>
<h3>Usage</h3>
<p>
The basic usage is:
</p>
<pre>
codnar-split [options] source-file &gt; chunks-file
codnar-weave [options] chunks-files... &gt; codnar.html
</pre>
<p>
Both programs accept a <tt>-h</tt> or <tt>--help</tt> flag to print more
detailed usage messages. You can also invoke Codnar from a Rakefile:
</p>
<pre>
require &quot;codnar/rake&quot;

Codnar::Rake::SplitTask([ source-files... ], [ configurations... ])
Codnar::Rake::WeaveTask(root-file, [ configurations... ], output)
</pre>
</div>
<div class='markdown doc markup'>
<h2>The Story</h2>
<p>
This is the story of the Code Narrator (Codnar) tool. It serves a dual purpose.
It describes the Codnar tool itself, but it also serves as an example of why it
exists in the first place. To explain this more fully, we'll have to make a
little detour into the issue of system documentation.
</p>
<h3>The Documentation Problem</h3>
<p>
Documentation for any system can be grouped to two kinds. The first kind is the
reference manual. If you know of a small piece of the system, this kind of
documentation will give you the details about it. A good reference will help
you find this piece even if you only have a rough idea of what it is named. A
really good reference will also link it to related pieces. A great reference
will even give you example of how to use the related pieces in a realistic
context.
</p>
<p>
Reference manuals are invaluable, and there are plenty of tools to help you
create them. The common approach is the use of structured comments (e.g.,
<a href="http://en.wikipedia.org/wiki/Javadoc">JavaDoc</a>,
<a href="http://en.wikipedia.org/wiki/Doxygen">Doxygen</a>, and a <a href="http://en.wikipedia.org/wiki/Comparison_of_documentation_generators">host of similar
tools</a>).
However, reference manuals by themselves are insufficient.
</p>
<p>
A reference manual only works if you have some idea about how the system works
as a whole. For that, you need some sort of overview. Here there is much less
to help you produce good documentation. The common practice is to sprinkle
small tutorials inside your reference documentation (the <a href="http://msdn.microsoft.com/en-us/library">MSDN
library</a> is a good example). This
doesn't really solve the problem: how do you sufficiently explain a complex new
system, so that references and small tutorials become useful?
</p>
<p>
One possible solution to this problem, <a href="http://en.wikipedia.org/wiki/Literate_programming">literate
programming</a>, was proposed
by Knuth. In a nutshell, the idea was that the source code for the system
fulfilled a dual role. You could compile it into the executable code, as
expected. But you could also generate documentation from it.
</p>
<p>
So far this sounds a lot like structured comments, and indeed structured
comments were inspired by literate programming. The key difference between the
two approaches is that in literate programming, the generated documentation was
not a reference manual. It was a linear narrative describing the system - a
story which walked you through the system in an specific path chosen for
optimal presentation.
</p>
<p>
To achieve this, the sources contained the linear documentation, with embedded
code "chunks". The order of the chunks in the sources was determined by the
narrative, not the programming language requirements. Extracting and
re-ordering these chunks was part of the build process, so the regular compiler
could process them as usual.
</p>
<p>
This was the great strength, but also the great weakness, of literate
programming. For example, it is next to impossible to create IDEs and similar
tools for literate programming source code. The code chunks are split any which
way and spread around the source files in any order; the same source file may
contain chunks in several languages; etc. Automatically figuring out, say, the
list of members of some class would be a daunting task.
</p>
<p>
In contrast, structured comments stay out of the way of the IDE and similar
tools. The source code is still structured exactly the way the compiler wants,
which allows for easy, localized processing. The trade-off, of course, is that
structured comments produce a reference manual, not a narrative.
</p>
<p>
Today, structured comments have taken over the coding world, and literate
programming has all but been forgotten. The problem it tried to solve, however,
is still very much with us. How do we explain a new complex system?
</p>
<h3>A Different Approach</h3>
<p>
Codnar is an example of a different approach for solving this problem, "inverse
literate programming" (similar to, for example,
<a href="http://packages.python.org/antiweb/">antiweb</a>). This approach is a combination
of structured comments and literate programming. Note that this approach is
similar to, but different in key aspects from, <a href="http://ssw.jku.at/Research/Projects/RevLitProg/">reverse literate
programming</a>.
</p>
<p>
In inverse literate programming, the source files are organized just
the way the compiler, IDE, and similar tools expect them to be. Structured
comments are used to document the pieces of code, and a reference manual can be
generated from the sources as usual.
</p>
<p>
In addition, the code is split into (possibly nested) named "chunks". This is
done using specially formatted comments. It turns out this functionality is
already supported by most coding editors and IDEs, in the form of "folds" or
"regions". These allow the developer to collapse or expand such chunks at will.
</p>
<p>
At this point, inverse literate programming kicks in. The developer writes
additional documentation source files, next to the usual code source files.
These documentation source files contain a narrative that describes the system,
much in the same way that a literate programming documentation would have done,
with two important differences.
</p>
<p>
The first difference is that the documentation source files refer to and embed
the code chunks (using their names), as opposed to a literate programming
system, where the documentation source files actually contain the code chunks.
</p>
<p>
The second difference is that the documentation source files do not need to
repeat the information that is already covered in the structured comments. When
a code chunk is embedded into the documentation, it includes these comments, so
all the documentation source files need to contain is the narrative "glue" for
placing these pieces into a comprehensible context for the reader.
</p>
<p>
In this way, inverse literate programming allows generating a linear narrative
describing the system, without abandoning the existing code processing tools.
It also makes it easy to retrofit such documentation to an existing code base;
all that's needed is to mark the already-documented code chunks (or even just
treat each source code file as a single chunk), and provide the narrative glue
around them.
</p>
<h3>Maintaining the Documentation</h3>
<p>
Structutred comments have the advantage that they are easy to maintain. Every
time you change a piece of code, change its comment to match. Simiarlt,
literate programming forced one to maintain the documentation as well, since
the same source file was used for code and documentation. Inverse literate
programming does not share this advantage. The linear documentation is in a
separate file, so it isn't immediately visible to the developer who is making
the changes. Also, it is easy to just forget to include some chunks of code in
the documentation.
</p>
<p>
These issues are very similar to the issues of unit testing. Unit tests live in
a separate file from the code they test, and it is easy to forget to test some
chunks of code. One way to ensure all code is tested is to use a code coverage
tool. Similarly, inverse literate programming tools should complain about code
chunks that are left out of the final narrative.
</p>
<p>
A different approach,
<a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a>, ensures that the
tests are up-to-date and complete by writing the tests before the code. The
same approach can be used for documentation.
<a href="http://thinkingphp.org/spliceit/docs/0.1_alpha/pages/ddd_info.html">DDD</a> means
that you first document what you are about to do, and only then follow up with
the actual coding. Inverse literate programming and TDD are an excellent
practical way to achieve that.
</p>
<p>
The unit tests are code like any other code. As such, they should be documented
using structured comments. Certain unit test tools like
<a href="http://rspec.info/">RSpec</a>, <a href="http://cukes.info/">Cucumber</a> and other
<a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> tools blur the
line between the tests-as-code and the tests-as-documentation anyway, so the
amount of unit test structured documentation should be small.
</p>
<p>
Therefore, if you are writing the tests first, you have done the heavy lifting
of documenting what the new code will do. All that is left is providing a bit
of surrounding context and embedding it all in the currect location in the
narrative. Then, when you write the new code itself, it should be easy to
connect it to the narrative at the appropriate point.
</p>
<p>
In the case of Code Narrator itself, the number of (raw) lines in the code
library itself is ~2100 lines, the number of test code lines is ~2200 lines,
and the number of narrative documentation lines is only ~900 lines. Given
narrative documentation are easier to write than system (or test) code, this
indicates maintaining a narrative is not an unreasonable burden for a
well-tested project.
</p>
<h3>Code Narrator</h3>
<p>
Codnar is an inverse literate programming tool. It allows you to tell a story
about your system, which will explain it to others: developers, maintainers,
and/or users. It builds on the structured comments you would write anyway to
generate a reference manual for the system, requires minimal or no changes to
your source code files, and works perfectly well inside your favorite IDE or
editor. If you follow TDD or BDD, Codnar will make it easier for you to
complement it with DDD.
</p>
<p>
The rest of this document goes into the details of Codnar's implementation. The
core of the system is the following simple data flow: A set of source files is
split into chunks; the chunks are woven into a single HTML. This simple flow
can be enhanced by pre-processing the sources, or post-processing the HTML. In
a realistic project, all this would be managed by some build tool; either using
the command-line (for arbitrary build tools) or using the provided Ruby classes
for Rake integration.
</p>
</div>
<div class='markdown doc markup'>
<h2>Utilities</h2>
<p>
Before delving into the code, here are a few low-level generic utilities which
are used all over it. These arguably belong in a separate library.
</p>
<h3>Overall module</h3>
<p>
Executable scripts (tests, command-line applications) starts with a <code>require
'codnar'</code> line to access to the full Codnar code. This also serves as a
convenient list of all of Codnar's parts and dependencies:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rb">
<span>lib/codnar.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;andand&quot;
require &quot;base64&quot;
require &quot;cgi&quot;
require &quot;erb&quot;
require &quot;fileutils&quot;
require &quot;getoptions&quot;
require &quot;irb&quot;
require &quot;rdiscount&quot;
require &quot;rdoc/markup/to_html&quot;
require &quot;yaml&quot;

require &quot;codnar/core_ext/hash&quot;
require &quot;codnar/core_ext/markdown&quot;
require &quot;codnar/core_ext/rdoc&quot;
require &quot;codnar/core_ext/string&quot;

require &quot;codnar/version&quot;

require &quot;codnar/application.rb&quot;
require &quot;codnar/configuration.rb&quot;
require &quot;codnar/data_files.rb&quot;
require &quot;codnar/errors&quot;
require &quot;codnar/formatter&quot;
require &quot;codnar/globals.rb&quot;
require &quot;codnar/grouper&quot;
require &quot;codnar/gvim&quot;
require &quot;codnar/merger&quot;
require &quot;codnar/split&quot;
require &quot;codnar/reader&quot;
require &quot;codnar/scanner&quot;
require &quot;codnar/splitter&quot;
require &quot;codnar/sunlight&quot;
require &quot;codnar/weave&quot;
require &quot;codnar/weaver&quot;
require &quot;codnar/writer&quot;
</pre>
</div>
</div>
</p>
<h3>Collecting and testing for errors</h3>
<p>
Since Codnar needs to process multiple input files (in general, all the source
and most documentation files of a complex system), it is important that errors
will be reported with appropriate location information, and that processing
will continue so the full set of errors will be reported. This also makes the
code easier to test, using a special test case base class supporting error
collection:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-test-with-errors-rb">
<span>test/lib/test_with_errors.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Tests that collect Errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module TestWithErrors

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Aliasing methods needs to be deferred to when the module is included and be
executed in the context of the class.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.included(base)
      base.class_eval do

        alias_method :errors_original_setup, :setup

</pre>
        <table class='layout'>
<tr>
<td class='indentation'>
<pre>        </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Automatically create an fresh error data member for each test.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
        def setup
          errors_original_setup
          @errors = Errors.new
        end

      end
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is a simple test that demonstrates error collection:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-collect-errors-rb">
<span>test/collect_errors.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test collecting errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestCollectErrors &lt; Test::Unit::TestCase

    include TestWithErrors

    def test_one_error
      @errors &lt;&lt; &quot;Oops&quot;
      @errors.should == [ &quot;#{$0}: Oops&quot; ]
    end

    def test_path_error
      @errors.in_path(&quot;foo&quot;) do
        @errors &lt;&lt; &quot;Eeek&quot;
      end
      @errors &lt;&lt; &quot;Oops&quot;
      @errors.should == [ &quot;#{$0}: Eeek in file: foo&quot;, &quot;#{$0}: Oops&quot; ]
    end

    def test_line_error
      @errors.in_path(&quot;foo&quot;) do
        @errors.at_line(1)
        @errors &lt;&lt; &quot;Eeek&quot;
      end
      @errors &lt;&lt; &quot;Oops&quot;
      @errors.should == [ &quot;#{$0}: Eeek in file: foo at line: 1&quot;, &quot;#{$0}: Oops&quot; ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-errors-rb">
<span>lib/codnar/errors.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Collect a list of errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Errors &lt; Array

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create an empty errors collection.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize
      @path = nil
      @line = nil
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Associate all errors collected by a block with a specific disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def in_path(path, &amp;block)
      prev_path, prev_line = @path, @line
      @path, @line = path, nil
      block.call
      @path, @line = prev_path, prev_line
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Set the line number for any errors collected from here on.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def at_line(line)
      @line = line
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Add a single error to the collection, with automatic context annotation
(current disk file and line). Other methods (<tt>push</tt>, “+=” etc.)
do not automatically add the context annotation.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def &lt;&lt;(message)
      push(annotate_error_message(message))
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Annotate an error message with the context (current file and line).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def annotate_error_message(message)
      return &quot;#{$0}: #{message}&quot; unless @path
      return &quot;#{$0}: #{message} in file: #{@path}&quot; unless @line
      return &quot;#{$0}: #{message} in file: #{@path} at line: #{@line}&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Tests with a fake file system</h3>
<p>
Since Codnar manipulates files (source files, chunk files, generated HTML
files), it is very useful to be able to execute file-related tests with a fake
file system. This is a more elegant alternative to creating and cleaning a
temporary physical directory for the test.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-test-with-fakefs-rb">
<span>test/lib/test_with_fakefs.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;fakefs/safe&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Setup tests that use the FakeFS fake file system.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module TestWithFakeFS

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Aliasing methods needs to be deferred to when the module is included and be
executed in the context of the class.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.included(base)
      base.class_eval do

        alias_method :fakefs_original_setup, :setup

</pre>
        <table class='layout'>
<tr>
<td class='indentation'>
<pre>        </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Automatically create an fresh fake file system for each test.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
        def setup
          fakefs_original_setup
          FakeFS.activate!
          FakeFS::FileSystem.clear
        end

        alias_method :fakefs_original_teardown, :teardown

</pre>
        <table class='layout'>
<tr>
<td class='indentation'>
<pre>        </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Automatically clean up the fake file system at the end of each test.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
        def teardown
          fakefs_original_teardown
          FakeFS.deactivate!
        end

      end

    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Tests with temporary files</h3>
<p>
Some tests need to create temporary files outside the fake file system. This is
mainly needed to provide input to external tools (e.g., syntax highlighting
using GVim).
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-test-with-tempfile-rb">
<span>test/lib/test_with_tempfile.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Tests with a temporary file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module TestWithTempfile

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a temporary file on the disk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def write_tempfile(path, content)
      file = Tempfile.open(path, &quot;.&quot;)
      file.write(content)
      file.close(false)
      (@tempfiles ||= []) &lt;&lt; (path = file.path)
      return path
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Aliasing methods needs to be deferred to when the module is included and be
executed in the context of the class.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.included(base)
      base.class_eval do

        alias_method :tempfile_original_teardown, :teardown

</pre>
        <table class='layout'>
<tr>
<td class='indentation'>
<pre>        </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Automatically clean up the temporary files when the test is done. This
isn’t really required when we are using FakeFS, but we can’t do that
when we are running GVim syntax highlighting tests.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
        def teardown
          tempfile_original_teardown
          @tempfiles ||= []
          @tempfiles.each do |tempfile|
            File.delete(tempfile) if File.exist?(tempfile)
          end
        end

      end

    end
  end

end
</pre>
</div>
</div>
</p>
<h3>Extending the Hash class</h3>
<p>
We extend the builtin Hash class in three ways. Two will be described further
below; a third is to make all Hash objects behave as OpenStruct, that is, allow
accessing and setting values using "." notation. This allows us to avoid
defining classes for "dumb" data structures, while allowing them to be dumped
and loaded from clean YAML files. Here is a simple test of accessing missing
keys:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-missing-keys-rb">
<span>test/missing_keys.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test accessing missing keys as members.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestMissingKeys &lt; Test::Unit::TestCase

    def test_read_missing_key
      {}.missing.should == nil
    end

    def test_set_missing_key
      hash = {}
      hash.missing = &quot;value&quot;
      hash.missing.should == &quot;value&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-hash-rb">
<span>lib/codnar/core_ext/hash.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extend the core Hash class.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
class Hash

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Provide OpenStruct/JavaScript-like implicit “.key” and “.key=”
methods.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def method_missing(method, *arguments)
    method = method.to_s
    key = method.chomp(&quot;=&quot;)
    return method == key ? self[key] : self[key] = arguments[0]
  end

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#deep-clone'>Deep clone</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#deep-merge'>Deep merge</a>
</pre>
<pre class='sunlight-highlight-ruby'>

end
</pre>
</div>
</div>
</p>
<h3>Extending the String class</h3>
<p>
We extend the builtin String class to manage indentation and convert chunk
names to identifiers. These functions will be decribed below when used in the
code.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-string-rb">
<span>lib/codnar/core_ext/string.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extend the core String class.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
class String

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#unindent-text'>Unindent text</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#convert-names-to-identifiers'>Convert names to identifiers</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#clean-markup-html'>Clean markup HTML</a>
</pre>
<pre class='sunlight-highlight-ruby'>

end
</pre>
</div>
</div>
</p>
<p>
In addition, we also provide a method for cleaning up messy HTML code generated
by markup formatters:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="clean-markup-html">
<span>Clean markup HTML</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Clean HTML generated by markup formatters. Such HTML tends to have extra
empty lines for no apparent reason. Cleaning it up seems to be safe enough,
and eliminates the ugly additional vertical space in the final HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def clean_markup_html
  return gsub(/\n*&lt;p&gt;\n*/, &quot;\n&lt;p&gt;\n&quot;) \
        .gsub(/\n*&lt;\/p&gt;\n*/, &quot;\n&lt;/p&gt;\n&quot;) \
        .gsub(/\n*&lt;pre&gt;\n*/, &quot;\n&lt;pre&gt;\n&quot;) \
        .gsub(/\n*&lt;\/pre&gt;\n*/, &quot;\n&lt;/pre&gt;\n&quot;) \
        .sub(/^\n*/, &quot;&quot;)
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-string-rb">lib/codnar/core_ext/string.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h2>Splitting files into chunks</h2>
<p>
Codnar makes the reasonable assumption that each source file can be effectively
processed as a sequence of lines. This works well in practice for all "text"
source files. It fails miserably for "binary" source files, but such files
don't work that well in most generic source management tools (such as version
management systems).
</p>
<p>
A second, less obvious assumption is that it is possible to classify the source
file lines to "kinds" using a simple state machine. The classified lines are
then grouped into nested chunks based on the two special line kinds
<code>begin_chunk</code> and <code>end_chunk</code>. The other line kinds are used to control how the
lines are formatted into HTML.
</p>
<p>
The collected chunks, with the formatted HTML for each one, are then stored in
a chunks file to be used later for weaving the overall HTML narrative.
</p>
<h3>Scanning Lines</h3>
<p>
Scanning a file into classified lines is done by the <code>Scanner</code> class.
Here is a simple test that demonstrates using the scanner:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-scan-lines-rb">
<span>test/scan_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test scanning classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestScanLines &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithFakeFS

    def test_scan_lines
      File.open(&quot;comments&quot;, &quot;w&quot;) { |file| file.write(INPUT) }
      scanner = Scanner.new(@errors, SYNTAX)
      scanner.lines(&quot;comments&quot;).should == LINES
      @errors.should == ERRORS
    end

    SYNTAX = {
      &quot;start_state&quot; =&gt; &quot;comment&quot;,
      &quot;patterns&quot; =&gt; {
        &quot;shell&quot; =&gt; {
          &quot;regexp&quot; =&gt; &quot;^(\\s*)#+\\s*(.*)$&quot;,
          &quot;groups&quot; =&gt; [ &quot;indentation&quot;, &quot;payload&quot; ],
          &quot;kind&quot; =&gt; &quot;comment&quot;,
        },
        &quot;c++&quot; =&gt; {
          &quot;regexp&quot; =&gt; /^(\s*)\/\/+\s*(.*)$/,
          &quot;groups&quot; =&gt; [ &quot;indentation&quot;, &quot;payload&quot; ],
          &quot;kind&quot; =&gt; &quot;comment&quot;,
        },
        &quot;invalid&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;(&quot; },
      },
      &quot;states&quot; =&gt; {
        &quot;comment&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;shell&quot; },
            { &quot;pattern&quot; =&gt; &quot;c++&quot; },
            { &quot;pattern&quot; =&gt; &quot;no-such-pattern&quot;, &quot;next_state&quot; =&gt; &quot;no-such-state&quot; },
          ],
        },
      },
    }

    INPUT = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #! foo
       // bar
        baz
    EOF

    LINES = [ {
      &quot;kind&quot; =&gt; &quot;comment&quot;,
      &quot;line&quot; =&gt; &quot;# foo&quot;,
      &quot;indentation&quot; =&gt; &quot;&quot;,
      &quot;payload&quot; =&gt; &quot;foo&quot;,
      &quot;number&quot; =&gt; 1,
    }, {
      &quot;kind&quot; =&gt; &quot;comment&quot;,
      &quot;line&quot; =&gt; &quot; // bar&quot;,
      &quot;indentation&quot; =&gt; &quot; &quot;,
      &quot;payload&quot; =&gt; &quot;bar&quot;,
      &quot;number&quot; =&gt; 2,
    }, {
      &quot;kind&quot; =&gt; &quot;error&quot;,
      &quot;line&quot; =&gt; &quot;  baz&quot;,
      &quot;indentation&quot; =&gt; &quot;  &quot;,
      &quot;payload&quot; =&gt; &quot;baz&quot;,
      &quot;state&quot; =&gt; &quot;comment&quot;,
      &quot;number&quot; =&gt; 3,
    } ]

    ERRORS = [
      &quot;#{$0}: Invalid pattern: invalid regexp: ( error: premature end of regular expression: /(/&quot;,
      &quot;#{$0}: Reference to a missing pattern: no-such-pattern&quot;,
      &quot;#{$0}: Reference to a missing state: no-such-state&quot;,
      &quot;#{$0}: State: comment failed to classify line: baz in file: comments at line: 3&quot;
    ]

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-scanner-rb">
<span>lib/codnar/scanner.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan a file into classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Scanner

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Construct a scanner based on a syntax in the following structure:
</p>
<pre>
patterns:
  &lt;name&gt;:
    name: &lt;name&gt;
    kind: &lt;kind&gt;
    regexp: &lt;regexp&gt;
    groups:
    - &lt;name&gt;
states:
  &lt;name&gt;:
    name: &lt;name&gt;
    transitions:
    - pattern: &lt;pattern&gt;
      kind: &lt;kind&gt;
      next_state: &lt;state&gt;
start_state: &lt;state&gt;
</pre>
<p>
To allow for cleaner YAML files to specify the syntax, the following
shorthands are supported:
</p>
<ul><li>
<p>
A pattern or state reference can be presented by the string name of the
pattern or state.
</p>
</li><li>
<p>
The name field of a state or pattern can be ommitted. If specified, it must
be identical to the key in the states or patterns mapping.
</p>
</li><li>
<p>
The kind field of a pattern can be ommitted; by default it is assumed to be
identical to the pattern name.
</p>
</li><li>
<p>
A pattern regexp can be presented by a plain string.
</p>
</li><li>
<p>
The pattern groups field can be ommitted or contain <tt>nil</tt> if it is
equal to [ “indentation”, “payload” ].
</p>
</li><li>
<p>
The kind field of a transition can be ommitted; by default it is assumed to
be identical to the pattern kind.
</p>
</li><li>
<p>
The next state of a transition can be ommitted; by default it is assumed to
be identical to the containing state.
</p>
</li><li>
<p>
The start state can be ommitted; by default it is assumed to be named
<tt>start</tt>.
</p>
</li></ul>
<p>
When the Scanner is constructed, a deep clone of the syntax object is
created and modified to expand all the above shorthands. Any problems
detected during this process are pushed into the errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(errors, syntax)
      @errors = errors
      @syntax = syntax.deep_clone
      @syntax.patterns.each { |name, pattern| expand_pattern_shorthands(name, pattern) }
      @syntax.states.each { |name, state| expand_state_shorthands(name, state) }
      @syntax.start_state = resolve_start_state
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan a disk file into classified lines in the following format (where the
groups contain the text extracted by the matching pattern):
</p>
<pre>
- kind: &lt;kind&gt;
  line: &lt;text&gt;
  &lt;group&gt;: &lt;text&gt;
</pre>
<p>
By convention, each classified line has a “payload” group that contains
the “main” content of the line (chunk name for begin/end/nested chunk
lines, clean comment text for comment lines, etc.). In addition, most
classified lines have an “indentation” group that contains the leading
white space (which is not included in the payload).
</p>
<p>
If at some state, a file line does not match any pattern, the scanner will
push a message into the errors. In addition it will classify the line as
follows:
</p>
<pre>
- kind: error
  state: &lt;name&gt;
  line: &lt;text&gt;
  indentation: &lt;leading white space&gt;
  payload: &lt;line text following the indentation&gt;
</pre>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def lines(path)
      @path = path
      @lines = []
      @state = @syntax.start_state
      @errors.in_path(path) { scan_path }
      return @lines
    end

  protected

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-pattern-shorthands'>Scanner pattern shorthands</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-state-shorthands'>Scanner state shorthands</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-file-processing'>Scanner file processing</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-line-processing'>Scanner line processing</a>
</pre>
<pre class='sunlight-highlight-ruby'>

  end

end
</pre>
</div>
</div>
</p>
<p>
As we can see, the implementation is split into two main parts. First, all
shorthands in the syntax definition are expanded (possibly generating errors).
Then, the expanded syntax is applied to a file, to generate a sequence of
classified lines.
</p>
<h4>Scanner Syntax Shorthands</h4>
<p>
The syntax is expected to be written by hand in a YAML file. We therefore
provide some convenient shorthands (listed above) to make YAML syntax files
more readable. These shorthands must be expanded to their full form before we
can apply the syntax to a file. There are two sets of shorthands we need to
expand:
</p>
<ul>
<li>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-pattern-shorthands">
<span>Scanner pattern shorthands</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand all the shorthands used in the pattern.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def expand_pattern_shorthands(name, pattern)
  pattern.kind ||= fill_name(name, pattern, &quot;Pattern&quot;)
  pattern.groups ||= [ &quot;indentation&quot;, &quot;payload&quot; ]
  pattern.regexp = convert_to_regexp(name, pattern.regexp)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a string regexp to a real Regexp.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def convert_to_regexp(name, regexp)
  return regexp if Regexp == regexp
  begin
    return Regexp.new(regexp)
  rescue
    @errors &lt;&lt; &quot;Invalid pattern: #{name} regexp: #{regexp} error: #{$!}&quot;
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Fill in the name field for state or pattern object.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def fill_name(name, data, type)
  data_name = data.name ||= name
  @errors &lt;&lt; &quot;#{type}: #{name} has wrong name: #{data_name}&quot; if data_name != name
  return data_name
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
</li>
<li>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-state-shorthands">
<span>Scanner state shorthands</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand all the shorthands used in the state.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def expand_state_shorthands(name, state)
  fill_name(name, state, &quot;State&quot;)
  state.transitions.each do |transition|
    pattern = transition.pattern = lookup(@syntax.patterns, &quot;pattern&quot;, transition.pattern)
    transition.kind ||= pattern.andand.kind
    transition.next_state = lookup(@syntax.states, &quot;state&quot;, transition.next_state || state)
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a string name to an actual data reference.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def lookup(mapping, type, reference)
  return reference unless String === reference
  data = mapping[reference]
  @errors &lt;&lt; &quot;Reference to a missing #{type}: #{reference}&quot; unless data
  return data
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Resolve the start state reference.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def resolve_start_state
  return lookup(@syntax.states, &quot;state&quot;, @syntax.start_state || &quot;start&quot;) || {
    &quot;name&quot; =&gt; &quot;missing_start_state&quot;,
    &quot;kind&quot; =&gt; &quot;error&quot;,
    &quot;transitions&quot; =&gt; []
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
</li>
</ul>
<p>
The above code modifies the syntax object in place. This is safe because we are
working on a <code>deep_clone</code> of the original syntax:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="deep-clone">
<span>Deep clone</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Obtain a deep clone which shares nothing with this hash.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def deep_clone
  return YAML.load(to_yaml)
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-hash-rb">lib/codnar/core_ext/hash.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Classifying Source Lines</h4>
<p>
Scanning a file to classified lines is a simple matter of applying the current
state transitions to each line:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-file-processing">
<span>Scanner file processing</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan a disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def scan_path
  File.open(@path, &quot;r&quot;) do |file|
    scan_file(file)
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan an opened file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def scan_file(file)
  @line_number = 0
  file.read.each_line do |line|
    @errors.at_line(@line_number += 1)
    scan_line(line.chomp)
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan the next file line.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def scan_line(line)
  @state.transitions.each do |transition|
    return if transition.pattern &amp;&amp; transition.next_state &amp;&amp; classify_matching_line(line, transition)
  end
  unclassified_line(line, @state.name)
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
If a line matches a state transition, it is classified accordingly. Otherwise,
it is reported as an error:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-line-processing">
<span>Scanner line processing</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Handle a file line, only if it matches the pattern.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def classify_matching_line(line, transition)
  match = (pattern = transition.pattern).regexp.match(line)
  return false unless match
  @lines &lt;&lt; Scanner.extracted_groups(match, pattern.groups).update({
    &quot;line&quot; =&gt; line,
    &quot;kind&quot; =&gt; transition.kind,
    &quot;number&quot; =&gt; @line_number
  })
  @state = transition.next_state
  return true
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extract named groups from a match. As a special case, indentation is
deleted if there is no payload.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.extracted_groups(match, groups)
  extracted = {}
  groups.each_with_index do |group, index|
    extracted[group] = match[index + 1]
  end
  extracted.delete(&quot;indentation&quot;) if match[0] == &quot;&quot;
  return extracted
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Handle a file line that couldn’t be classified.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def unclassified_line(line, state_name)
  @lines &lt;&lt; {
    &quot;line&quot; =&gt; line,
    &quot;indentation&quot; =&gt; line.indentation,
    &quot;payload&quot; =&gt; line.unindent,
    &quot;kind&quot; =&gt; &quot;error&quot;,
    &quot;state&quot; =&gt; state_name,
    &quot;number&quot; =&gt; @line_number
  }
  @errors &lt;&lt; &quot;State: #{state_name} failed to classify line: #{@lines.last.payload}&quot;
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h3>Merging scanned lines to chunks</h3>
<p>
Once we have the array of scanned classified lines, we need to merge them into
nested chunks. Here is a simple test that demonstrates using the merger:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-merge-lines-rb">
<span>test/merge_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test merging classified lines to chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestMergeLines &lt; Test::Unit::TestCase

    include TestWithErrors

    def test_merge_no_chunks
      lines = [ { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;foo&quot;, &quot;number&quot; =&gt; 1, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;foo&quot; } ]
      chunks = Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;path&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;lines&quot; =&gt; lines
      } ]
    end

    def test_valid_merge
      chunks = Merger.chunks(@errors, &quot;path&quot;, VALID_LINES)
      @errors.should == []
      chunks.should == VALID_CHUNKS
    end

    VALID_LINES = [
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;number&quot; =&gt; 1,  &quot;line&quot; =&gt; &quot;before top&quot;,
        &quot;indentation&quot; =&gt; &quot;&quot;,     &quot;payload&quot; =&gt; &quot;before top&quot;          },
      { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;number&quot; =&gt; 2, &quot;line&quot; =&gt; &quot; {{{ top chunk&quot;,
        &quot;indentation&quot; =&gt; &quot; &quot;,    &quot;payload&quot; =&gt; &quot;top chunk&quot;           },
      { &quot;kind&quot; =&gt; &quot;code&quot;,         &quot;number&quot; =&gt; 3, &quot;line&quot; =&gt; &quot; before intermediate&quot;,
        &quot;indentation&quot; =&gt; &quot; &quot;,    &quot;payload&quot; =&gt; &quot;before intermediate&quot; },
      { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;number&quot; =&gt; 4,  &quot;line&quot; =&gt; &quot;  {{{ intermediate chunk&quot;,
        &quot;indentation&quot; =&gt; &quot;  &quot;,   &quot;payload&quot; =&gt; &quot;intermediate chunk&quot;  },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;number&quot; =&gt; 5,  &quot;line&quot; =&gt; &quot;  before inner&quot;,
        &quot;indentation&quot; =&gt; &quot;  &quot;,   &quot;payload&quot; =&gt; &quot;before inner&quot;        },
      { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;number&quot; =&gt; 6,  &quot;line&quot; =&gt; &quot;   {{{ inner chunk&quot;,
        &quot;indentation&quot; =&gt; &quot;   &quot;,  &quot;payload&quot; =&gt; &quot;inner chunk&quot;         },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;number&quot; =&gt; 7,  &quot;line&quot; =&gt; &quot;   inner line&quot;,
        &quot;indentation&quot; =&gt; &quot;   &quot;,  &quot;payload&quot; =&gt; &quot;inner line&quot;          },
      { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;number&quot; =&gt; 8,  &quot;line&quot; =&gt; &quot;   }}} inner chunk&quot;,
        &quot;indentation&quot; =&gt; &quot;   &quot;,  &quot;payload&quot; =&gt; &quot;inner chunk&quot;         },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;number&quot; =&gt; 9,  &quot;line&quot; =&gt; &quot;  after inner&quot;,
        &quot;indentation&quot; =&gt; &quot;  &quot;,   &quot;payload&quot; =&gt; &quot;after inner&quot;         },
      { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;number&quot; =&gt; 10, &quot;line&quot; =&gt; &quot;  }}}&quot;,
        &quot;indentation&quot; =&gt; &quot;  &quot;,   &quot;payload&quot; =&gt; &quot;&quot;                    },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;number&quot; =&gt; 11, &quot;line&quot; =&gt; &quot; after intermediate&quot;,
        &quot;indentation&quot; =&gt; &quot; &quot;,    &quot;payload&quot; =&gt; &quot;after intermediate&quot;  },
      { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;number&quot; =&gt; 12, &quot;line&quot; =&gt; &quot; }}} TOP CHUNK&quot;,
        &quot;indentation&quot; =&gt; &quot; &quot;,    &quot;payload&quot; =&gt; &quot;TOP CHUNK&quot;           },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;number&quot; =&gt; 13, &quot;line&quot; =&gt; &quot;after top&quot;,
        &quot;indentation&quot; =&gt; &quot;&quot;,     &quot;payload&quot; =&gt; &quot;after top&quot;           }
    ]

    VALID_CHUNKS = [
      { &quot;name&quot; =&gt; &quot;path&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [ &quot;top chunk&quot; ],
        &quot;lines&quot; =&gt; [
          VALID_LINES[0].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          { &quot;kind&quot; =&gt; &quot;nested_chunk&quot;, &quot;number&quot; =&gt; 2, &quot;line&quot; =&gt; &quot; {{{ top chunk&quot;,
            &quot;indentation&quot; =&gt; &quot; &quot;,     &quot;payload&quot; =&gt; &quot;top chunk&quot; },
          VALID_LINES[12].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
        ] },
      { &quot;name&quot; =&gt; &quot;top chunk&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 2 } ],
        &quot;containers&quot; =&gt; [ &quot;path&quot; ],
        &quot;contained&quot; =&gt; [ &quot;intermediate chunk&quot; ],
        &quot;lines&quot; =&gt; [
          VALID_LINES[1].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[2].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          { &quot;kind&quot; =&gt; &quot;nested_chunk&quot;, &quot;number&quot; =&gt; 4, &quot;line&quot; =&gt; &quot;  {{{ intermediate chunk&quot;,
            &quot;indentation&quot; =&gt; &quot; &quot;,     &quot;payload&quot; =&gt; &quot;intermediate chunk&quot; },
          VALID_LINES[10].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[11].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
        ] },
      { &quot;name&quot; =&gt; &quot;intermediate chunk&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 4 } ],
        &quot;containers&quot; =&gt; [ &quot;top chunk&quot; ],
        &quot;contained&quot; =&gt; [ &quot;inner chunk&quot; ],
        &quot;lines&quot; =&gt; [
          VALID_LINES[3].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[4].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          { &quot;kind&quot; =&gt; &quot;nested_chunk&quot;, &quot;number&quot; =&gt; 6, &quot;line&quot; =&gt; &quot;   {{{ inner chunk&quot;,
            &quot;indentation&quot; =&gt; &quot; &quot;,     &quot;payload&quot; =&gt; &quot;inner chunk&quot; },
          VALID_LINES[8].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[9].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
        ] },
      { &quot;name&quot; =&gt; &quot;inner chunk&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 6 } ],
        &quot;containers&quot; =&gt; [ &quot;intermediate chunk&quot; ],
        &quot;contained&quot; =&gt; [],
        &quot;lines&quot; =&gt; [
          VALID_LINES[5].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[6].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[7].merge(&quot;indentation&quot; =&gt; &quot;&quot;)
        ] }
    ]

    def test_mismatching_end_chunk_line
      lines = [
        { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;number&quot; =&gt; 1, &quot;line&quot; =&gt; &quot;{{{ top chunk&quot;,
          &quot;indentation&quot; =&gt; &quot;&quot;,     &quot;payload&quot; =&gt; &quot;top chunk&quot;     },
        { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;number&quot; =&gt; 2, &quot;line&quot; =&gt; &quot;}}} not top chunk&quot;,
          &quot;indentation&quot; =&gt; &quot;&quot;,     &quot;payload&quot; =&gt; &quot;not top chunk&quot; }
      ]
      Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == [
        &quot;#{$0}: End line for chunk: not top chunk mismatches begin line for chunk: top chunk in file: path at line: 2&quot;
      ]
    end

    def test_missing_begin_chunk_name
      lines = [
        { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;number&quot; =&gt; 1, &quot;line&quot; =&gt; &quot;{{{&quot;, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;&quot; },
        { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;number&quot; =&gt; 2, &quot;line&quot; =&gt; &quot;}}}&quot;, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;&quot; }
      ]
      Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == [ &quot;#{$0}: Begin line for chunk with no name in file: path at line: 1&quot; ]
    end

    def test_missing_end_chunk_line
      lines = [ { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;number&quot; =&gt; 1, &quot;line&quot; =&gt; &quot;{{{ top chunk&quot;,
                  &quot;indentation&quot; =&gt; &quot;&quot;,     &quot;payload&quot; =&gt; &quot;top chunk&quot; } ]
      Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == [ &quot;#{$0}: Missing end line for chunk: top chunk in file: path at line: 1&quot; ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-merger-rb">
<span>lib/codnar/merger.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge classified lines into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Merger

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert classified lines from a disk file into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.chunks(errors, path, lines)
      return Merger.new(errors, path, lines).chunks
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return merged chunks containing the classified lines. Each chunk lines are
only indented relative to the chunk. This allows nested chunks to be
presented unindented in the final weaved HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def chunks
      @chunks = [ file_chunk ]
      @stack = @chunks.dup
      @errors.in_path(@path) { merge_lines }
      @chunks.each { |chunk| Merger.unindent_lines(chunk.lines) }
      return @chunks
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert classified lines from a disk file into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(errors, path, lines)
      @errors = errors
      @path = path
      @lines = lines
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The top-level all-the-disk-file chunk (without any classified lines)
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def file_chunk
      return { 
        &quot;name&quot; =&gt; @path,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; @path, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;lines&quot; =&gt; []
      }
    end

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#merging-nested-chunk-lines'>Merging nested chunk lines</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#unindenting-chunk-lines'>Unindenting chunk lines</a>
</pre>
<pre class='sunlight-highlight-ruby'>

  end

end
</pre>
</div>
</div>
</p>
<h4>Merging nested chunk lines</h4>
<p>
To merge the nested chunk lines, we maintain a stack of the current chunks.
Each <code>begin_chunk</code> line pushes another chunk on the stack, and each <code>end_chunk</code>
line pops it. If any chunks are not properly terminated, they will remain in
the stack when all the lines are processed.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="merging-nested-chunk-lines">
<span>Merging nested chunk lines</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge all the classified lines into chunks
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def merge_lines
  @lines.each do |line|
    @errors.at_line(line.number)
    merge_line(line)
  end
  end_unterminated_chunks
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
End all chunks missing a terminating end chunk classified line.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def end_unterminated_chunks
  @stack.shift
  @stack.each do |chunk|
    @errors &lt;&lt; &quot;Missing end line for chunk: #{chunk.name}&quot;
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge the next classified line.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def merge_line(line)
  case line.kind
  when &quot;begin_chunk&quot;
    begin_chunk_line(line)
  when &quot;end_chunk&quot;
    end_chunk_line(line)
  else
    @stack.last.lines &lt;&lt; line
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a classified line that starts a new chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def begin_chunk_line(line)
  chunk = contained_chunk(container = @stack.last, line)
  container.contained &lt;&lt; chunk.name
  container.lines &lt;&lt; line.merge(&quot;kind&quot; =&gt; &quot;nested_chunk&quot;)
  @chunks &lt;&lt; chunk
  @stack &lt;&lt; chunk
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A chunk contained in another chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def contained_chunk(container, line)
  return {
    &quot;name&quot; =&gt; new_chunk_name(line.payload),
    &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; @path, &quot;line&quot; =&gt; line.number } ],
    &quot;containers&quot; =&gt; [ container.name ],
    &quot;contained&quot; =&gt; [],
    &quot;lines&quot; =&gt; [ line ]
  }
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return the name of a new chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def new_chunk_name(name)
  return name unless name.nil? || name == &quot;&quot;
  @errors &lt;&lt; &quot;Begin line for chunk with no name&quot;
  return &quot;#{@path}/#{@chunks.size}&quot;
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a classified line that ends an existing chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def end_chunk_line(line)
  return missing_begin_chunk_line(line) if @stack.size == 1
  chunk = @stack.last
  @errors &lt;&lt; &quot;End line for chunk: #{line.payload} mismatches begin line for chunk: #{chunk.name}&quot; \
    unless Merger.matching_end_chunk_line?(chunk, line)
  chunk.lines &lt;&lt; line
  @stack.pop
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Check whether an end chunk classified line matches the begin chunk
classified line.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.matching_end_chunk_line?(chunk, line)
  line_name = line.payload
  return line_name.to_s == &quot;&quot; || line_name.to_id == chunk.name.to_id
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-merger-rb">lib/codnar/merger.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Unindenting merged chunk lines</h4>
<p>
Nested chunks are typically indented relative to their container chunks.
However, in the generated documentation, these chunks are displayed on their
own, and preserving this relative indentation would reduce their readability.
We therefore unindent all chunks as much as possible as the final step.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="unindenting-chunk-lines">
<span>Unindenting chunk lines</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Remove the common indentation from a sequence of classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.unindent_lines(lines)
  indentation = Merger.minimal_indentation(lines)
  lines.each do |line|
    line.indentation = line.indentation.andand.unindent(indentation)
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Find out the minimal indentation of all the classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.minimal_indentation(lines)
  return lines.map { |line| line.indentation }.compact.min
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-merger-rb">lib/codnar/merger.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
The <code>unindent</code> method is an extension to the String class. Here is a simple
test that demonstrates unindenting text:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-unindent-text-rb">
<span>test/unindent_text.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test unindenting a multi-line text.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestUnindentText &lt; Test::Unit::TestCase

    def test_automatic_unindent
      &quot;  a\n    b\n&quot;.unindent.should == &quot;a\n  b\n&quot;
    end

    def test_invalid_unindent
      &quot;    a\n  b\n&quot;.unindent.should == &quot;a\n  b\n&quot;
    end

    def test_integer_unindent
      &quot;  a\n    b\n&quot;.unindent(1).should == &quot; a\n   b\n&quot;
    end

    def test_string_unindent
      &quot;  a\n    b\n&quot;.unindent(&quot; &quot;).should == &quot; a\n   b\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="unindent-text">
<span>Unindent text</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Strip away common indentation from the beginning of each line in this
String. By default, detects the indentation from the first line. This can
be overriden to the exact (String) indentation to strip, or to the (Fixnum)
number of spaces the first line is further-indented from the rest of the
text.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def unindent(unindentation = 0)
  unindentation = &quot; &quot; * (indentation.length - unindentation) if Fixnum === unindentation
  return gsub(/^#{unindentation}/, &quot;&quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extract the indentation from the beginning of this String.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def indentation
  return sub(/[^ ].*$/m, &quot;&quot;)
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-string-rb">lib/codnar/core_ext/string.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h3>Generating chunk HTML</h3>
<p>
Now that we have each chunk's lines, we need to convert them to HTML.
</p>
<h4>Grouping lines of the same kind</h4>
<p>
Instead of formatting each line on its own, we batch the operations to work on
all lines of the same kind at once. Here is a simple test that demonstrates
using the grouper:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-group-lines-rb">
<span>test/group_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test grouping classified lines by their kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestGroupLines &lt; Test::Unit::TestCase

    def test_group_empty_lines
      Grouper.lines_to_groups([]).should == []
    end

    def test_group_one_line
      Grouper.lines_to_groups([ { &quot;kind&quot; =&gt; &quot;code&quot; } ]).should == [ [ { &quot;kind&quot; =&gt; &quot;code&quot; } ] ]
    end

    def test_group_lines
      Grouper.lines_to_groups([
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;0&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;1&quot; },
        { &quot;kind&quot; =&gt; &quot;comment&quot;, &quot;line&quot; =&gt; &quot;2&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;3&quot; },
      ]).should == [ [
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;0&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;1&quot; },
      ], [
        { &quot;kind&quot; =&gt; &quot;comment&quot;, &quot;line&quot; =&gt; &quot;2&quot; },
      ], [
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;3&quot; },
      ] ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-grouper-rb">
<span>lib/codnar/grouper.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Group classified lines according to kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module Grouper

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert array of classified lines to array of classified line groups with
the same line kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.lines_to_groups(lines)
      groups = lines.reduce([], &amp;method(:group_next_line))
      return groups
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Add the next classified line to the classified line groups.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.group_next_line(groups, next_line)
      last_group = groups.last
      if last_group.andand.last.andand.kind == next_line.kind
        last_group.push(next_line)
      else
        groups.push([ next_line ])
      end
      return groups
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Formatting lines as HTML</h4>
<p>
Formatting is based on a configuration that specifies, for (a group of) lines
of each kind, how to convert it to HTML. Here is a simple test that
demonstrates using the formatter:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-format-lines-rb">
<span>test/format_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test converting classified lines to HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestFormatLines &lt; Test::Unit::TestCase

    include TestWithErrors

    alias_method :original_setup, :setup

    def setup
      original_setup
      Formatter.send(:public, *Formatter.protected_instance_methods)
      @formatter = Formatter.new(@errors,
                                 &quot;code&quot; =&gt; &quot;Formatter.lines_to_pre_html(lines)&quot;,
                                 &quot;fail&quot; =&gt; &quot;TestFormatLines.fail&quot;)
    end

    def test_process_html_lines
      lines_group = @formatter.process_lines_group([
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo&quot;, },
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 2, &quot;payload&quot; =&gt; &quot;bar&quot;, },
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 3, &quot;payload&quot; =&gt; &quot;baz&quot;, },
      ])
      @errors.should == []
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo\nbar\nbaz&quot; } ]
    end

    def test_process_unknown_lines
      lines_group = @formatter.process_lines_group([
        { &quot;kind&quot; =&gt; &quot;unknown-kind&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;foo&gt;&quot;, },
      ])
      @errors.should == [ &quot;#{$0}: No formatter specified for lines of kind: unknown-kind&quot; ]
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1,
                                &quot;payload&quot; =&gt; &quot;&lt;pre class='missing formatter error'&gt;\n&amp;lt;foo&amp;gt;\n&lt;/pre&gt;&quot; } ]
    end

    def test_process_code_lines
      lines_group = @formatter.process_lines_group([
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;foo&gt;&quot;, },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;number&quot; =&gt; 2, &quot;payload&quot; =&gt; &quot;bar&quot;, },
      ])
      @errors.should == []
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1,
                                &quot;payload&quot; =&gt; &quot;&lt;pre&gt;\n&amp;lt;foo&amp;gt;\nbar\n&lt;/pre&gt;&quot; } ]
    end

    def test_failed_formatter
      lines_group = @formatter.process_lines_group([ { &quot;kind&quot; =&gt; &quot;fail&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo&quot;, } ])
      @errors.size.should == 1
      @errors.last.should =~ \
        /#{$0}: Formatter: TestFormatLines.fail for lines of kind: fail failed with exception:.*in `fail': Reason/
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1,
                                &quot;payload&quot; =&gt; &quot;&lt;pre class='failed formatter error'&gt;\nfoo\n&lt;/pre&gt;&quot; } ]
    end

    def test_lines_to_html
      lines_group = @formatter.lines_to_html([
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;number&quot; =&gt; 2, &quot;payload&quot; =&gt; &quot;&lt;bar&gt;&quot; },
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 3, &quot;payload&quot; =&gt; &quot;baz&quot; },
      ])
      @errors.should == []
      lines_group.should == &quot;foo\n&lt;pre&gt;\n&amp;lt;bar&amp;gt;\n&lt;/pre&gt;\nbaz&quot;
    end

    def self.fail
      raise &quot;Reason&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-formatter-rb">
<span>lib/codnar/formatter.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format chunks into HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Formatter

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Construct a Formatter based on a mapping from a classified line kind, to a
Ruby expression, that converts an array of classified lines of that kind,
into an array of lines of another kind. This expression is simply
<tt>eval</tt>-ed, and is expected to make use of a variable called
<tt>lines</tt> that contains an array of classified lines, as produced by a
Scanner. The result of evaluating the expressions is expected to be an
array of any number of classified lines of any kind.
</p>
<p>
Formatting repeatedly applies these formatting expressions, until the
result is an array containing a single classified line, which has the kind
<tt>html</tt> and whose payload field contains the unified final HTML
presentation of the original classified lines. In each processing round,
all consecutive lines of the same kind are formated together. This allows
for properly formating line kinds that use a multi-line notation such as
Markdown.
</p>
<p>
The default formatting expression for the kind <tt>html</tt> simply joins
all the payloads of all the classified lines into a single html, and
returns a single “line” containing this joined HTML. All other line
kinds need to have a formatting expression explicitly specified in the
formatters mapping.
</p>
<p>
If no formatting expression is specified for some classified line kind, an
error is reported and the classified lines are wrapped in a pre HTML
element with a <tt>missing_formatter</tt> CSS class. Similarly, if a
formatting expression fails (raises an exception), an error is reported and
the lines are wrapped in a pre HTML element with a
<tt>failed_formatter</tt> CSS class.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(errors, formatters)
      @errors = errors
      @formatters = { &quot;html&quot; =&gt; &quot;Formatter.merge_html_lines(lines)&quot; }.merge(formatters)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Repeatedly process an array of classified lines of arbitrary kinds until we
obtain a single classified “line” containing a unified final HTML
presentation of the original classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def lines_to_html(lines)
      until Formatter.single_html_line?(lines)
        lines = Grouper.lines_to_groups(lines).map { |group| process_lines_group(group) }.flatten
      end
      return lines.last.andand.payload.to_s
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Check whether we have finally got a single HTML classified “line” for
the whole classified lines sequence.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.single_html_line?(lines)
      return lines.size &lt;= 1 &amp;&amp; lines[0].andand.kind == &quot;html&quot;
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Perform one pass of processing toward HTML on a group of consecutive
classified lines with the same kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def process_lines_group(lines)
      kind = lines.last.kind
      formatter = @formatters[kind] ||= missing_formatter(kind)
      begin
        return eval formatter
      rescue
        return failed_formatter(lines, formatter, $!)
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return an expression for formatting classified lines of some kind that
doesn’t have such a formatting expression already specified.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def missing_formatter(kind)
      @errors &lt;&lt; &quot;No formatter specified for lines of kind: #{kind}&quot;
      return &quot;Formatter.lines_to_pre_html(lines, :class =&gt; 'missing formatter error')&quot;
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format classified lines as HTML if the original specified formatting
expression failed.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def failed_formatter(lines, formatter, exception)
      @errors &lt;&lt; &quot;Formatter: #{formatter} for lines of kind: #{lines.last.kind} failed with exception: #{exception}&quot;
      return Formatter.lines_to_pre_html(lines, :class =&gt; &quot;failed formatter error&quot;)
    end

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#basic-formatters'>Basic formatters</a>
</pre>
<pre class='sunlight-highlight-ruby'>

  end

end
</pre>
</div>
</div>
</p>
<h4>Basic formatters</h4>
<p>
The implementation contains some basic formatting functions. These are
sufficient for generic source code processing.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="basic-formatters">
<span>Basic formatters</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a group of consecutive indented lines into a group with a single
classified “line”. The given block is passed the joined content of all
the lines, and may process it to yield the merged “line” content. If an
explicit indentation is given, it overrides each line’s indentation. This
is useful for avoiding the inclusion of the indentation in the payload.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.merge_lines(lines, kind, indentation = nil)
  payload = yield lines.map { |line| (indentation || line.indentation || &quot;&quot;) + (line.payload || &quot;&quot;) }.join(&quot;\n&quot;)
  merged_line = lines[0]
  merged_line.merge!(&quot;kind&quot; =&gt; kind, &quot;payload&quot; =&gt; payload)
  merged_line.delete(&quot;indentation&quot;) if indentation.nil?
  return [ merged_line ]
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a group of consecutive HTML classified lines into a group with a
single HTML classified “line”. This is the default formatting
expression for HTML lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.merge_html_lines(lines)
  return Formatter.merge_lines(lines, &quot;html&quot;) { |payload| payload }
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format classified lines into HTML using a pre element with optional
attributes. This is the default formatting expression for classified lines
of unknown kinds.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.lines_to_pre_html(lines, attributes = {})
  return Formatter.merge_lines(lines, &quot;html&quot;) do |payload|
    ( &quot;&lt;pre&quot; + Formatter.html_attributes(attributes) + &quot;&gt;\n&quot; \
    + CGI.escapeHTML(payload) + &quot;\n&quot; \
    + &quot;&lt;/pre&gt;&quot; )
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert an attribute mapping to HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.html_attributes(attributes)
  return &quot;&quot; if attributes == {}
  return &quot; &quot; + attributes.map { |name, value| &quot;#{name}='#{CGI.escapeHTML(value.to_s)}'&quot; }.join(&quot; &quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format classified lines that indicate a nested chunk to HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.nested_chunk_lines_to_html(lines)
  return lines.each do |line|
    line.kind = &quot;html&quot;
    chunk_name = line.payload
    line.payload = &quot;&lt;pre class='nested chunk'&gt;\n&quot; \
                 + (line.indentation || &quot;&quot;) \
                 + &quot;&lt;a class='nested chunk' href='##{chunk_name.to_id}'&gt;#{CGI.escapeHTML(chunk_name)}&lt;/a&gt;\n&quot; \
                 + &quot;&lt;/pre&gt;&quot;
    line.delete(&quot;indentation&quot;)
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Indent arbitrary HTML lines to line up with the rest of the lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.unindented_lines_to_html(lines)
  merged_line = lines[0]
  html = lines.map { |line| line.payload + &quot;\n&quot; }.join
  merged_line.payload = self.indent_html(merged_line.indentation, html)
  merged_line.kind = &quot;html&quot;
  return [ merged_line ]
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Indent a chunk of HTML by some spaces. This uses a table, which is arguably
the wrong way to do it.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.indent_html(indentation, html)
  return html.chomp if indentation.nil?
  return &quot;&lt;table class='layout'&gt;\n&lt;tr&gt;\n&quot; \
       + &quot;&lt;td class='indentation'&gt;\n&quot; \
       + &quot;&lt;pre&gt;#{indentation}&lt;/pre&gt;\n&quot; \
       + &quot;&lt;/td&gt;\n&quot; \
       + &quot;&lt;td class='html'&gt;\n&quot; \
       + html \
       + &quot;&lt;/td&gt;\n&quot; \
       + &quot;&lt;/tr&gt;\n&lt;/table&gt;&quot;
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Cast a sequence of classified lines into a different kind without any
processing.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.cast_lines(lines, kind)
  lines = lines.dup
  lines.each { |line| line.kind = kind }
  return lines
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a sequence of marked-up classified lines to (unindented) HTML
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.markup_lines_to_html(lines, klass)
  implementation = String === klass ? Kernel.const_get(klass) : klass
  return Formatter.merge_lines(lines, &quot;unindented_html&quot;, &quot;&quot;) do |payload|
    ( &quot;&lt;div class='#{klass.downcase} #{lines[0].kind} markup'&gt;\n&quot; \
    + implementation.to_html(payload) \
    + &quot;&lt;/div&gt;&quot; )
  end
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-formatter-rb">lib/codnar/formatter.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Markup formats</h4>
<p>
The <code>markup_lines_to_html</code> formatter above relies on the existence of a class
for converting comments from the specific markup format to HTML. Currently, two
such formats are supported:
</p>
<ul>
<li>
<p>
RDoc, the default markup format used in Ruby comments. Here is a simple test
that demonstrates using RDoc:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-expand-rdoc-rb">
<span>test/expand_rdoc.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test expanding RDoc text.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestExpandRDoc &lt; Test::Unit::TestCase

    def test_emphasis_text
      RDoc.to_html(&quot;_text_&quot;).should == &quot;&lt;p&gt;\n&lt;em&gt;text&lt;/em&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_strong_text
      RDoc.to_html(&quot;*text*&quot;).should == &quot;&lt;p&gt;\n&lt;b&gt;text&lt;/b&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_indented_pre
      RDoc.to_html(&quot;base\n  indented\n    more\nback\n&quot;).should \
        == &quot;&lt;p&gt;\nbase\n&lt;/p&gt;\n&lt;pre&gt;\nindented\n  more\n&lt;/pre&gt;\n&lt;p&gt;\nback\n&lt;/p&gt;\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-rdoc-rb">
<span>lib/codnar/core_ext/rdoc.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand RDoc text with some Codnar extensions.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
module RDoc

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process a RDoc String and return the resulting HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.to_html(rdoc)
    return ::RDoc::Markup::ToHtml.new.convert(rdoc).clean_markup_html
  end

end
</pre>
</div>
</div>
</p>
</li>
<li>
<p>
Markdown, a generic markup syntax used across many systems and languages.
Here is a simple test that demonstrates using Markdown:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-expand-markdown-rb">
<span>test/expand_markdown.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test expanding Markdown text.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestExpandMarkdown &lt; Test::Unit::TestCase

    def test_emphasis_text
      Markdown.to_html(&quot;*text*&quot;).should == &quot;&lt;p&gt;\n&lt;em&gt;text&lt;/em&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_strong_text
      Markdown.to_html(&quot;**text**&quot;).should == &quot;&lt;p&gt;\n&lt;strong&gt;text&lt;/strong&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_embed_chunk
      Markdown.to_html(&quot;[[Chunk|template]]&quot;).should == &quot;&lt;p&gt;\n&lt;embed src='chunk' type='x-codnar/template'/&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_embed_anchor
      Markdown.to_html(&quot;[[#Name]]&quot;).should == &quot;&lt;p&gt;\n&lt;a id='name'/&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_embed_link
      Markdown.to_html(&quot;[Label](#Name)&quot;).should == &quot;&lt;p&gt;\n&lt;a href=\&quot;#name\&quot;&gt;Label&lt;/a&gt;\n&lt;/p&gt;\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-markdown-rb">
<span>lib/codnar/core_ext/markdown.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand Markdown text with some Codnar extensions.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
class Markdown

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process a Markdown String and return the resulting HTML. In addition to the
normal Markdown syntax, processing supports the following Codnar-specific
extensions:
</p>
<ul><li>
<p>
The notation “[[chunk|template]]” is expanded to embedding the
specified chunk (name) using the specified template at Weave time.
</p>
</li><li>
<p>
The notation “[[#name]]” defines an empty anchor. The HTML anchor id is
not the specified name, but rather the identifier generated from it (in the
same way that chunk names are converted to identifiers).
</p>
</li><li>
<p>
The notation “[…](#name)” defines a link to an anchor, which is
either the chunk with the specified name, or an empty anchor defined as
above.
</p>
</li></ul>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.to_html(markdown)
    markdown = Markdown.embed_chunks(markdown)
    markdown = Markdown.id_anchors(markdown)
    html = RDiscount.new(markdown).to_html
    html = Markdown.id_links(html)
    return html.clean_markup_html
  end

protected

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand “[[chunk|template]]” to HTML embed tags. Use identifiers instead
of names in the <tt>src</tt> field for safety, unless the template is a
magical file template, in which case we must preserve the file path,
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.embed_chunks(markdown)
    return markdown.gsub(/\[\[(.*?)\|(.*?)\]\]/) do
      src = $1
      template = $2
      src = src.to_id unless Codnar::Weaver::FILE_TEMPLATE_PROCESSORS.include?(template)
      &quot;&lt;embed src='#{src}' type='x-codnar/#{template}'/&gt;&quot;
    end
  end

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand “[[#name]]” anchors to HTML anchor tags with the matching
identifier.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.id_anchors(markdown)
    return markdown.gsub(/\[\[#(.*?)\]\]/) { &quot;&lt;a id='#{$1.to_id}'/&gt;&quot; }
  end

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand “href=‘#name’” links to the matching “href=‘#id’”
links.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.id_links(html)
    return html.gsub(/href=([&quot;'])#(.*?)([&quot;'])/) { &quot;href=#{$1}##{$2.to_id}#{$3}&quot; }
  end

end
</pre>
</div>
</div>
</p>
</li>
</ul>


<h4>Syntax highlighting using GVIM</h4>
<p>
If you have <code>gvim</code> istalled, it is possible to use it to generate syntax
highlighting. This is a <em>slow</em> operation, as <code>gvim</code> was never meant to be used
as a command-line tool. However, what it lacks in speed it compensates for in
scope; almost any language you can think of has a <code>gvim</code> syntax highlighting
definition. Here is a simple test that demonstrates using <code>gvim</code> for syntax
highlighting:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-gvim-highlight-syntax-rb">
<span>test/gvim_highlight_syntax.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test highlighting syntax using GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestGVimHighlightSyntax &lt; Test::Unit::TestCase

    def test_ruby_no_css
      ruby = &lt;&lt;-EOF.unindent
        def foo
          return bar = baz
        end
      EOF
      Codnar::GVim.syntax_to_html(ruby, &quot;ruby&quot;).should == &lt;&lt;-EOF.unindent #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;div class='ruby code syntax' bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;
        &lt;font face=&quot;monospace&quot;&gt;
        &lt;font color=&quot;#ff40ff&quot;&gt;def&lt;/font&gt;&amp;nbsp;&lt;font color=&quot;#00ffff&quot;&gt;foo&lt;/font&gt;&lt;br /&gt;
        &amp;nbsp;&amp;nbsp;&lt;font color=&quot;#ffff00&quot;&gt;return&lt;/font&gt;&amp;nbsp;bar = baz&lt;br /&gt;
        &lt;font color=&quot;#ff40ff&quot;&gt;end&lt;/font&gt;&lt;br /&gt;
        &lt;/font&gt;
        &lt;/div&gt;
      EOF
</pre>
<pre class='sunlight-highlight-ruby'>
      #! ))) html
    end

    def test_ruby_css
      ruby = &lt;&lt;-EOF.unindent
        def foo
          return bar = baz
        end
      EOF
      Codnar::GVim.syntax_to_html(ruby, &quot;ruby&quot;, [ &quot;+:let html_use_css=1&quot; ]).should == &lt;&lt;-EOF.unindent #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;pre class='ruby code syntax'&gt;
        &lt;span class=&quot;PreProc&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;foo&lt;/span&gt;
          &lt;span class=&quot;Statement&quot;&gt;return&lt;/span&gt; bar = baz
        &lt;span class=&quot;PreProc&quot;&gt;end&lt;/span&gt;
        &lt;/pre&gt;
      EOF
</pre>
<pre class='sunlight-highlight-ruby'>
      #! ))) html
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-gvim-rb">
<span>lib/codnar/gvim.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Syntax highlight using GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class GVim

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a sequence of classified code lines to HTML using GVim syntax
highlighting. The commands array allows configuring the way that GVim will
format the output (see the <tt>syntax_to_html</tt> method for details).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.lines_to_html(lines, syntax, commands = [])
      return Formatter.merge_lines(lines, &quot;html&quot;) do |payload|
        GVim.syntax_to_html(payload + &quot;\n&quot;, syntax, commands).chomp
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Highlight syntax of text using GVim. This uses the GVim standard CSS
classes to mark keywords, identifiers, and so on. See the GVim
documentation for details. The commands array allows configuring the way
that GVim will format the output. For example:
</p>
<ul><li>
<p>
The command “+:colorscheme &lt;name&gt;” will override the default
color scheme used.
</p>
</li><li>
<p>
The command “+:let html_use_css=1” will just annotate each HTML tag
with a CSS class, instead of embedding some specific style directly into
the tag. In this case the colorscheme and background are ignored; you will
need to provide your own CSS stylesheet as part of the final woven document
to style the marked-up words.
</p>
</li></ul>
<p>
Additional commands may be useful; GVim provides a full scripting
environment so there is no theoretical limit to what can be done here.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.syntax_to_html(text, syntax, commands = [])
      file = write_temporary_file(text)
      run_gvim(file, syntax, commands)
      html = read_html_file(file)
      delete_temporary_files(file)
      return clean_html(html, syntax)
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write the text to highlight the syntax of into a temporary file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.write_temporary_file(text)
      file = Tempfile.open(&quot;codnar-&quot;)
      file.write(text)
      file.close(false)
      return file
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run GVim to highlight the syntax of a temporary file. This uses the
little-known ability of GVim to emit the syntax highlighting as HTML using
only command-line arguments.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.run_gvim(file, syntax, commands)
      path = file.path
      ENV[&quot;DISPLAY&quot;] = &quot;none&quot; # Otherwise the X11 server *does* affect the result.
      command = [
        &quot;gvim&quot;,
        &quot;-f&quot;, &quot;-X&quot;,
        &quot;-u&quot;, &quot;none&quot;,
        &quot;-U&quot;, &quot;none&quot;,
        &quot;+:let html_ignore_folding=1&quot;,
        &quot;+:let use_xhtml=1&quot;,
        &quot;+:let html_use_css=0&quot;,
        &quot;+:syn on&quot;,
        &quot;+:set syntax=#{syntax}&quot;,
        commands,
        &quot;+run! syntax/2html.vim&quot;,
        &quot;+:f #{path}&quot;,
        &quot;+:wq&quot;, &quot;+:q&quot;,
        path
      ]
      system(&quot;echo '\n' | '#{command.flatten.join(&quot;' '&quot;)}' &gt; /dev/null 2&gt;&amp;1&quot;)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Read the HTML with the syntax highlighting written out by GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.read_html_file(file)
      return File.read(file.path + &quot;.xhtml&quot;)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Delete both the text and HTML temporary files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.delete_temporary_files(file)
      File.delete(file.path + &quot;.xhtml&quot;)
      file.delete
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extract the clean highlighted syntax HTML from GVim’s HTML output.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.clean_html(html, syntax)
      if html =~ /&lt;pre&gt;/
        html.sub!(/.*?&lt;pre&gt;/m, &quot;&lt;pre class='#{syntax} code syntax'&gt;&quot;)
        html.sub!(&quot;&lt;/body&gt;\n&lt;/html&gt;\n&quot;, &quot;&quot;)
      else
        html.sub!(/.*?&lt;body/m, &quot;&lt;div class='#{syntax} code syntax'&quot;)
        html.sub!(&quot;&lt;/body&gt;\n&lt;/html&gt;\n&quot;, &quot;&lt;/div&gt;\n&quot;)
      end
      return html
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Syntax highlighting using Sunlight</h4>
<p>
<a href="http://sunlightjs.com/">Sunlight</a> offers a different approach for syntax
highlighting. Instead of pre-processing the code to generate highlighted HTML
while splitting, it provides Javascript files that examine the textual code in
the DOM and convert it to highlighted HTML in the browser. This takes virtually
no time when splitting the code, but requires recomputing highlighting for all
the code chunks every time the HTML file is loaded. This can be pretty slow,
especially if using a browser with a slow Javascript engine, like IE. However,
given how slow GVIM is, this is a reasonable trade-off, at least for small
projects. Since Sunlight is a new project, it doesn't offer the extensive
coverage of different programming languages supported by GVIM.
</p>
<p>
Here is a simple test that demonstrates using Sunlight for syntax highlighting:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-sunlight-highlight-syntax-rb">
<span>test/sunlight_highlight_syntax.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test highlighting syntax using Sunlight.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSunlightHighlightSyntax &lt; Test::Unit::TestCase

    def test_sunlight_lines
      Sunlight.lines_to_html([
        { &quot;kind&quot; =&gt; &quot;ruby_code&quot;, &quot;number&quot; =&gt; 1, &quot;indentation&quot; =&gt; &quot;&quot;,   &quot;payload&quot; =&gt; &quot;def foo&quot;  },
        { &quot;kind&quot; =&gt; &quot;ruby_code&quot;, &quot;number&quot; =&gt; 2, &quot;indentation&quot; =&gt; &quot;  &quot;, &quot;payload&quot; =&gt; &quot;return 1&quot; },
        { &quot;kind&quot; =&gt; &quot;ruby_code&quot;, &quot;number&quot; =&gt; 3, &quot;indentation&quot; =&gt; &quot;&quot;,   &quot;payload&quot; =&gt; &quot;end&quot;      },
      ], &quot;ruby&quot;).should == [
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1,
          &quot;payload&quot; =&gt; &lt;&lt;-EOF.unindent.chomp
            &lt;pre class='sunlight-highlight-ruby'&gt;
            def foo
              return 1
            end
            &lt;/pre&gt;
          EOF
        },
      ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-sunlight-rb">
<span>lib/codnar/sunlight.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Syntax highlight using Sunlight.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Sunlight

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a sequence of classified code lines to HTML using Sunlight syntax
highlighting. All we need to do is wrap the lines in an HTML <tt>pre</tt>
element with the correct class
(<tt>sunlight</tt>-<tt>highlight</tt>-<em>syntax</em>). The actual
highlighting is done in the HTML DOM using Javascript. Embedding this
Javascript into the final HTML should be done separately.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.lines_to_html(lines, syntax)
      return Formatter.lines_to_pre_html(lines, :class =&gt; &quot;sunlight-highlight-#{syntax}&quot;)
    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Putting it all together</h3>
<p>
Now that we have all the separate pieces of functionality for splitting source
files into HTML chunks, we need to combine them to a single convenient service.
</p>
<h4>Splitting code files</h4>
<p>
Here is a simple test that demonstrates using the splitter for source code
files:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-code-rb">
<span>test/split_code.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test splitting code files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitCode &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithTempfile

    def test_split_ruby
      splitter = Splitter.new(@errors, RUBY_CONFIGURATION)
      path = write_tempfile(&quot;ruby.rb&quot;, RUBY_FILE)
      chunks = splitter.chunks(path)
      @errors.should == []
      chunks.should == ruby_chunks(path)
    end

  protected

    def ruby_chunks(path)
      RUBY_CHUNKS[0].name = path
      RUBY_CHUNKS[1].containers[0] = path
      RUBY_CHUNKS.each { |chunk| chunk.locations[0].file = path }
      return RUBY_CHUNKS
    end

    RUBY_FILE = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #! This is *rdoc*.
        #! {{{ assignment
        local = $global
          indented
        #! }}}
    EOF

    RUBY_CONFIGURATION = {
      &quot;formatters&quot; =&gt; {
        &quot;code&quot; =&gt; &quot;Formatter.cast_lines(lines, 'ruby')&quot;,
        &quot;comment&quot; =&gt; &quot;Formatter.cast_lines(lines, 'rdoc')&quot;,
        &quot;ruby&quot; =&gt; &quot;GVim.lines_to_html(lines, 'ruby')&quot;,
        &quot;rdoc&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'RDoc')&quot;,
        &quot;begin_chunk&quot; =&gt; &quot;[]&quot;,
        &quot;end_chunk&quot; =&gt; &quot;[]&quot;,
        &quot;nested_chunk&quot; =&gt; &quot;Formatter.nested_chunk_lines_to_html(lines)&quot;,
        &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
      },
      &quot;syntax&quot; =&gt; {
        &quot;start_state&quot; =&gt; &quot;ruby&quot;,
        &quot;patterns&quot; =&gt; {
          &quot;comment&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#\\s*(.*)$&quot; },
          &quot;code&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)(.*)$&quot; },
          &quot;begin_chunk&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)\\W*\\{\\{\\{\\s*(.*?)\\s*$&quot; },
          &quot;end_chunk&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)\\W*\\}\\}\\}\\s*(.*?)\\s*$&quot; },
        },
        &quot;states&quot; =&gt; {
          &quot;ruby&quot; =&gt; {
            &quot;transitions&quot; =&gt; [
              { &quot;pattern&quot; =&gt; &quot;begin_chunk&quot; },
              { &quot;pattern&quot; =&gt; &quot;end_chunk&quot; },
              { &quot;pattern&quot; =&gt; &quot;comment&quot; },
              { &quot;pattern&quot; =&gt; &quot;code&quot; },
            ],
          },
        },
      },
    }

    RUBY_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;PATH&quot;,
      &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;PATH&quot;, &quot;line&quot; =&gt; 1 ],
      &quot;containers&quot; =&gt; [],
      &quot;contained&quot; =&gt; [ &quot;assignment&quot; ],
      &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent.chomp, #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;table class='layout'&gt;
        &lt;tr&gt;
        &lt;td class='indentation'&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class='html'&gt;
        &lt;div class='rdoc rdoc markup'&gt;
        &lt;p&gt;
        This is &lt;b&gt;rdoc&lt;/b&gt;.
        &lt;/p&gt;
        &lt;/div&gt;
        &lt;/td&gt;
        &lt;/tr&gt;
        &lt;/table&gt;
        &lt;pre class='nested chunk'&gt;
          &lt;a class='nested chunk' href='#assignment'&gt;assignment&lt;/a&gt;
        &lt;/pre&gt;
      EOF
</pre>
<pre class='sunlight-highlight-ruby'>
      #! ))) html
    }, {
      &quot;name&quot; =&gt; &quot;assignment&quot;,
      &quot;containers&quot; =&gt; [ &quot;PATH&quot; ],
      &quot;contained&quot; =&gt; [],
      &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;PATH&quot;, &quot;line&quot; =&gt; 2 ],
      &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent.chomp, #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;div class='ruby code syntax' bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;
        &lt;font face=&quot;monospace&quot;&gt;
        local =&amp;nbsp;&lt;font color=&quot;#00ffff&quot;&gt;$global&lt;/font&gt;&lt;br /&gt;
        &amp;nbsp;&amp;nbsp;indented&lt;br /&gt;
        &lt;/font&gt;
        &lt;/div&gt;
      EOF
</pre>
<pre class='sunlight-highlight-ruby'>
      #! ))) html
    } ]

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-splitter-rb">
<span>lib/codnar/splitter.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split disk files into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Splitter

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Construct a splitter based on a configuration in the following structure:
</p>
<pre>
syntax: &lt;syntax&gt;
formatters:
  &lt;kind&gt;: &lt;expression&gt;
</pre>
<p>
Where the syntax is passed as-is to (and expanded in-place by) a Scanner,
and the formatters are passed as-is to a Formatter to convert the chunk’s
classified lines into HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(errors, configuration)
      @errors = errors
      @configuration = configuration
      @scanner = Scanner.new(errors, configuration.syntax)
      @formatter = Formatter.new(errors, configuration.formatters)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split a disk file into HTML chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def chunks(path)
      lines = @scanner.lines(path)
      chunks = Merger.chunks(@errors, path, lines)
      chunks.each { |chunk| chunk.html = @formatter.lines_to_html(chunk.delete(&quot;lines&quot;)) }
      return chunks
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Splitting documentation files</h4>
<p>
The narrative documentation is expected to reside in one or more files, which
are also "split" to a single chunk each. Having both documentation and code
exist as chunks allows for uniform treatment of both when weaving, as well as
allowing for pre-processing the documentation files, if necessary. For example,
Codnar currently supports for documentation the same two markup formats that
are also supported for code comments. Here is a simple test that demonstrates
"splitting" documentation (using the same implementation as above):
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-documentation-rb">
<span>test/split_documentation.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test “splitting” documentation files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitDocumentation &lt; Test::Unit::TestCase
  
    include TestWithErrors
    include TestWithFakeFS

    def test_split_raw
      File.open(&quot;raw.html&quot;, &quot;w&quot;) { |file| file.write(&quot;&lt;foo&gt;\nbar\n&lt;/foo&gt;\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;html&quot;))
      chunks = splitter.chunks(&quot;raw.html&quot;)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;raw.html&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;raw.html&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;foo&gt;\nbar\n&lt;/foo&gt;&quot;
      } ]
    end

    def test_split_markdown
      File.open(&quot;markdown.md&quot;, &quot;w&quot;) { |file| file.write(&quot;*foo*\nbar\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;markdown&quot;))
      chunks = splitter.chunks(&quot;markdown.md&quot;)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;markdown.md&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;markdown.md&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;div class='markdown markdown markup'&gt;\n&lt;p&gt;\n&lt;em&gt;foo&lt;/em&gt;\nbar\n&lt;/p&gt;\n&lt;/div&gt;&quot;
      } ]
    end

    def test_split_rdoc
      File.open(&quot;rdoc.rdoc&quot;, &quot;w&quot;) { |file| file.write(&quot;*foo*\nbar\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;rdoc&quot;))
      chunks = splitter.chunks(&quot;rdoc.rdoc&quot;)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;rdoc.rdoc&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;rdoc.rdoc&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;div class='rdoc rdoc markup'&gt;\n&lt;p&gt;\n&lt;b&gt;foo&lt;/b&gt; bar\n&lt;/p&gt;\n&lt;/div&gt;&quot;
      } ]
    end

    def test_split_unknown_kind
      File.open(&quot;unknown.kind&quot;, &quot;w&quot;) { |file| file.write(&quot;foo\nbar\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;unknown-kind&quot;))
      chunks = splitter.chunks(&quot;unknown.kind&quot;)
      @errors.should == [ &quot;#{$0}: No formatter specified for lines of kind: unknown-kind&quot; ]
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;unknown.kind&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;unknown.kind&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;pre class='missing formatter error'&gt;\nfoo\nbar\n&lt;/pre&gt;&quot;
      } ]
    end

  protected

    def configuration(kind)
      return {
        &quot;formatters&quot; =&gt; {
          &quot;markdown&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'Markdown')&quot;,
          &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
          &quot;rdoc&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'RDoc')&quot;,
        },
        &quot;syntax&quot; =&gt; {
          &quot;start_state&quot; =&gt; kind,
          &quot;patterns&quot; =&gt; {
            kind =&gt; { &quot;regexp&quot; =&gt; &quot;^(.*)$&quot;, &quot;groups&quot; =&gt; [ &quot;payload&quot; ] },
          },
          &quot;states&quot; =&gt; {
            kind =&gt; {
              &quot;transitions&quot; =&gt; [
                { &quot;pattern&quot; =&gt; kind }
              ]
            }
          }
        }
      }
    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Built-in configurations</h3>
<p>
The splitting mechanism defined above is pretty generic. To apply it to a
specific system requires providing the appropriate configuration. The system
provides a few specific built-in configurations which may be useful "out of the
box".
</p>
<p>
If one is willing to give up altogether on syntax highlighting and comment
formatting, the system would be applicable as-is to any programming language.
Properly highlighting almost any known programming language syntax would be a
simple matter of passing the correct syntax parameter to GVIM.
</p>
<p>
Properly formatting comments in additional mark-up formats would be trickier.
First, a proper pattern needs to be established for extracting the comments
(<code>/*</code>, <code>//</code>, <code>--</code>, etc.). Them, the results need to be converted to HTML. One
way would be to pass them through GVim syntax highlighting with an appropriate
format (e.g, <code>syntax=doxygen</code>). Another would be to invoke some Ruby library;
finally, one could invoke some external tool to do the job. The latter two
options would require providing additional glue Ruby code, similar to the GVim
class above.
</p>
<p>
At any rate, here are the built-in configurations:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-configuration-rb">
<span>lib/codnar/configuration.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A module for all the “built-in” configurations. The names of these
configurations can be passed to the –require option of any Codnar
Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module Configuration

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#documentation-splitting-configurations'>Documentation &quot;splitting&quot; configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#source-code-lines-classification-configurations'>Source code lines classification configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#nested-foreign-syntax-code-islands-configurations'>Nested foreign syntax code islands configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#simple-comment-classification-configurations'>Simple comment classification configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#complex-comment-classification-configurations'>Complex comment classification configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#comment-formatting-configurations'>Comment formatting configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>
    
</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#gvim-syntax-highlighting-formatting-configurations'>GVim syntax highlighting formatting configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#sunlight-syntax-highlighting-formatting-configurations'>Sunlight syntax highlighting formatting configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#chunk-splitting-configurations'>Chunk splitting configurations</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#weaving-templates'>Weaving templates</a>
</pre>
<pre class='sunlight-highlight-ruby'>

  end

end
</pre>
</div>
</div>
</p>
<p>
(Built-in weaving templates are described later.)
</p>
<h4>Combining configurations</h4>
<p>
Different source files require different overall configurations but reuse
common building blocks. To support it, we allow comfigurations to be combined
using a "deep merge". This allows complex nested structures to be merged. There
is even a way for arrays to append elements before/after the array they are
merged with. Here is a simple test that demonstrates deep-merging complex
structures:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-deep-merge-rb">
<span>test/deep_merge.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test deep-merging complex structures.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestDeepMerge &lt; Test::Unit::TestCase

    def test_deep_merge
      default = {
        &quot;only_default&quot; =&gt; &quot;default_value&quot;,
        &quot;overriden&quot; =&gt; &quot;default_value&quot;,
        &quot;overriden_array&quot; =&gt; [ &quot;default_value&quot; ],
        &quot;merged_array&quot; =&gt; [ &quot;default_value&quot; ],
      }
      override = {
        &quot;only_override&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden_array&quot; =&gt; [ &quot;overriden_value&quot; ],
        &quot;merged_array&quot; =&gt; [ &quot;overriden_value&quot;, [] ],
      }
      default.deep_merge(override).should == {
        &quot;only_default&quot; =&gt; &quot;default_value&quot;,
        &quot;only_override&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden_array&quot; =&gt; [ &quot;overriden_value&quot; ],
        &quot;merged_array&quot; =&gt; [ &quot;overriden_value&quot;, &quot;default_value&quot; ],
      }
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="deep-merge">
<span>Deep merge</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Perform a deep merge with another hash.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def deep_merge(hash)
    return merge(hash, &amp;Hash::method(&quot;deep_merger&quot;))
  end

protected

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return a Hash merger that recursively merges nested hashes.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.deep_merger(key, default, override)
    if Hash === default &amp;&amp; Hash === override
      default.deep_merge(override)
    elsif Array === default &amp;&amp; Array === override
      Hash.deep_merge_arrays(default, override)
    else
      override
    end
  end

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
If the overriding data array contains an empty array element (“[]”), it
is replaced by the default data array being overriden.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  def self.deep_merge_arrays(default, override)
    embed_index = override.find_index([])
    return override unless embed_index
    override = override.dup
    override[embed_index..embed_index] = default
    return override
  end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-hash-rb">lib/codnar/core_ext/hash.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
And here is a test module that automates the process of merging configurations
and invoking the Splitter:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-test-with-configurations-rb">
<span>test/lib/test_with_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Tests with configurations. Requires also including TestWithTempfile.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module TestWithConfigurations

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running the Splitter with merged configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def check_split_file(file_text, *configurations, &amp;block)
      configuration = configurations.inject({}) do |merged_configuration, next_configuration|
        merged_configuration.deep_merge(next_configuration)
      end
      splitter = Splitter.new(@errors, configuration)
      chunks = splitter.chunks(path = write_tempfile(&quot;splitted&quot;, file_text))
      @errors.should == []
      chunks.should == yield(path)
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Documentation "splitting"</h4>
<p>
These are pretty simple configurations, applicable to files containing a piece
of the narrative in some supported format. These configurations typically do
not require to be combined with other configurations. Here is a simple test
that demonstrates "splitting" documentation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-documentation-configurations-rb">
<span>test/split_documentation_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
#! require &quot;test_with_fakefs&quot; - current version (0.3.1) does not work with tempfile.
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test the built-in split documentation configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitDocumentationConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    #! include TestWithFakeFS - until FakeFS fixes the tempfile issue.
    include TestWithConfigurations
    include TestWithTempfile

    HTML_FILE = &lt;&lt;-EOF.unindent #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
      &lt;p&gt;This is an
      HTML file.&lt;/p&gt;
    EOF
</pre>
<pre class='sunlight-highlight-ruby'>
    # ))) html

    def test_split_html_documentation
      check_split_file(HTML_FILE, Configuration::SPLIT_HTML_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; HTML_FILE.chomp
        } ]
      end
    end

    PRE_FILE = &lt;&lt;-EOF.unindent
      This is a preformatted
      raw text file.
    EOF

    def test_split_pre_documentation
      check_split_file(PRE_FILE, Configuration::SPLIT_PRE_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; &quot;&lt;pre class='doc'&gt;\n&quot; + PRE_FILE + &quot;&lt;/pre&gt;&quot;
        } ]
      end
    end

    MARKUP_FILE = &lt;&lt;-EOF.unindent
      This is a
      *marked-up* file.
    EOF

    RDOC_HTML = &lt;&lt;-EOF.unindent.chomp #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
      &lt;div class='rdoc doc markup'&gt;
      &lt;p&gt;
      This is a &lt;b&gt;marked-up&lt;/b&gt; file.
      &lt;/p&gt;
      &lt;/div&gt;
    EOF
</pre>
<pre class='sunlight-highlight-ruby'>
    # ))) html

    def test_split_rdoc_documentation
      check_split_file(MARKUP_FILE, Configuration::SPLIT_RDOC_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; RDOC_HTML,
        } ]
      end
    end

    MARKDOWN_HTML = &lt;&lt;-EOF.unindent.chomp #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
      &lt;div class='markdown doc markup'&gt;
      &lt;p&gt;
      This is a
      &lt;em&gt;marked-up&lt;/em&gt; file.
      &lt;/p&gt;
      &lt;/div&gt;
    EOF
</pre>
<pre class='sunlight-highlight-ruby'>
    #! ))) html

    def test_split_markdown_documentation
      check_split_file(MARKUP_FILE, Configuration::SPLIT_MARKDOWN_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; MARKDOWN_HTML,
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here are the actual configurations:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="documentation-splitting-configurations">
<span>Documentation &quot;splitting&quot; configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file. All lines are assumed to have the same
kind <tt>doc</tt> and no indentation is collected. Unless overriden by
additional configuration(s), the lines are assumed to contain formatted
HTML, and are passed as-is to the output.
</p>
<p>
This is the default configuration as it performs the minimal amount of
processing on the input. It isn’t the most useful configuration.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
SPLIT_HTML_DOCUMENTATION = {
  &quot;formatters&quot; =&gt; {
    &quot;doc&quot; =&gt; &quot;Formatter.cast_lines(lines, 'html')&quot;,
  },
  &quot;syntax&quot; =&gt; {
    &quot;patterns&quot; =&gt; {
      &quot;doc&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(.*)$&quot;, &quot;groups&quot; =&gt; [ &quot;payload&quot; ] },
    },
    &quot;states&quot; =&gt; {
      &quot;start&quot; =&gt; { &quot;transitions&quot; =&gt; [ { &quot;pattern&quot; =&gt; &quot;doc&quot; } ] },
    },
  },
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file containing arbitrary text, which is
preserved by escaping it and wrapping it in an HTML pre element.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
SPLIT_PRE_DOCUMENTATION = SPLIT_HTML_DOCUMENTATION.deep_merge(
  &quot;formatters&quot; =&gt; {
    &quot;doc&quot; =&gt; &quot;Formatter.lines_to_pre_html(lines, :class =&gt; :doc)&quot;,
  }
)

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file containing pure RDoc documentation.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
SPLIT_RDOC_DOCUMENTATION = SPLIT_HTML_DOCUMENTATION.deep_merge(
  &quot;formatters&quot; =&gt; {
    &quot;doc&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'RDoc')&quot;,
    &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
  }
)

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file containing pure Markdown documentation.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
SPLIT_MARKDOWN_DOCUMENTATION = SPLIT_HTML_DOCUMENTATION.deep_merge(
  &quot;formatters&quot; =&gt; {
    &quot;doc&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'Markdown')&quot;,
    &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
  }
)

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Source code lines classification</h4>
<p>
Splitting source code files is a more complex affair, which does typically
require combining several configurations. The basic configuration marks all
lines as belonging to some code syntax, as a single chunk:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="source-code-lines-classification-configurations">
<span>Source code lines classification configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify all lines as source code of some syntax (kind). This doesn’t
distinguish between comment and code lines; to do that, you need to combine
this with comment classification configuration(s). Also, it just formats
the lines in an HTML <tt>pre</tt> element, without any syntax highlighting;
to do that, you need to combine this with syntax highlighting formatting
configuration(s).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_SOURCE_CODE = lambda do |syntax|
  return {
    &quot;formatters&quot; =&gt; {
      &quot;#{syntax}_code&quot; =&gt; &quot;Formatter.lines_to_pre_html(lines, :class =&gt; :code)&quot;,
    },
    &quot;syntax&quot; =&gt; {
      &quot;patterns&quot; =&gt; {
        &quot;#{syntax}_code&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)(.*)$&quot; },
      },
      &quot;states&quot; =&gt; {
        &quot;start&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;#{syntax}_code&quot; },
          ],
        },
      },
    },
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Sometimes, a code in one syntax contains nested "islands" of code in another
syntax. Here is a simple configuration to support that, which can be combined
with the above basic configuration:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="nested-foreign-syntax-code-islands-configurations">
<span>Nested foreign syntax code islands configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Allow for comments containing “((( &lt;syntax&gt;” and “)))
&lt;syntax&gt;” to designate nested islands of foreign syntax inside the
normal code. The designator comment lines are always treated as part of the
surrounding code, not as part of the nested foreign syntax code. There is
no further classification of the nested foreign syntax code. Therefore, the
nested code is not examined for begin/end chunk markers. Likewise, the
nested code may not contain deeper nested code using a third syntax.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_NESTED_CODE = lambda do |outer_syntax, inner_syntax|
  {
    &quot;syntax&quot; =&gt; {
      &quot;patterns&quot; =&gt; {
        &quot;start_#{inner_syntax}_in_#{outer_syntax}&quot; =&gt;
          { &quot;regexp&quot; =&gt; &quot;^(\\s*)(.*\\(\\(\\(\\s*#{inner_syntax}.*)$&quot; },
        &quot;end_#{inner_syntax}_in_#{outer_syntax}&quot; =&gt; 
          { &quot;regexp&quot; =&gt; &quot;^(\\s*)(.*\\)\\)\\)\\s*#{inner_syntax}.*)$&quot; },
        &quot;#{inner_syntax}_in_#{outer_syntax}&quot; =&gt;
          { &quot;regexp&quot; =&gt; &quot;^(\\s*)(.*)$&quot; },
      },
      &quot;states&quot; =&gt; {
        &quot;start&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;start_#{inner_syntax}_in_#{outer_syntax}&quot;,
              &quot;kind&quot; =&gt; &quot;#{outer_syntax}_code&quot;,
              &quot;next_state&quot; =&gt; &quot;#{inner_syntax}_in_#{outer_syntax}&quot; },
            [],
          ],
        },
        &quot;#{inner_syntax}_in_#{outer_syntax}&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;end_#{inner_syntax}_in_#{outer_syntax}&quot;,
              &quot;kind&quot; =&gt; &quot;#{outer_syntax}_code&quot;,
              &quot;next_state&quot; =&gt; &quot;start&quot; },
            { &quot;pattern&quot; =&gt; &quot;#{inner_syntax}_in_#{outer_syntax}&quot;,
              &quot;kind&quot; =&gt; &quot;#{inner_syntax}_code&quot; },
          ],
        },
      },
    },
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating using source code lines classifications:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-code-configurations-rb">
<span>test/split_code_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test combinations of the built-in split code configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitCodeConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    SOURCE_CODE = &lt;&lt;-EOF.unindent
      a = b
      b = 1
    EOF

    def test_source_code
      check_split_file(SOURCE_CODE, Configuration::CLASSIFY_SOURCE_CODE.call(&quot;ruby&quot;)) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; &quot;&lt;pre class='code'&gt;\n#{SOURCE_CODE}&lt;/pre&gt;&quot;
        } ]
      end
    end

    ISLAND_CODE = &lt;&lt;-EOF.unindent
      a = b
      b = 1
      HTML = &lt;&lt;-EOH.unindent # ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;p&gt;
        HTML
        &lt;/p&gt;
      EOH
</pre>
<pre class='sunlight-highlight-ruby'>
      # ))) html
    EOF

    ISLAND_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='ruby code syntax'&gt;
      a = b
      b = &lt;span class=&quot;Constant&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;Type&quot;&gt;HTML&lt;/span&gt; = &amp;lt;&amp;lt;-&lt;span class=&quot;Special&quot;&gt;EOH&lt;/span&gt;.unindent &lt;span class=&quot;Comment&quot;&gt;# ((( html&lt;/span&gt;
</pre>
<pre class='sunlight-highlight-html'>
      &lt;/pre&gt;
      &lt;pre class='html code syntax'&gt;
        &lt;span class=&quot;Identifier&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;Statement&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;&amp;gt;&lt;/span&gt;
        HTML
        &lt;span class=&quot;Identifier&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;Statement&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;&amp;gt;&lt;/span&gt;
      EOH
      &lt;/pre&gt;
      &lt;pre class='ruby code syntax'&gt;
</pre>
<pre class='sunlight-highlight-ruby'>
      &lt;span class=&quot;Comment&quot;&gt;# ))) html&lt;/span&gt;
      &lt;/pre&gt;
    EOF

    def test_island_code
      check_split_file(ISLAND_CODE, Configuration::CLASSIFY_SOURCE_CODE.call(&quot;ruby&quot;),
                                    Configuration::FORMAT_CODE_GVIM_CSS.call(&quot;ruby&quot;),
                                    Configuration::CLASSIFY_NESTED_CODE.call(&quot;ruby&quot;, &quot;html&quot;),
                                    Configuration::FORMAT_CODE_GVIM_CSS.call(&quot;html&quot;)) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; ISLAND_HTML
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Simple comment classification</h4>
<p>
Many languages use a simple comment syntax, where some prefix indicates a
comment that spans until the end of the line (e.g., shell <code>#</code> comments or C++
<code>//</code> comments).
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="simple-comment-classification-configurations">
<span>Simple comment classification configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify simple comment lines. It accepts a restricted format: each comment
is expected to start with some exact prefix (e.g. “#” for shell style
comments or “//” for C++ style comments). The following space, if any,
is stripped from the payload. As a convenience, comment that starts with
“!” is not taken to start a comment. This both protects the 1st line of
shell scripts (“#!”), and also any other line you wish to avoid being
treated as a comment.
</p>
<p>
This configuration is typically complemented by an additional one
specifying how to format the (stripped!) comments; by default they are just
displayed as-is using an HTML <tt>pre</tt> element, which isn’t very
useful.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_SIMPLE_COMMENTS = lambda do |prefix|
  return Configuration.simple_comments(prefix)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify simple shell (“#”) comment lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_SHELL_COMMENTS = lambda do
  return Configuration.simple_comments(&quot;#&quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify simple C++ (“//”) comment lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_CPP_COMMENTS = lambda do
  return Configuration.simple_comments(&quot;//&quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Configuration for classifying lines to comments and code based on a simple
prefix (e.g. “#” for shell style comments or “//” for C++ style
comments).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.simple_comments(prefix)
  return {
    &quot;syntax&quot; =&gt; {
      &quot;patterns&quot; =&gt; {
        &quot;comment_#{prefix}&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#{prefix}(?!!)\\s?(.*)$&quot; },
      },
      &quot;states&quot; =&gt; {
        &quot;start&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;comment_#{prefix}&quot;, &quot;kind&quot; =&gt; &quot;comment&quot; },
            []
          ],
        },
      },
    },
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating using simple comment classifications:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-simple-comment-configurations-rb">
<span>test/split_simple_comment_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test built-in split simple comment configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitSimpleCommentsConfigurations &lt; Test::Unit::TestCase
  
    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    def test_custom_comments
      check_any_comment(&quot;!&quot;, Configuration::CLASSIFY_SIMPLE_COMMENTS.call(&quot;!&quot;))
    end

    def test_shell_comments
      check_any_comment(&quot;#&quot;, Configuration::CLASSIFY_SHELL_COMMENTS.call)
    end

    def test_cpp_comments
      check_any_comment(&quot;//&quot;, Configuration::CLASSIFY_CPP_COMMENTS.call)
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The “?” will be replaced by the simple comment prefix.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    ANY_COMMENT_CODE = &lt;&lt;-EOF.unindent
      ?
      ? Comment
      Code
      ?! Not comment
    EOF

    def check_any_comment(prefix, configuration)
      check_split_file(ANY_COMMENT_CODE.gsub(&quot;?&quot;, prefix),
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;any&quot;),
                       Configuration::FORMAT_PRE_COMMENTS,
                       configuration) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; &quot;&lt;pre class='comment'&gt;\n\nComment\n&lt;/pre&gt;\n&lt;pre class='code'&gt;\nCode\n#{prefix}! Not comment\n&lt;/pre&gt;&quot;
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Complex comment classification</h4>
<p>
Other languages use a complex multi-line comment syntax, where some prefix
indicates the beginning of the comment, some suffix indicates the end, and by
convention some prefix is expected for the inner comment lines (e.g., C's
"<code>/*</code>", "<code>*</code>", "<code>*/</code>" comments or HTML's "<code>&lt;!--</code>", "<code>-</code>", "<code>--&gt;</code>" comments).
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="complex-comment-classification-configurations">
<span>Complex comment classification configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify complex comment lines. It accepts a restricted format: each
comment is expected to start with some exact prefix (e.g. “/*” for C
style comments or “&lt;!–” for HTML++ style comments). The following
space, if any, is stripped from the payload. Following lines are also
considered comments; a leading inner line prefix (e.g., “ *” for C
style comments or “ -” for HTML style comments) with an optional
following space are stripped from the payload. Finally, a line containing
some exact suffix (e.g. “*/” for C style comments, or “–&gt;” for
HTML style comments) ends the comment. A one line comment format is also
supported containing the prefix, the payload, and the suffix. As a
convenience, comment that starts with “!” is not taken to start a
comment. This allows protecting comment block you wish to avoid being
classified as a comment.
</p>
<p>
This configuration is typically complemented by an additional one
specifying how to format the (stripped!) comments; by default they are just
displayed as-is using an HTML <tt>pre</tt> element, which isn’t very
useful.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_COMPLEX_COMMENTS = lambda do |prefix, inner, suffix|
  return Configuration.complex_comments(prefix, inner, suffix)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify complex C (“/*”, “ *”, “ */”) style comments.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_C_COMMENTS = lambda do
</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Since the prefix/inner/suffix passed to the configuration are regexps, we
need to escape special characters such as “*”.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  return Configuration.complex_comments(&quot;/\\*&quot;, &quot; \\*&quot;, &quot; \\*/&quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify complex HTML (“&lt;!–”, “ -”, “–&gt;”) style
comments.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CLASSIFY_HTML_COMMENTS = lambda do
  return Configuration.complex_comments(&quot;&lt;!--&quot;, &quot; -&quot;, &quot;--&gt;&quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Configuration for classifying lines to comments and code based on a complex
start prefix, inner line prefix and final suffix (e.g., “/*”, “ *”,
“ */” for C-style comments or “&lt;!–”, “ -”, “–&gt;”
for HTML style comments).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.complex_comments(prefix, inner, suffix)
  return {
    &quot;syntax&quot; =&gt; {
      &quot;patterns&quot; =&gt; {
        &quot;comment_prefix_#{prefix}&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#{prefix}(?!!)\\s?(.*)$&quot; },
        &quot;comment_inner_#{inner}&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#{inner}\\s?(.*)$&quot; },
        &quot;comment_suffix_#{suffix}&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#{suffix}\\s*$&quot; },
        &quot;comment_line_#{prefix}_#{suffix}&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#{prefix}(?!!)\s?(.*?)\s*#{suffix}\\s*$&quot; },
      },
      &quot;states&quot; =&gt; {
        &quot;start&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;comment_line_#{prefix}_#{suffix}&quot;,
              &quot;kind&quot; =&gt; &quot;comment&quot; },
            { &quot;pattern&quot; =&gt; &quot;comment_prefix_#{prefix}&quot;,
              &quot;kind&quot; =&gt; &quot;comment&quot;,
              &quot;next_state&quot; =&gt; &quot;comment_#{prefix}&quot; },
            [],
          ],
        },
        &quot;comment_#{prefix}&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;comment_suffix_#{suffix}&quot;,
              &quot;kind&quot; =&gt; &quot;comment&quot;,
              &quot;next_state&quot; =&gt; &quot;start&quot; },
            { &quot;pattern&quot; =&gt; &quot;comment_inner_#{inner}&quot;,
              &quot;kind&quot; =&gt; &quot;comment&quot; },
          ],
        },
      },
    },
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating using complex comment classifications:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-complex-comment-configurations-rb">
<span>test/split_complex_comment_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test built-in split complex comment configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitComplexCommentsConfigurations &lt; Test::Unit::TestCase
  
    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    def test_custom_comments
</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Since the prefix/inner/suffix passed to the configuration are regexps, we
need to escape special characters such as “{” and “|”.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      check_any_comment([ &quot;@{&quot;, &quot; |&quot;, &quot; }@&quot; ], Configuration::CLASSIFY_COMPLEX_COMMENTS.call(&quot;@\\{&quot;, &quot; \\|&quot;, &quot; \\}@&quot;))
    end

    def test_c_comments
      check_any_comment([ &quot;/*&quot;, &quot; *&quot;, &quot; */&quot; ], Configuration::CLASSIFY_C_COMMENTS.call)
    end

    def test_html_comments
      check_any_comment([ &quot;&lt;!--&quot;, &quot; -&quot;, &quot;--&gt;&quot; ], Configuration::CLASSIFY_HTML_COMMENTS.call)
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The “&lt;&lt;&lt;” will be replaced by the complex comment prefix, the
“&lt;&gt;” will be replaced by the inner line comment prefix, and the
“&gt;&gt;&gt;” will be replaced by the complex comment suffix.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    ANY_COMMENT_CODE = &lt;&lt;-EOF.unindent
      /-- One-line comment --/
      Code
      /--
       - Multi-line
       - comment.
      --/
    EOF

    ANY_COMMENT_HTML = &lt;&lt;-EOF.unindent.chomp # ((( html
</pre>
<pre class='sunlight-highlight-html'>
      &lt;pre class='comment'&gt;
      One-line comment
      &lt;/pre&gt;
      &lt;pre class='code'&gt;
      Code
      &lt;/pre&gt;
      &lt;pre class='comment'&gt;

      Multi-line
      comment.

      &lt;/pre&gt;
    EOF
    # )))

    def check_any_comment(patterns, configuration)
      prefix, inner, suffix = patterns
      check_split_file(ANY_COMMENT_CODE.gsub(&quot;/--&quot;, prefix).gsub(&quot;--/&quot;, suffix).gsub(&quot; -&quot;, inner),
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;any&quot;),
                       Configuration::FORMAT_PRE_COMMENTS,
                       configuration) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; ANY_COMMENT_HTML.gsub(&quot;/--&quot;, prefix).gsub(&quot;--/&quot;, suffix).gsub(&quot; -&quot;, inner),
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Comment formatting</h4>
<p>
In many cases, the text inside comments is written using some markup format
(e.g., RDoc for Ruby or JavaDoc for Java). Currently, two such formats are
supported, as well as simply wrapping the comment in an HTML pre element:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="comment-formatting-configurations">
<span>Comment formatting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format comments as HTML pre elements. Is used to complement a configuration
that classifies some lines as <tt>comment</tt>.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
FORMAT_PRE_COMMENTS = {
  &quot;formatters&quot; =&gt; {
    &quot;comment&quot; =&gt; &quot;Formatter.lines_to_pre_html(lines, :class =&gt; :comment)&quot;,
  },
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format comments that use the RDoc notation. Is used to complement a
configuration that classifies some lines as <tt>comment</tt>.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
FORMAT_RDOC_COMMENTS = {
  &quot;formatters&quot; =&gt; {
    &quot;comment&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'RDoc')&quot;,
    &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
  },
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format comments that use the Markdown notation. Is used to complement a
configuration that classifies some lines as <tt>comment</tt>.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
FORMAT_MARKDOWN_COMMENTS = {
  &quot;formatters&quot; =&gt; {
    &quot;comment&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'Markdown')&quot;,
    &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
  },
}

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating formatting comment contents:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-format-comment-configurations-rb">
<span>test/format_comment_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test built-in split comment formatting configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestFormatCommentsConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    COMMENT_TEXT = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #! Comment *text*.
    EOF

    PRE_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='comment'&gt;
      Comment *text*.
      &lt;/pre&gt;
    EOF

    def test_pre_comments
      check_any_format(PRE_HTML, Configuration::FORMAT_PRE_COMMENTS)
    end

    RDOC_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;table class='layout'&gt;
      &lt;tr&gt;
      &lt;td class='indentation'&gt;
      &lt;pre&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class='html'&gt;
      &lt;div class='rdoc comment markup'&gt;
      &lt;p&gt;
      Comment &lt;b&gt;text&lt;/b&gt;.
      &lt;/p&gt;
      &lt;/div&gt;
      &lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
    EOF

    def test_rdoc_comments
      check_any_format(RDOC_HTML, Configuration::FORMAT_RDOC_COMMENTS)
    end

    MARKDOWN_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;table class='layout'&gt;
      &lt;tr&gt;
      &lt;td class='indentation'&gt;
      &lt;pre&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class='html'&gt;
      &lt;div class='markdown comment markup'&gt;
      &lt;p&gt;
      Comment &lt;em&gt;text&lt;/em&gt;.
      &lt;/p&gt;
      &lt;/div&gt;
      &lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
    EOF

    def test_markdown_comments
      check_any_format(MARKDOWN_HTML, Configuration::FORMAT_MARKDOWN_COMMENTS)
    end

  protected

    def check_any_format(html, configuration)
      check_split_file(COMMENT_TEXT,
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;any&quot;),
                       Configuration::CLASSIFY_SHELL_COMMENTS.call,
                       configuration) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; html,
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Syntax highlighting using GVim</h4>
<p>
Supporting a specific programming language (other than dealing with comments)
is very easy using GVim for syntax highlighting, as demonstrated here:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="gvim-syntax-highlighting-formatting-configurations">
<span>GVim syntax highlighting formatting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format code using GVim’s Ruby syntax highlighting, using explicit HTML
constructs. Assumes some previous configuration already classified the code
lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
FORMAT_CODE_GVIM_HTML = lambda do |syntax|
  return Configuration.gvim_code_format(syntax)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format code using GVim’s Ruby syntax highlighting, using CSS classes
instead of explicit font and color styles. Assumes some previous
configuration already classified the code lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
FORMAT_CODE_GVIM_CSS = lambda do |syntax|
  return Configuration.gvim_code_format(syntax, &quot;'+:let html_use_css=1'&quot;)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return a configuration for highlighting a specific syntax using GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.gvim_code_format(syntax, extra_commands = &quot;&quot;)
  return {
    &quot;formatters&quot; =&gt; {
      &quot;#{syntax}_code&quot; =&gt; &quot;GVim.lines_to_html(lines, '#{syntax}', [ #{extra_commands} ])&quot;,
    },
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating highlighting code syntax using <code>gvim</code>:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-format-code-gvim-configurations-rb">
<span>test/format_code_gvim_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test built-in split code formatting configurations using GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestGVimFormatCodeConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    CODE_TEXT_ = &lt;&lt;-EOF.unindent
      local = $global;
    EOF

    SUNLIGHT_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='sunlight-highlight-ruby'&gt;
      local = $global;
      &lt;/pre&gt;
    EOF

    def test_sunlight_code
      check_split_file(CODE_TEXT_,
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;ruby&quot;),
                       Configuration::FORMAT_CODE_SUNLIGHT.call(&quot;ruby&quot;)) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; SUNLIGHT_HTML,
        } ]
      end
    end

    CODE_TEXT = &lt;&lt;-EOF.unindent
      int x;
    EOF

    GVIM_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;div class='c code syntax' bgcolor=\&quot;#ffffff\&quot; text=\&quot;#000000\&quot;&gt;
      &lt;font face=\&quot;monospace\&quot;&gt;
      &lt;font color=\&quot;#00ff00\&quot;&gt;int&lt;/font&gt;&amp;nbsp;x;&lt;br /&gt;
      &lt;/font&gt;
      &lt;/div&gt;
    EOF

    def test_html_code
      check_any_code(GVIM_HTML, Configuration::FORMAT_CODE_GVIM_HTML.call(&quot;c&quot;))
    end

    GVIM_CSS = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='c code syntax'&gt;
      &lt;span class=\&quot;Type\&quot;&gt;int&lt;/span&gt; x;
      &lt;/pre&gt;
    EOF

    def test_css_code
      check_any_code(GVIM_CSS, Configuration::FORMAT_CODE_GVIM_CSS.call(&quot;c&quot;))
    end

  protected

    def check_any_code(html, configuration)
      check_split_file(CODE_TEXT,
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;c&quot;),
                       configuration) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; html,
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Syntax highlighting using Sunlight</h4>
<p>
For small projects in languages supported by Sunlight, you may choose to use
it instead of GVIM
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="sunlight-syntax-highlighting-formatting-configurations">
<span>Sunlight syntax highlighting formatting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format code using Sunlight’s syntax highlighting. This assumes the HTML
will include and invoke Sunlight’s Javascript file which does the
highlighting on the fly inside the DOM, instead of pre-computing it when
splitting the file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
FORMAT_CODE_SUNLIGHT = lambda do |syntax|
  return Configuration.sunlight_code_format(syntax)
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return a configuration for highlighting a specific syntax using Sunlight.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.sunlight_code_format(syntax)
  return {
    &quot;formatters&quot; =&gt; {
      &quot;#{syntax}_code&quot; =&gt; &quot;Sunlight.lines_to_html(lines, '#{syntax}')&quot;,
    },
  }
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating highlighting code syntax using Sunlight:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-format-code-sunlight-configurations-rb">
<span>test/format_code_sunlight_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test built-in split code formatting configurations using Sunlight.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSunlightFormatCodeConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    CODE_TEXT = &lt;&lt;-EOF.unindent
      local = $global;
    EOF

    SUNLIGHT_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='sunlight-highlight-ruby'&gt;
      local = $global;
      &lt;/pre&gt;
    EOF

    def test_sunlight_code
      check_split_file(CODE_TEXT,
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;ruby&quot;),
                       Configuration::FORMAT_CODE_SUNLIGHT.call(&quot;ruby&quot;)) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; SUNLIGHT_HTML,
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Chunk splitting</h4>
<p>
There are many ways to denote code "regions" (which become Codnar chunks). The
following covers GVim's default scheme; others are easily added. It is safest
to merge this configuration as the last of all the combined configurations, to
ensure its patterns end up before any others.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="chunk-splitting-configurations">
<span>Chunk splitting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Group lines into chunks using VIM-style “{{{”/“}}}” region
designations. Assumes other configurations handle the actual content lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
CHUNK_BY_VIM_REGIONS = {
  &quot;formatters&quot; =&gt; {
    &quot;begin_chunk&quot; =&gt; &quot;[]&quot;,
    &quot;end_chunk&quot; =&gt; &quot;[]&quot;,
    &quot;nested_chunk&quot; =&gt; &quot;Formatter.nested_chunk_lines_to_html(lines)&quot;,
  },
  &quot;syntax&quot; =&gt; {
    &quot;patterns&quot; =&gt; {
      &quot;begin_chunk&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)\\W*\\{\\{\\{\\s*(.*?)\\s*$&quot; },
      &quot;end_chunk&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)\\W*\\}\\}\\}\\s*(.*?)\\s*$&quot; },
    },
    &quot;states&quot; =&gt; {
      &quot;start&quot; =&gt; {
        &quot;transitions&quot; =&gt; [
          { &quot;pattern&quot; =&gt; &quot;begin_chunk&quot; },
          { &quot;pattern&quot; =&gt; &quot;end_chunk&quot; },
          [],
        ],
      },
    },
  },
}

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
Here is a simple test demonstrating splitting code chunks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-chunk-configurations-rb">
<span>test/split_chunk_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test built-in split code formatting configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitChunkConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    CODE_TEXT = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      int x;
      #! {{{ chunk
      int y;
      #! }}}
    EOF

    CODE_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='code'&gt;
      int x;
      &lt;/pre&gt;
      &lt;pre class='nested chunk'&gt;
      &lt;a class='nested chunk' href='#chunk'&gt;chunk&lt;/a&gt;
      &lt;/pre&gt;
    EOF

    CHUNK_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='code'&gt;
      int y;
      &lt;/pre&gt;
    EOF

    def test_gvim_chunks
      check_split_file(CODE_TEXT,
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;c&quot;),
                       Configuration::CHUNK_BY_VIM_REGIONS) do |path|
        [ {
          &quot;name&quot;=&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [ &quot;chunk&quot; ],
          &quot;html&quot;=&gt; CODE_HTML,
        }, {
          &quot;name&quot; =&gt; &quot;chunk&quot;,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 2 } ],
          &quot;containers&quot; =&gt; [ path ],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; CHUNK_HTML,
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Putting it all together</h3>
<p>
Here is a test demonstrating putting several of the above configurations
together in a meaningful way:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-combined-configurations-rb">
<span>test/split_combined_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_configurations&quot;
require &quot;test_with_tempfile&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test combination of many built-in configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestSplitCombinedConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithConfigurations
    include TestWithTempfile

    CODE_TEXT = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #!!/usr/bin/ruby -w

      #! {{{ HTML snippet

      HELLO_WORLD_IN_HTML = &lt;&lt;-EOH.unindent.chomp #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;p&gt;
        Hello, world!
        &lt;/p&gt;
      EOH
</pre>
<pre class='sunlight-highlight-ruby'>
      #! ))) html

      #! }}}

      #! {{{ Ruby code

      #! Hello, *world*!
      puts HELLO_WORLD_IN_HTML

      #! }}}
    EOF

    FILE_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='ruby code syntax'&gt;
      &lt;span class=&quot;PreProc&quot;&gt;#!/usr/bin/ruby -w&lt;/span&gt;

      &lt;/pre&gt;
      &lt;pre class='nested chunk'&gt;
      &lt;a class='nested chunk' href='#html-snippet'&gt;HTML snippet&lt;/a&gt;
      &lt;/pre&gt;
      &lt;pre class='ruby code syntax'&gt;

      &lt;/pre&gt;
      &lt;pre class='nested chunk'&gt;
      &lt;a class='nested chunk' href='#ruby-code'&gt;Ruby code&lt;/a&gt;
      &lt;/pre&gt;
    EOF

    HTML_CHUNK = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='ruby code syntax'&gt;

      &lt;span class=&quot;Type&quot;&gt;HELLO_WORLD_IN_HTML&lt;/span&gt; = &amp;lt;&amp;lt;-&lt;span class=&quot;Special&quot;&gt;EOH&lt;/span&gt;.unindent.chomp &lt;span class=&quot;Comment&quot;&gt;# ((( html&lt;/span&gt;
</pre>
<pre class='sunlight-highlight-html'>
      &lt;/pre&gt;
      &lt;pre class='html code syntax'&gt;
        &lt;span class=&quot;Identifier&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;Statement&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;&amp;gt;&lt;/span&gt;
        Hello, world!
        &lt;span class=&quot;Identifier&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;Statement&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;&amp;gt;&lt;/span&gt;
      EOH
      &lt;/pre&gt;
      &lt;pre class='ruby code syntax'&gt;
</pre>
<pre class='sunlight-highlight-ruby'>
      &lt;span class=&quot;Comment&quot;&gt;# ))) html&lt;/span&gt;

      &lt;/pre&gt;
    EOF

    RUBY_CHUNK = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='ruby code syntax'&gt;

      &lt;/pre&gt;
      &lt;table class='layout'&gt;
      &lt;tr&gt;
      &lt;td class='indentation'&gt;
      &lt;pre&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class='html'&gt;
      &lt;div class='rdoc comment markup'&gt;
      &lt;p&gt;
      Hello, &lt;b&gt;world&lt;/b&gt;!
      &lt;/p&gt;
      &lt;/div&gt;
      &lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;pre class='ruby code syntax'&gt;
      puts &lt;span class=&quot;Type&quot;&gt;HELLO_WORLD_IN_HTML&lt;/span&gt;

      &lt;/pre&gt;
    EOF

    def test_gvim_chunks
      check_split_file(CODE_TEXT,
                       Configuration::CLASSIFY_SOURCE_CODE.call(&quot;ruby&quot;),
                       Configuration::FORMAT_CODE_GVIM_CSS.call(&quot;ruby&quot;),
                       Configuration::CLASSIFY_NESTED_CODE.call(&quot;ruby&quot;, &quot;html&quot;),
                       Configuration::FORMAT_CODE_GVIM_CSS.call(&quot;html&quot;),
                       Configuration::CLASSIFY_SHELL_COMMENTS.call,
                       Configuration::FORMAT_RDOC_COMMENTS,
                       Configuration::CHUNK_BY_VIM_REGIONS) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;line&quot; =&gt; 1, &quot;file&quot; =&gt; path } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [ &quot;HTML snippet&quot;, &quot;Ruby code&quot; ],
          &quot;html&quot; =&gt; FILE_HTML,
        }, {
          &quot;name&quot; =&gt; &quot;HTML snippet&quot;,
          &quot;locations&quot; =&gt; [ { &quot;line&quot; =&gt; 3, &quot;file&quot; =&gt; path } ],
          &quot;containers&quot; =&gt; [ path ],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; HTML_CHUNK,
        }, {
          &quot;name&quot; =&gt; &quot;Ruby code&quot;,
          &quot;locations&quot; =&gt; [ { &quot;line&quot; =&gt; 14, &quot;file&quot; =&gt; path } ],
          &quot;containers&quot; =&gt; [ path ],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; RUBY_CHUNK,
        } ]
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h2>Storing chunks on the disk</h2>

<h3>Writing chunks to disk</h3>
<p>
In any realistic system, the number of source files and chunks will be such
that it makes sense to store the chunks on the disk for further processing.
This allows incorporating the split operation as part of a build tool chain,
and only re-splitting modified files. Here is a simple test demonstrating
writing chunks to the disk:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-write-chunks-rb">
<span>test/write_chunks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test writing chunks to files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestWriteChunks &lt; Test::Unit::TestCase

    include TestWithFakeFS

    def test_write_chunks
      check_writing_data([])
      check_writing_data(&quot;name&quot; =&gt; &quot;foo&quot;)
      check_writing_data([ { &quot;name&quot; =&gt; &quot;foo&quot; }, { &quot;name&quot; =&gt; &quot;bar&quot; } ])
    end

    def test_write_invalid_data
      lambda { check_writing_data(&quot;not a chunk&quot;) }.should.raise
    end

  protected

    def check_writing_data(data)
      Writer.write(&quot;path&quot;, data)
      data = [ data ] unless Array === data
      YAML.load_file(&quot;path&quot;).should == data
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-writer-rb">
<span>lib/codnar/writer.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write chunks into a disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Writer

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write one chunk or an array of chunks to a disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.write(path, data)
      self.new(path) do |writer|
        writer &lt;&lt; data
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Add one chunk or an array of chunks to the disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def &lt;&lt;(data)
      case data
      when Array
        @chunks += data
      when Hash
        @chunks &lt;&lt; data
      else
        raise &quot;Invalid data class: #{data.class}&quot;
      end
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write chunks into the specified disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(path, &amp;block)
      @chunks = []
      File.open(path, &quot;w&quot;) do |file|
        block.call(self)
        file.print(@chunks.to_yaml)
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Reading chunks to memory</h3>
<p>
Having written the chunks to the disk requires us, at some following point in
time, to read them back into memort. This is the first time we will have a view
of the whole documented system, which allows us to detect several classes of
consistency errors: Some chunks may be left out of the final narrative
(consider this the equivalent of tests code coverage); we may be referring to
missing (or misspelled) chunk names; and, finally, we need to deal with
duplicate chunks.
</p>
<p>
In literate programming, it is trivial to write a chunk once and use it in
several places in the compiled source code. The classical example is C/C++
function signatures that need to appear in both the <code>.h</code> and <code>.c</code>/<code>.cpp</code> files.
However, in some cases this practice makes sense for other pieces of code, and
since the ultimate source code contains only one copy of the chunk, this does
not suffer from the typical copy-and-paste issues.
</p>
<p>
In inverse literate programming, if the same code appears twice (as a result of
copy-and-paste), then it does suffer from the typical copy-and-paste issues.
The most serious of these is, of course, that when only one copy is changed.
The way that Codnar helps alleviate this problem is that if the same chunk
appears more than once in the source code, its content is expected to be
exactly the same in both cases (up to indentation). This should not be viewed
as endorsement of copy-and-paste programming; Using duplicate chunks should be
a last resort measure to combat restrictions in the programming language and
compilation tool chain.
</p>
<h4>Chunk identifiers</h4>
<p>
The above definition raises the obvious question: what does "the same chunk"
mean? As far as Codnar is concerned, a chunk is uniquely identified by its
name, which is specified on the <code>begin_chunk</code> line. The unique identifier is
not the literal name but a transformation of it. This allows us to ignore
capitalization, white space, and any punctuation that may appear in the name.
It also allows us to use the resulting ID as an HTML anchor name, without
worrying about HTML's restictions on such names.
</p>
<p>
Here is a simple test demonstrating converting names to identifiers:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-identify-chunks-rb">
<span>test/identify_chunks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test converting chunk names to identifiers.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestIdentifyChunks &lt; Test::Unit::TestCase

    def test_lower_case_to_id
      &quot;a&quot;.to_id.should == &quot;a&quot;
    end

    def test_upper_case_to_id
      &quot;A&quot;.to_id.should == &quot;a&quot;
    end

    def test_digits_to_id
      &quot;1&quot;.to_id.should == &quot;1&quot;
    end

    def test_non_alnum_to_id
      &quot;!@-$#&quot;.to_id.should == &quot;-&quot;
    end

    def test_complex_to_id
      &quot;C# for .NET!&quot;.to_id.should == &quot;c-for-net-&quot;
    end

    def test_strip_to_id
      &quot; a &quot;.to_id.should == &quot;a&quot;
    end


  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="convert-names-to-identifiers">
<span>Convert names to identifiers</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert this String to an identifier. This is a stable operation, so
anything that accept a name will also accept an identifier as well.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def to_id
  return self.strip.gsub(/[^a-zA-Z0-9]+/, &quot;-&quot;).downcase
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-string-rb">lib/codnar/core_ext/string.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>In-memory chunks storage</h4>
<p>
Detecting unused and/or duplicate chunks requires us to have in-memory chunk
storage that tracks all chunks access. Here is a simple test demonstrating
reading chunks into the storage and handling the various error conditions
listed above:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-read-chunks-rb">
<span>test/read_chunks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test reading chunks from files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestReadChunks &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithFakeFS

    def test_read_chunks
      Writer.write(&quot;foo.chunks&quot;, { &quot;name&quot; =&gt; &quot;foo&quot; })
      Writer.write(&quot;bar.chunks&quot;, [ { &quot;name&quot; =&gt; &quot;bar&quot; }, { &quot;name&quot; =&gt; &quot;baz&quot; } ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo&quot; =&gt; { &quot;name&quot; =&gt; &quot;foo&quot; },
                              &quot;bar&quot; =&gt; { &quot;name&quot; =&gt; &quot;bar&quot; },
                              &quot;baz&quot; =&gt; { &quot;name&quot; =&gt; &quot;baz&quot; })
      @errors.should == []
    end

    def test_read_invalid_chunks
      file_path = nil
      File.open(&quot;foo.chunks&quot;, &quot;w&quot;) { |file| file_path = File.expand_path(file.path) }
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      @errors.should == [ &quot;#{$0}: Invalid chunks data in file: #{file_path}&quot; ]
    end

    def test_read_unused_chunks
      Writer.write(&quot;foo.chunks&quot;, { &quot;name&quot; =&gt; &quot;foo&quot;,
                                   &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot;, &quot;line&quot; =&gt; 1 } ] })
      Writer.write(&quot;bar.chunks&quot;, { &quot;name&quot; =&gt; &quot;bar&quot;,
                                   &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;b&quot;, &quot;line&quot; =&gt; 2 } ] })
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo&quot; =&gt; { &quot;name&quot; =&gt; &quot;foo&quot;,
                                         &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot;, &quot;line&quot; =&gt; 1 } ] })
      @errors.should == [ &quot;#{$0}: Unused chunk: bar in file: b at line: 2&quot; ]
    end

    def test_read_duplicate_chunks
      Writer.write(&quot;foo.chunks&quot;, { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot; } ],
                                   &quot;contained&quot; =&gt; [ &quot;A&quot; ], &quot;containers&quot; =&gt; [ &quot;c&quot; ] })
      Writer.write(&quot;bar.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;b&quot; } ],
          &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [ &quot;d&quot; ] },
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;c&quot; } ],
          &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [] }
      ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo&quot; =&gt; {
        &quot;name&quot; =&gt; &quot;foo&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot; }, { &quot;file&quot; =&gt; &quot;b&quot; }, { &quot;file&quot; =&gt; &quot;c&quot; } ],
        &quot;contained&quot; =&gt; [ &quot;a&quot; ],
        &quot;containers&quot; =&gt; [ &quot;c&quot;, &quot;d&quot; ],
      })
    end

    def test_read_different_chunks
      Writer.write(&quot;foo.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;html&quot; =&gt; &quot;bar&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 } ],
          &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [] },
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;html&quot; =&gt; &quot;baz&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 2 } ],
          &quot;contained&quot; =&gt; [ &quot;A&quot; ], &quot;containers&quot; =&gt; [] }
      ])
      Writer.write(&quot;bar.chunks&quot;, [ { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;html&quot; =&gt; &quot;bar&quot;,
                                     &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;bar.chunks&quot;, &quot;line&quot; =&gt; 1 } ],
                                     &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [] } ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;).sort)
      @errors.should == [ &quot;#{$0}: Chunk: foo is different in file: foo.chunks at line: 2, &quot; \
                        + &quot;and in file: bar.chunks at line: 1 or in file: foo.chunks at line: 1&quot; ]
      check_read_data(reader, &quot;foo&quot; =&gt; {
        &quot;name&quot; =&gt; &quot;foo&quot;,
        &quot;html&quot; =&gt; &quot;bar&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;bar.chunks&quot;, &quot;line&quot; =&gt; 1 }, { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;contained&quot; =&gt; [ &quot;a&quot; ],
        &quot;containers&quot; =&gt; [],
      })
    end

    def test_read_fake_chunk
      reader = Reader.new(@errors, [])
      reader[&quot;foo&quot;].should == Reader.fake_chunk(&quot;foo&quot;)
      @errors.should == [ &quot;#{$0}: Missing chunk: foo&quot; ]
    end

    def test_read_equivalent_name_chunks
      Writer.write(&quot;foo.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;Foo?&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [ &quot;1&quot; ], &quot;contained&quot; =&gt; [ &quot;c&quot; ] },
        { &quot;name&quot; =&gt; &quot;FOO!!&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 2 } ],
          &quot;containers&quot; =&gt; [ &quot;2&quot; ], &quot;contained&quot; =&gt; [ &quot;C&quot; ] }
      ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo-&quot; =&gt; {
        &quot;name&quot; =&gt; &quot;Foo?&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 }, { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 2 } ],
        &quot;containers&quot; =&gt; [ &quot;1&quot;, &quot;2&quot; ],
        &quot;contained&quot; =&gt; [ &quot;c&quot; ],
      })
    end

  protected

    def check_read_data(reader, chunks)
      chunks.each do |name, chunk|
        reader[name].should == chunk
      end
      reader.collect_unused_chunk_errors
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-reader-rb">
<span>lib/codnar/reader.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Read chunks from disk files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Reader

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all chunks from the specified disk files to memory for later access by
name.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(errors, paths)
      @errors = errors
      @chunks = {}
      @used = {}
      paths.each do |path|
        read_path_chunks(path)
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Fetch a chunk by its name.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def [](name)
      id = name.to_id
      @used[id] = true
      return @chunks[id] ||= (
        @errors &lt;&lt; &quot;Missing chunk: #{name}&quot;
        Reader.fake_chunk(name)
      )
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Collect errors for unused chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def collect_unused_chunk_errors
      @chunks.each do |id, chunk|
        @errors.push(&quot;#{$0}: Unused chunk: #{chunk.name} #{Reader.locations_message(chunk)}&quot;) unless @used[id]
      end
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load and merge all chunks from a disk file into memory.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def read_path_chunks(path)
      @errors.in_path(path) do
        chunks = load_path_chunks(path)
        next unless chunks
        merge_loaded_chunks(chunks)
        @root_chunk ||= chunks[0].name
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all chunks from a disk file into memory.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def load_path_chunks(path)
      chunks = YAML.load_file(path)
      @errors &lt;&lt; &quot;Invalid chunks data&quot; unless chunks
</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
TODO: A bit more validation would be nice.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      return chunks
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge an array of chunks into memory.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def merge_loaded_chunks(chunks)
      chunks.each do |new_chunk|
        old_chunk = @chunks[id = new_chunk.name.to_id]
        if old_chunk.nil?
          @chunks[id] = new_chunk
        elsif Reader.same_chunk?(old_chunk, new_chunk)
          Reader.merge_same_chunks(old_chunk, new_chunk)
        else
          @errors.push(Reader.different_chunks_error(old_chunk, new_chunk))
        end
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a new “same” chunk into an old one.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.merge_same_chunks(old_chunk, new_chunk)
      old_chunk.locations = \
        (old_chunk.locations + new_chunk.locations).uniq.sort \
          do |first_location, second_location|
            [ first_location.file.to_id, first_location.line ] \
            &lt;=&gt; [ second_location.file.to_id, second_location.line ]
          end
      old_chunk.containers = \
        (old_chunk.containers + new_chunk.containers).uniq.sort \
          do |first_name, second_name|
            first_name.to_id &lt;=&gt; second_name.to_id
          end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Check whether two chunks contain the same “stuff”.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.same_chunk?(old_chunk, new_chunk)
      return Reader.chunk_payload(old_chunk) == Reader.chunk_payload(new_chunk)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return just the actual payload of a chunk for equality comparison.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.chunk_payload(chunk)
      chunk = chunk.reject { |key, value| [ &quot;locations&quot;, &quot;name&quot;, &quot;containers&quot; ].include?(key) }
      chunk.contained.map! { |name| name.to_id }
      return chunk
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Error message when two different chunks have the same name.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.different_chunks_error(old_chunk, new_chunk)
      old_location = Reader.locations_message(old_chunk)
      new_location = Reader.locations_message(new_chunk)
      return &quot;#{$0}: Chunk: #{old_chunk.name} is different #{new_location}, and #{old_location}&quot;
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format a chunk’s location for an error message.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.locations_message(chunk)
      locations = chunk.locations.map { |location| &quot;in file: #{location.file} at line: #{location.line}&quot; }
      return locations.join(&quot; or &quot;)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return a fake chunk for the specified name.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.fake_chunk(name)
      return {
        &quot;name&quot; =&gt; name,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;MISSING&quot; } ],
        &quot;contained&quot; =&gt; [],
        &quot;containers&quot; =&gt; [],
        &quot;html&quot; =&gt; &quot;&lt;div class='missing chunk error'&gt;\nMISSING\n&lt;/div&gt;&quot;
      }
    end

  end

end
</pre>
</div>
</div>
</p>
<h2>Weaving chunks into HTML</h2>
<p>
Assembling the final HTML requires combining both the narrative documentation
and source code chunks. This is done top-down starting at a "root"
documentation chunk and recursively embedding nested documentation and code
chunks into it.
</p>
<h3>Weaving chunks together</h3>
<p>
When embedding a documentation chunk inside another documentation chunk, things
are pretty easy - we just need to insert the embedded chunk HTML into the
containing chunk. When embedding a source code chunk into the documentation,
however, we may want to wrap it in some boilerplate HTML, providing a header,
footer, borders, links, etc. Therefore, the HTML syntax we use to embed a chunk
into the documentation is <code>&lt;embed src="..." type="x-codnar/template-name"/&gt;</code>.
The templates are normal ERB templates, except for the magical <code>file</code> and
<code>image</code> templates, described below.
</p>
<p>
At any rate, here is a simple test demonstrating applying different templates
to the embedded code chunks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-weave-configurations-rb">
<span>test/weave_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_errors&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test the built-in weave configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestWeaveConfigurations &lt; Test::Unit::TestCase

    include TestWithErrors
    include TestWithFakeFS

    def test_weave_file
      Writer.write(&quot;chunks&quot;, {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [], &quot;contained&quot; =&gt; [],
        &quot;name&quot; =&gt; &quot;Top&quot;, &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent,
          &lt;h1&gt;Top&lt;/h1&gt;
          &lt;embed src=&quot;path&quot; type=&quot;x-codnar/file&quot;/&gt;
        EOF
      })
      File.open(&quot;path&quot;, &quot;w&quot;) { |file| file.puts(&quot;&lt;h2&gt;File&lt;/h2&gt;&quot;) }
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_INCLUDE).weave(&quot;include&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == &lt;&lt;-EOF.unindent
        &lt;h1&gt;Top&lt;/h1&gt;
        &lt;h2&gt;File&lt;/h2&gt;
      EOF
    end

    def test_weave_include
      Writer.write(&quot;chunks&quot;, chunks(&quot;include&quot;))
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_INCLUDE).weave(&quot;include&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == &lt;&lt;-EOF.unindent #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
        &lt;h1&gt;Top&lt;/h1&gt;
        &lt;h2&gt;Intermediate&lt;/h2&gt;
        &lt;h3&gt;Bottom&lt;/h3&gt;
      EOF
</pre>
<pre class='sunlight-highlight-ruby'>
      #! ))) html
    end

    WOVEN_PLAIN_CHUNK = &lt;&lt;-EOF.unindent #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
      &lt;div class=&quot;plain chunk&quot;&gt;
      &lt;a name=&quot;top&quot;/&gt;
      &lt;h1&gt;Top&lt;/h1&gt;
      &lt;div class=&quot;plain chunk&quot;&gt;
      &lt;a name=&quot;intermediate&quot;/&gt;
      &lt;h2&gt;Intermediate&lt;/h2&gt;
      &lt;div class=&quot;plain chunk&quot;&gt;
      &lt;a name=&quot;bottom&quot;/&gt;
      &lt;h3&gt;Bottom&lt;/h3&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    EOF
</pre>
<pre class='sunlight-highlight-ruby'>
    #! ))) html

    def test_weave_plain_chunk
      Writer.write(&quot;chunks&quot;, chunks(&quot;plain_chunk&quot;))
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_PLAIN_CHUNK).weave(&quot;plain_chunk&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == WOVEN_PLAIN_CHUNK
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Normally, one does not nest named_chunk_with_containers chunks this way,
but it serves as a test.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    WOVEN_NAMED_CHUNK = &lt;&lt;-EOF.unindent #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
      &lt;div class=&quot;named_with_containers chunk&quot;&gt;
      &lt;div class=&quot;chunk name&quot;&gt;
      &lt;a name=&quot;top&quot;&gt;
      &lt;span&gt;Top&lt;/span&gt;
      &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk html&quot;&gt;
      &lt;h1&gt;Top&lt;/h1&gt;
      &lt;div class=&quot;named_with_containers chunk&quot;&gt;
      &lt;div class=&quot;chunk name&quot;&gt;
      &lt;a name=&quot;intermediate&quot;&gt;
      &lt;span&gt;Intermediate&lt;/span&gt;
      &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk html&quot;&gt;
      &lt;h2&gt;Intermediate&lt;/h2&gt;
      &lt;div class=&quot;named_with_containers chunk&quot;&gt;
      &lt;div class=&quot;chunk name&quot;&gt;
      &lt;a name=&quot;bottom&quot;&gt;
      &lt;span&gt;BOTTOM&lt;/span&gt;
      &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk html&quot;&gt;
      &lt;h3&gt;Bottom&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk containers&quot;&gt;
      &lt;span class=&quot;chunk containers header&quot;&gt;Contained in:&lt;/span&gt;
      &lt;ul class=&quot;chunk containers&quot;&gt;
      &lt;li class=&quot;chunk container&quot;&gt;
      &lt;a class=&quot;chunk container&quot; href=&quot;#intermediate&quot;&gt;Intermediate&lt;/a&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk containers&quot;&gt;
      &lt;span class=&quot;chunk containers header&quot;&gt;Contained in:&lt;/span&gt;
      &lt;ul class=&quot;chunk containers&quot;&gt;
      &lt;li class=&quot;chunk container&quot;&gt;
      &lt;a class=&quot;chunk container&quot; href=&quot;#top&quot;&gt;Top&lt;/a&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    EOF
</pre>
<pre class='sunlight-highlight-ruby'>
    #! ))) html

    def test_weave_named_chunk_with_containers
      Writer.write(&quot;chunks&quot;, chunks(&quot;named_chunk_with_containers&quot;))
      weaver = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_NAMED_CHUNK_WITH_CONTAINERS)
      html = weaver.weave(&quot;named_chunk_with_containers&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == WOVEN_NAMED_CHUNK
    end

  protected

    def chunks(template)
      return [ {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [ &quot;Intermediate&quot; ], &quot;contained&quot; =&gt; [],
        &quot;name&quot; =&gt; &quot;BOTTOM&quot;,
        &quot;html&quot; =&gt; &quot;&lt;h3&gt;Bottom&lt;/h3&gt;\n&quot;,
      }, {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [ &quot;Top&quot; ], &quot;contained&quot; =&gt; [ &quot;BOTTOM&quot; ],
        &quot;name&quot; =&gt; &quot;Intermediate&quot;, &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent, #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
          &lt;h2&gt;Intermediate&lt;/h2&gt;
          &lt;embed type='x-codnar/#{template}' src='bottom'&gt;
          &lt;/embed&gt;
        EOF
</pre>
<pre class='sunlight-highlight-ruby'>
        #! ))) html
      }, {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [], &quot;contained&quot; =&gt; [ &quot;Intermediate&quot; ],
        &quot;name&quot; =&gt; &quot;Top&quot;, &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent, #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
          &lt;h1&gt;Top&lt;/h1&gt;
          &lt;embed src=&quot;##INTERMEDIATE&quot; type=&quot;x-codnar/#{template}&quot;/&gt;
        EOF
</pre>
<pre class='sunlight-highlight-ruby'>
        #! ))) html
      } ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-weaver-rb">
<span>lib/codnar/weaver.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave all chunks to a unified HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Weaver &lt; Reader

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all chunks from the specified disk files to memory for weaving using
the specified templates.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(errors, paths, templates)
      super(errors, paths)
      @templates = templates
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
How to process each magical file template.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    FILE_TEMPLATE_PROCESSORS = {
      &quot;file&quot; =&gt; lambda { |name, data| data },
      &quot;image&quot; =&gt; lambda { |name, data| Weaver.embedded_base64_img_tag(name, data) },
    }

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave the HTML for a named chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def weave(template, chunk_name = @root_chunk)
      return process_file_template(template, chunk_name) if FILE_TEMPLATE_PROCESSORS.include?(template)
      @last_chunk = chunk = self[chunk_name.to_id]
      expand_chunk_html(chunk)
      return process_template(chunk, template)
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Due to <a
href="http://github.com/relevance/rcov/issues/#issue/43">github.com/relevance/rcov/issues/#issue/43</a>
the following regular expressions must be on a single line.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Detect embedded chunks (<tt>type</tt> before <tt>src</tt>).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    TYPE_SRC_CHUNK = / [ ]* &lt;embed \s+ type = ['\&quot;] x-codnar\/ (.*?) ['\&quot;] \s+ src = ['\&quot;] \#* (.*?) ['\&quot;] \s* (?: \/&gt; | &gt; \s* &lt;\/embed&gt; ) [ ]* /x

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Detect embedded chunks (<tt>src</tt> before <tt>type</tt>).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    SRC_TYPE_CHUNK = / [ ]* &lt;embed \s+ src = ['\&quot;] \#* (.*?) ['\&quot;] \s+ type = ['\&quot;] x-codnar\/ (.*?) ['\&quot;] \s* (?: \/&gt; | &gt; \s* &lt;\/embed&gt; ) [ ]* /x

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Recursively expand all embedded chunks inside a container chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def expand_chunk_html(chunk)
      html = chunk.html
      @errors.push(&quot;No HTML in chunk: #{chunk.name} #{Weaver.locations_message(chunk)}&quot;) unless html
      #! TRICKY: All &quot;container&quot; chunks are assumed to be whole-file chunks with
      #! a single location. Which makes sense as these are documentation and not
      #! code chunks. TODO: It would be nice to know the exact line number of
      #! the chunk embedding directive for better pinpointing of any error.
      @errors.in_path(chunk.locations[0].file) do
        chunk.expanded_html ||= expand_embedded_chunks(html || &quot;&quot;).chomp
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Recursively expand_embedded_chunks all embedded chunk inside an HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def expand_embedded_chunks(html)
      return html.gsub(TYPE_SRC_CHUNK) { |match| weave($1, $2).chomp } \
                 .gsub(SRC_TYPE_CHUNK) { |match| weave($2, $1).chomp }
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process the chunk using an ERB template prior to inclusion in container
chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def process_template(chunk, template_name)
      template_text = @templates[template_name] ||= (
        @errors &lt;&lt; &quot;Missing ERB template: #{template_name}&quot;
        &quot;&lt;%= chunk.expanded_html %&gt;\n&quot;
      )
      return (
        (
          chunk.erb ||= {}
        )[template_name] ||= ERB.new(template_text, nil, &quot;%&quot;)
      ).result(binding)
    end

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#processing-the-file-template'>Processing the file template</a>
</pre>
<pre class='sunlight-highlight-ruby'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#processing-base64-embedded-data-images'>Processing Base64 embedded data images</a>
</pre>
<pre class='sunlight-highlight-ruby'>

  end

end
</pre>
</div>
</div>
</p>
<p>
And here are the pre-defined weaving template configurations:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="weaving-templates">
<span>Weaving templates</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave configuration providing a single simple <tt>include</tt> template.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
WEAVE_INCLUDE = { &quot;include&quot; =&gt; &quot;&lt;%= chunk.expanded_html %&gt;\n&quot; }

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave chunks in the plainest possible way.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
WEAVE_PLAIN_CHUNK = {
  &quot;plain_chunk&quot; =&gt; &lt;&lt;-EOF.unindent, #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
    &lt;div class=&quot;plain chunk&quot;&gt;
    &lt;a name=&quot;&lt;%= chunk.name.to_id %&gt;&quot;/&gt;
    &lt;%= chunk.expanded_html %&gt;
    &lt;/div&gt;
  EOF
</pre>
<pre class='sunlight-highlight-ruby'>
} #! ))) html

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave chunks with their name and the list of container chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
WEAVE_NAMED_CHUNK_WITH_CONTAINERS = {
  &quot;named_chunk_with_containers&quot; =&gt; &lt;&lt;-EOF.unindent, #! ((( html
</pre>
<pre class='sunlight-highlight-html'>
    &lt;div class=&quot;named_with_containers chunk&quot;&gt;
    &lt;div class=&quot;chunk name&quot;&gt;
    &lt;a name=&quot;&lt;%= chunk.name.to_id %&gt;&quot;&gt;
    &lt;span&gt;&lt;%= CGI.escapeHTML(chunk.name) %&gt;&lt;/span&gt;
    &lt;/a&gt;
    &lt;/div&gt;
    &lt;div class=&quot;chunk html&quot;&gt;
    &lt;%= chunk.expanded_html %&gt;
    &lt;/div&gt;
    % if chunk.containers != []
    &lt;div class=&quot;chunk containers&quot;&gt;
    &lt;span class=&quot;chunk containers header&quot;&gt;Contained in:&lt;/span&gt;
    &lt;ul class=&quot;chunk containers&quot;&gt;
    % chunk.containers.each do |container|
    &lt;li class=&quot;chunk container&quot;&gt;
    &lt;a class=&quot;chunk container&quot; href=&quot;#&lt;%= container.to_id %&gt;&quot;&gt;&lt;%= CGI.escapeHTML(container) %&gt;&lt;/a&gt;
    &lt;/li&gt;
    % end
    &lt;/ul&gt;
    &lt;/div&gt;
    % end
    &lt;/div&gt;
  EOF
</pre>
<pre class='sunlight-highlight-ruby'>
} #! ))) html

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Embedding files</h4>
<p>
The template named <code>file</code> is special in two ways. First, the <code>src</code> is given
special treatment. If it begins with a "<code>.</code>", it is assumed to be a normal path
name relative to the current working directory; otherwise, it is assumed to be
a name of a file packaged inside some gem and is searched for in Ruby's
<code>$LOAD_PATH</code>. This allows gems (such as Codnar itself) to provide such files to
be used in the woven documentation.
</p>
<p>
Second, the content of the file is simply embedded into the generated
documentation. This allows the documentation to be a stand-alone file,
including all the CSS and Javascript required for proper display.
</p>
<p>
At any rate, here is a simple test demonstrating how data file paths are
resolved:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-access-data-files-rb">
<span>test/access_data_files.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test accessing data files packages with the gem.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestAccessDataFiles &lt; Test::Unit::TestCase

    def test_access_data_file
      File.exist?(DataFiles.expand_path(&quot;codnar/reader.rb&quot;)).should == true
    end

    def test_access_missing_file
      DataFiles.expand_path(&quot;no-such-file&quot;).should == &quot;no-such-file&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-data-files-rb">
<span>lib/codnar/data_files.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Provide access to data files packaged with the gem.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module DataFiles

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Given the name of a data file packaged in some gem, return the absolute
disk path for accessing that data file. This is similar to what
<tt>require</tt> does internally, but here we just want the path for
reading data, rather than load the Ruby code in the file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.expand_path(relative_path)
      $LOAD_PATH.each do |load_directory|
        absolute_path = File.expand_path(load_directory + &quot;/&quot; + relative_path)
        return absolute_path if File.exist?(absolute_path)
      end
      return relative_path # This will cause &quot;file not found error&quot; down the line.
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the function for handling the magical <code>file</code> template:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="processing-the-file-template">
<span>Processing the file template</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process one of the magical file templates. The content of the file,
optionally processed, is directly embedded into the generated
documentation. If the file’s path begins with “.”, it is taken to be
relative to the current working directory. Otherwise, it is searched for in
Ruby’s load path, allowing easy access to files packaged inside gems.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def process_file_template(template, path)
  begin
    path = DataFiles.expand_path(path) unless path[0,1] == &quot;.&quot;
    return FILE_TEMPLATE_PROCESSORS[template].call(path, File.read(path))
  rescue Exception =&gt; exception
    @errors.push(&quot;#{$0}: Reading file: #{path} exception: #{exception} #{Reader.locations_message(@last_chunk)}&quot;) \
      if @last_chunk
    return &quot;FILE: #{path} EXCEPTION: #{exception}&quot;
  end
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-weaver-rb">lib/codnar/weaver.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
See the <code>doc/root.html</code> file for plenty of examples of using this
functionality.
</p>
<h4>Embedding images</h4>
<p>
The <code>image</code> template is a specialization of the <code>file</code> template for dealing
with embedded images. The specified image file is embedded into the generated
HTML as an <code>img</code> tag, using a <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">data
URL</a>. This is very useful for
small images, but is problematic when their size increase beyond
browser-specific limits.
</p>
<p>
Here is a simple test demonstrating processing embedded image files:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-embed-images-rb">
<span>test/embed_images.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test computing embedded image HTML tags.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestEmbedImages &lt; Test::Unit::TestCase

    def test_embed_image
      Weaver.embedded_base64_img_tag('fake file.png', 'fake file content').should \
        == &quot;&lt;img src='data:image/png;base64,ZmFrZSBmaWxlIGNvbnRlbnQ=\n'/&gt;&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="processing-base64-embedded-data-images">
<span>Processing Base64 embedded data images</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create an <tt>img</tt> tag with an embedded data URL. Different browsers
have different constraints about the size of the resulting URL, so YMMV.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
def self.embedded_base64_img_tag(name, data)
  extension = File.extname(name).sub(&quot;.&quot;, &quot;/&quot;)
  return &quot;&lt;img src='data:image#{extension};base64,&quot; \
       + Base64.encode64(data) \
       + &quot;'/&gt;&quot;
end

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-weaver-rb">lib/codnar/weaver.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
And here is a sample embedded image:
</p>
<p>
<img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAABGdBTUEAALGP
C/xhBQAAAwBQTFRFAAAAAAQACAgACAwACAgICAwIEBAAEBQAGBgAGBwAEBAQ
EBQQGBgYGBwYISAAISQAKSgAKSwAMTAAMTQAOTgAOTwAISAhISQhKSgpKSwp
MTAxMTQxOTg5OTw5QkEAQkUASkkASk0AUlEAUlUAWlkAWl0AY2EAY2UAa2kA
a20Ac3EAc3UAe3kAe30AQkFCQkVCSklKSk1KUlFSUlVSWllaWl1aY2Vja2lr
a21rc3Fzc3Vze3l7e317hIIAhIYAjIoAjI4AlJIAlJYAnJoAnJ4ApaIApaYA
raoAra4AtbIAtbYAvboAvb4AxsMAxscAzssAzs8A1tMA1tcA3tsA3t8A5+MA
5+cA7+sA7+8A9/MA9/cA//sA//8AhIKEhIaEjIqMjI6MlJKUlJaUnJqcpaKl
paalraqtra6ttbK1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAA6Ke7cwAAAQB0Uk5T////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////AFP3ByUAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2
My41LjVJivzgAAAFm0lEQVRoQ+1ZaVsURxCe2dEFPGDRKCqKqHhExXgnKgQP
EFHkPndb3cSI+f9/YDLTVTPTVV093WMev1GfeNi36u3qrq1ro/QnS/ST7aeH
BN4bPryi/3FF/RczDcRJ5HyDgzhqIvddDE6Cc03MR1F84GBwEXxqZj+KzjUk
ON6UIPoiMzg8eNLYfnS8EcERTTAY9tAIeyoyyB7c0/aTxU6II/H8Lxp2JJzg
K9id6i20Ahgmu+8Bdk9iED04Cxe0obqX/QTJqupNAeybwCARvAD4rFJqJfEy
/JrBNgY0bCyQ4JhGj+xlmuqWj2BoO4fdBdgnm0Hw4JHGxm9zRbU1WM8Qv9Sw
3RENOxZEALE50dWaaq4+VE/vA+wNwB5bDLYH4xqZfARFtX+qzoXWEsK6E+C3
n+BvsHcLFZV6Vxeq13oF7iOEw0XOYHlwUuMGN0uC3hW3C+31EqauA+wrY+AE
z8DTuUpRrblD9bYB24RwOOshOKpRozpEC7ntcmFkx4TNwjs/owzMgwca01o0
FdX2kMwQvyawvVENO1pH8B0OcaV8OrDwWg7VMxjJBc0iwB4SBurBeY1or5GT
KdWFdMmktcxgvUmNoKFKCPpgIs8uVJakUJ1ifiq1CuEwbrpACE7ozyG7ECnS
penDwIYFUzcB0DcYTIKn4OErW1Gtt/kFxXcF2Nawhp1wEECdLLIL1Z/mBJ1d
gUC9BNgfFYPhAdTJ1ntJsUiXJU28IMIwcxnVsyL4BkFWZRdqYZ6G6mXrhQG+
BLCq0asIxvQnZnYhDJgu0YVkRXRAKcxcVaNXEszAC0tPB7Y+mCnphsO+UmtQ
PctGryTAOik+HVjDGMzVh7acBOoOOPkZ37kggFYunncrqk04Wy5msuUaOxCq
RaNXEECI8uxClTFd8mTLGTBzYaOHBBe1/WS5xgGlMF1G8bta2D5p9IAAW7nr
jtgr7C1ADE56YB/MRg8IoE5K2YWG6mQOa6/WOpCFKjZ6/+SmNcFzeOE/PYqY
Ls06KWuYjZ4mgBDtkDopq2ahOmwnWwuLmStv9HKCh+AAtHL1klVPKdlyJaPR
ywmwldvZC5DpU9sBqL1XYPOR9uCz/juKkxBpd0JQCaaV83BFkObC5OpiyEyC
tvKUlxNgog5hGFjvXQ3BASZP2jqKoNSEyJ0sXfpnErSkyw580SAT+WU4b+Wc
jR7X/70igHLvFUi2OzBseAVKPya7sMH+DEwbjkaPM0LzggR973kyQJFs5UaP
W7ig7ZdbR2ga62Wq+MJiuqxFFw1kUXC++6ybyVZq9Lj+A3Cg2ptC414n+dyM
gumyBl028VXb4gtVkmytRo9zlWNIRQDDk1NaJNnudurRJ/GCjCsqyppLcYLW
SayeLnQ1Chq9KQ6wsg5v5Wijx3WMYdZs32EEl8Vq5ZZrUpI545ABxL01sFu5
3g33abI6I71BmsIaRBBceZDK6F6TkJUI8SCFKdmWUVx5EIZZ13FmDAfYDxS4
iuKaLbGVKxo9jqZrKepBCss0LnxuRkdwLuZoulhjBNhDUh1XK4dzMSO4ZF4Q
+aLpDy4JDjhbuVVr9rSXm8wDqXrqOimLsNHj61mL4DF3ga08CJO9JrEWzBYB
NqoVjTw3I4+10ftCX8B+gzSFabCURJ6bkWD/NEXbS37bg5T+NGGvPMgl0TWJ
8DOFQHBgHmrA2MpJD003enkrx0QgSH8zGKZ9Df16NXvyZRetySZxVT1rQrRg
Nho9YwciZ9Piv2WjF7/xOWA2euYWp54ghc1UtV+upcGtchT9Zb+AFKY5qg/2
47mVAFmG0T7CVi7gkTMINnpxmMBppPO7PEj/FXKe5190m+l5gzS935SB7WO9
BM7q6SJ+Lt+Q+zd9T6PHefhO3O9BOj7WRPReIjxMXegf+L+Ui37AjFvlkMB7
nYdX5L2i/wAENTnBDcjR4QAAAABJRU5ErkJggg==
'/>
</p>
<h2>Invoking the functionality</h2>
<p>
There are two ways to invoke Codnar's functionality - from the command line,
and (for Ruby projects) as integrated Rake tasks.
</p>
<h3>Command Line Applications</h3>
<p>
The base command line Application class handles execution from the command
line, with the usual standard options, as well as some Codnar-specific ones:
the ability to specify configuration files and/or built-in configurations, and
the ability to include additional extension code. Together, these allow
configuring and extending Codnar's behavior to cover the specific system's
needs.
</p>
<p>
In addition, the Application class also supports invocation from unit tests.
Here is a simple test demonstrating this mode of invocation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-run-application-rb">
<span>test/run_application.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running a Codnar Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestRunApplication &lt; Test::Unit::TestCase

    include TestWithFakeFS

    def test_do_nothing
      Application.with_argv(%w(dummy)) { Application.new(true).run }.should == 0
    end

    def test_print_version
      Application.with_argv(%w(-v -h -o nested/stdout dummy)) { Application.new(true).run }.should == 0
      File.read(&quot;nested/stdout&quot;).should == &quot;#{$0}: Version: #{Codnar::VERSION}\n&quot;
    end

    def test_print_help
      Application.with_argv(%w(-h -o stdout dummy)) { Application.new(true).run }.should == 0
      File.read(&quot;stdout&quot;).should.include?(&quot;OPTIONS&quot;)
    end

    def test_require_configuration_module
</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The additional_module is read by Ruby and is not captured by FakeFS.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      File.open(&quot;additional_configuration.yaml&quot;, &quot;w&quot;) { |file| file.puts(&quot;bar: updated_bar&quot;) }
      status = Application.with_argv(%w(-o stdout -I support -r additional_module
                                        -c ADDITIONAL additional_configuration.yaml -- dummy)) do
        run_print_configuration
      end
      YAML.load_file(&quot;stdout&quot;).should == { &quot;foo&quot; =&gt; &quot;original_foo&quot;, &quot;bar&quot; =&gt; &quot;updated_bar&quot; }
    end

    def test_require_missing_configuration
      status = Application.with_argv(%w(-e stderr -I support -r additional_module
                                        -c additional no-such-configuration -- dummy)) do
        run_print_configuration
      end
      File.read(&quot;stderr&quot;).should \
        == &quot;#{$0}: Configuration: no-such-configuration is neither a disk file nor a known configuration\n&quot;
    end

  protected

    def run_print_configuration
      Application.new(true).run do |configuration|
        puts configuration.to_yaml
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-application-rb">
<span>lib/codnar/application.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Base class for Codnar applications.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Application

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a Codnar application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(is_test = nil)
      @errors = Errors.new
      @is_test = !!is_test
      @configuration ||= {}
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the Codnar application, returning its status.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def run(&amp;block)
      parse_options
      block.call(@configuration) if block
      return print_errors
    rescue ExitException =&gt; exception
      return exception.status
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Execute a block with an overriden ARGV, typically for running an
application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.with_argv(argv)
      return Globals.without_changes do
        ARGV.replace(argv)
        yield
      end
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Parse the command line options of the program.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def parse_options
      @options = GetOptions.new(%w(help version output=string error=string include|I=@string require=@string configuration=@string))
      redirect_files
      print_options
      load_modules
      merge_configurations
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Redirect standard output and error according to the parsed command line
options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def redirect_files
      $stdout = Application::redirect_file($stdout, @options.output)
      $stderr = Application::redirect_file($stderr, @options.error)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Redirect a standard file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.redirect_file(default, file)
      return default if file.nil? || file == &quot;-&quot;
      FileUtils.mkdir_p(File.dirname(File.expand_path(file)))
      return File.open(file, &quot;w&quot;)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print data about the program and exit according to the parsed command line
options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_options
      print_version if @options.version
      print_help if @options.help
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the current Codnar version.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_version
      puts(&quot;#{$0}: Version: #{Codnar::VERSION}&quot;)
      exit(0)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print a short help message listing the available command line options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help(&amp;block)
      print_help_before_options
      print_standard_options
      print_help_after_options
      exit(0)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message before the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help_before_options
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the standard Codnar options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_standard_options
      print(&lt;&lt;-EOF.unindent)
        OPTIONS:

          -h, --help                           Print this help message and exit.
          -v, --version                        Print the version number (#{Codnar::VERSION}) and exit.
          -o, --output &lt;path&gt;|-                Redirect standard output to the &lt;path&gt;.
          -e, --error &lt;path&gt;|-                 Redirect standard error to the &lt;path&gt;.
          -I, --include &lt;path&gt;...              Add &lt;path&gt;(s) to Ruby's libs search path.
          -r, --require &lt;path&gt;...              Ruby require the code in the &lt;path&gt;(s).
          -c, --configuration &lt;NAME&gt;|&lt;path&gt;... Load named or disk file configuration(s).
      EOF
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message after the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help_after_options
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all requested modules.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def load_modules
      (@options.include || []).reverse.each do |path|
        $:.unshift(path)
      end
      (@options.require || []).each do |path|
        require path
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge all the specified configuration data into one mapping.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def merge_configurations
      configurations = @options.configuration || []
      @configuration = configurations.reduce(@configuration) do |configuration, name_or_path|
        named_configuration = load_configuration(name_or_path)
        configuration.deep_merge(named_configuration)
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load a configuration either from the available builtin data or from a disk
file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def load_configuration(name_or_path)
      return YAML.load_file(name_or_path) if File.exist?(name_or_path)
      name, *arguments = name_or_path.split(':')
      value = configuration_value(name)
      value = value.call(*arguments) unless Hash === value
      return value
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Compute the value of a named built-in configuration.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def configuration_value(name)
      begin
        value = Codnar::Configuration.const_get(name.upcase)
        return value if value
      rescue
        value = nil
      end
      $stderr.puts(&quot;#{$0}: Configuration: #{name} is neither a disk file nor a known configuration&quot;)
      exit(1)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print all the collected errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_errors
      @errors.each do |error|
        $stderr.puts(error)
      end
      return @errors.size
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Exit the application, unless we are running inside a test.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def exit(status)
      Kernel.exit(status) unless @is_test
      raise ExitException.new(status)
    end

  end

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Exception used to exit when running inside tests.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class ExitException &lt; Exception

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The exit status.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    attr_reader :status

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a new exception to indicate exiting the program with some status.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize(status)
      @status = status
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
To invoke an application in tests in a controlled way, we need to preserve the
state of certain global variables around the invocation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-globals-rb">
<span>lib/codnar/globals.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Save and restore the global variables when running an application inside a
test.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Globals

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run some code without affecting the global state.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.without_changes(&amp;block)
      state = Globals.new
      begin
        return block.call
      ensure
        state.restore
      end
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Restore the relevant global variables.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def restore
      $stdin = Globals.restore_file($stdin, @original_stdin)
      $stdout = Globals.restore_file($stdout, @original_stdout)
      $stderr = Globals.restore_file($stderr, @original_stderr)
      ARGV.replace(@original_argv)
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Take a snapshot of the relevant global variables.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def initialize
      @original_stdin = $stdin
      @original_stdout = $stdout
      @original_stderr = $stderr
      @original_argv = ARGV.dup
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Restore a specific global file variable to its original state.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.restore_file(current, original)
      current.close unless current == original
      return original
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Application for splitting files</h4>
<p>
Here is a simple test demonstrating invoking the command-line application for
splitting files:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-run-split-rb">
<span>test/run_split.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running the Split Codnar Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestRunSplit &lt; Test::Unit::TestCase

    include TestWithFakeFS

    def test_print_help
      Application.with_argv(%w(-h -o stdout)) { Split.new(true).run }.should == 0
      help = File.read(&quot;stdout&quot;)
      [ &quot;codnar-split&quot;, &quot;OPTIONS&quot;, &quot;DESCRIPTION&quot; ].each { |text| help.should.include?(text) }
    end

    def test_run_split
      File.open(&quot;input&quot;, &quot;w&quot;) { |file| file.puts(&quot;&lt;foo&gt;&quot;) }
      Application.with_argv(%w(-o stdout input)) { Split.new(true).run }.should == 0
      YAML.load_file(&quot;stdout&quot;).should == [ {
        &quot;name&quot; =&gt; &quot;input&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;input&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;foo&gt;&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
      } ]
    end

    def test_run_split_no_file
      Application.with_argv(%w(-e stderr)) { Split.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: No input file to split\n&quot;
    end

    def test_run_split_many_file
      Application.with_argv(%w(-e stderr one two)) { Split.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Too many input files to split\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-split-rb">
<span>lib/codnar/split.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Split &lt; Application

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the weaving Codnar application, returning its status.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def run
      super { split }
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Parse the command line options of the program.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def parse_options
      super
      case ARGV.size
      when 1 then return
      when 0 then $stderr.puts(&quot;#{$0}: No input file to split&quot;)
      else $stderr.puts(&quot;#{$0}: Too many input files to split&quot;)
      end
      exit(1)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split the specified input file into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def split
      @configuration = Codnar::Configuration::SPLIT_HTML_DOCUMENTATION if @configuration == {}
      splitter = Splitter.new(@errors, @configuration)
      print(splitter.chunks(ARGV[0]).to_yaml)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message before the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help_before_options
      print(&lt;&lt;-EOF.unindent)
        codnar-split - Split documentation or code files to chunks.

      EOF
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message after the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help_after_options
      print(&lt;&lt;-EOF.unindent(2))
          &lt;path&gt;                               Documentation or code file to split.

        DESCRIPTION:

          Split the documentation of file into chunks that are printed in YAML format to
          the output (to be read by codnar-weave). Many file formats can be split
          depending on the specified configuration. The default configuration is called
          SPLIT_HTML_DOCUMENTATION, and it preserves the whole file as a single formatted
          HTML documentation chunk. This isn't very useful.

          The configuration needs to specify a set of line classification patterns,
          parsing states and pattern-based transitions between them, the initial state,
          and expressions for formatting classified lines to HTML. See the Codnar
          documentation for details.
      EOF
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the actual command-line application script:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="bin-codnar-split">
<span>bin/codnar-split</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
#!/usr/bin/ruby -w

require &quot;codnar&quot;

exit Codnar::Split.new.run
</pre>
</div>
</div>
</p>
<h4>Application for weaving chunks</h4>
<p>
Here is a simple test demonstrating invoking the command-line application for
weaving chunk to HTML:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-run-weave-rb">
<span>test/run_weave.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running the Weave Codnar Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestRunWeave &lt; Test::Unit::TestCase

    include TestWithFakeFS

    def test_print_help
      Application.with_argv(%w(-h -o stdout)) { Weave.new(true).run }.should == 0
      help = File.read(&quot;stdout&quot;)
      [ &quot;codnar-weave&quot;, &quot;OPTIONS&quot;, &quot;DESCRIPTION&quot; ].each { |text| help.should.include?(text) }
    end

    ROOT_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;root&quot;,
      &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;root&quot;, &quot;line&quot; =&gt; 1 } ],
      &quot;html&quot; =&gt; &quot;Root\n&lt;embed src='included' type='x-codnar/include'/&gt;\n&quot;
    } ]

    INCLUDED_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;included&quot;,
      &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;included&quot;, &quot;line&quot; =&gt; 1 } ],
      &quot;html&quot; =&gt; &quot;Included&quot;
    } ]

    def test_run_weave
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(ROOT_CHUNKS.to_yaml) }
      File.open(&quot;included&quot;, &quot;w&quot;) { |file| file.write(INCLUDED_CHUNKS.to_yaml) }
      Application.with_argv(%w(-o stdout root included)) { Weave.new(true).run }.should == 0
      File.read(&quot;stdout&quot;).should == &quot;Root\nIncluded\n&quot;
    end

    def test_run_weave_missing_chunk
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(ROOT_CHUNKS.to_yaml) }
      Application.with_argv(%w(-e stderr -o stdout root)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Missing chunk: included in file: root\n&quot;
    end

    def test_run_weave_unused_chunk
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(ROOT_CHUNKS.to_yaml) }
      File.open(&quot;included&quot;, &quot;w&quot;) { |file| file.write(INCLUDED_CHUNKS.to_yaml) }
      Application.with_argv(%w(-e stderr -o stdout included root)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Unused chunk: root in file: root at line: 1\n&quot;
    end

    def test_run_weave_no_chunks
      Application.with_argv(%w(-e stderr)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: No chunk files to weave\n&quot;
    end

    FILE_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;root&quot;,
      &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;root&quot;, &quot;line&quot; =&gt; 1 } ],
      &quot;html&quot; =&gt; &quot;Root\n&lt;embed src='included.file' type='x-codnar/file'/&gt;\n&quot;
    } ]

    def test_run_weave_missing_file
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(FILE_CHUNKS.to_yaml) }
      Application.with_argv(%w(-e stderr -o stdout root)) { Weave.new(true).run }.should == 1
      double_message = &quot;No such file or directory - &quot; * 2 # Something weird in Ruby Exception.to_s
      File.read(&quot;stdout&quot;).should == &quot;Root\nFILE: included.file EXCEPTION: #{double_message}\n&quot;
      File.read(&quot;stderr&quot;).should \
        == &quot;#{$0}: Reading file: included.file exception: #{double_message} in file: root at line: 1\n&quot;
    end

    def test_run_weave_existing_file
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(FILE_CHUNKS.to_yaml) }
      File.open(&quot;included.file&quot;, &quot;w&quot;) { |file| file.write(&quot;included file\n&quot;) }
      Application.with_argv(%w(-e stderr -o stdout root)) { Weave.new(true).run }.should == 0
      File.read(&quot;stdout&quot;).should == &quot;Root\nincluded file\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-weave-rb">
<span>lib/codnar/weave.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class Weave &lt; Application

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the weaving Codnar application, returning its status.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def run
      super { weave }
    end

  protected

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Parse the command line options of the program.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def parse_options
      super
      return if ARGV.size &gt; 0
      $stderr.puts(&quot;#{$0}: No chunk files to weave&quot;)
      exit(1)
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave all the chunks together to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def weave
      @configuration = Codnar::Configuration::WEAVE_INCLUDE if @configuration == {}
      weaver = Weaver.new(@errors, ARGV, @configuration)
      puts(weaver.weave(&quot;include&quot;))
      weaver.collect_unused_chunk_errors
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message before the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help_before_options
      print(&lt;&lt;-EOF.unindent)
        codnar-weave - Weave documentation chunks to a single HTML.

      EOF
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message after the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def print_help_after_options
      print(&lt;&lt;-EOF.unindent(2))
          &lt;main-path&gt; &lt;chunks-path&gt;...         Chunk files to weave together.

        DESCRIPTION:

          Weave chunks in all chunk files (from codnar-split) to a single HTML that is
          printed to the output. The first file is the main documentation file that is
          expected to include all the rest of the chunks via directives of the format:

            &lt;embed src=&quot;chunk-name&quot; type=&quot;x-codnar/template-name&quot;&gt;&lt;/embed&gt;

          Where the template-name is a key in the configuration, whose value is an ERB
          template for embedding the named chunk into the documentation.

          If no configuration is specified, the WEAVE_INCLUDE configuration is assumed.
          This configuration contains a single template named &quot;include&quot;, which simply
          includes the named chunk into the generated HTML.
      EOF
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the actual command-line application script:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="bin-codnar-weave">
<span>bin/codnar-weave</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
#!/usr/bin/ruby -w

require &quot;codnar&quot;

exit Codnar::Weave.new.run
</pre>
</div>
</div>
</p>
<h3>Rake Integration</h3>
<p>
For Ruby projects (or any other project using Rake), it is also possible to
invoke Codnar using Rake tasks. Here is a simple test demonstrating using the
Rake tasks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-rake-tasks-rb">
<span>test/rake_tasks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;codnar/rake&quot;
require &quot;test/spec&quot;
require &quot;test_with_fakefs&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test rake tasks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  class TestRakeTasks &lt; Test::Unit::TestCase

    include TestWithFakeFS

    alias_method :original_setup, :setup

    def setup
      original_setup 
      @original_rake = ::Rake.application
      @rake = ::Rake::Application.new
      ::Rake.application = @rake
    end

    def teardown
      super
      ::Rake.application = @original_rake
    end

    def test_default
      run_rake
      test_results
    end

  protected

    def run_rake
      File.open(&quot;foo&quot;, &quot;w&quot;) { |file| file.puts(&quot;foo&quot;) }
      Rake::SplitTask.new([ &quot;foo&quot; ], [])
      Rake::WeaveTask.new(&quot;foo&quot;, [])
      @rake[&quot;codnar&quot;].invoke
    end

    def test_results
      chunk_file = Rake.chunks_dir + &quot;/foo&quot;
      YAML.load_file(chunk_file).should == [ {
        &quot;html&quot; =&gt; &quot;foo&quot;,
        &quot;name&quot; =&gt; &quot;foo&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
      } ]
      File.read(&quot;codnar.html&quot;).should == &quot;foo\n&quot;
      Rake.chunk_files.should == [ chunk_file ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
To use these tasks in a Rakefile, one needs to <code>require 'codnar/rake'</code>. The
code implements a singleton that holds the global state shared between tasks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rake-rb">
<span>lib/codnar/rake.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
require &quot;rake&quot;
require &quot;rake/tasklib&quot;

require &quot;codnar&quot;
require &quot;codnar/rake/split_task&quot;
require &quot;codnar/rake/weave_task&quot;

module Codnar

</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This module contains all the Codnar Rake tasks code.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  module Rake

    class &lt;&lt; self

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The root folder to store all chunk files under.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      attr_accessor :chunks_dir

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The list of split chunk files for later weaving.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      attr_accessor :chunk_files

    end

    Rake.chunk_files = []
    Rake.chunks_dir = &quot;chunks&quot;

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Compute options for invoking an application.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.application_options(output, configurations)
      options = [ &quot;-o&quot;, output ]
      options += [ &quot;-c&quot; ] \
               + configurations.map { |configuration| configuration.to_s } \
               + [ &quot;--&quot; ] \
        if configurations.size &gt; 0
      return options
    end

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return the list of actual configuration files (as opposed to names of
built-in configurations) for use as dependencies.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    def self.configuration_files(configurations)
      return configurations.find_all { |configuration| File.exists?(configuration.to_s) }
    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Task for splitting files</h4>
<p>
To split one or more files to chunks, create a new SplitTask. Multiple such
tasks may be created; this is required if different files need to be split
using different configurations.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rake-split-task-rb">
<span>lib/codnar/rake/split_task.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

  module Rake

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A Rake task for splitting source files to chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    class SplitTask &lt; ::Rake::TaskLib

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a new Rake task for splitting source files to chunks. Each of the
specified disk files is split using the specified set of configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def initialize(paths, configurations)
        @configurations = configurations
        paths.each do |path|
          define_tasks(path)
        end
      end

    protected

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the tasks for splitting a single source file to chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def define_tasks(path)
        output = Rake.chunks_dir + &quot;/&quot; + path
        define_split_file_task(path, output)
        SplitTask.define_common_tasks
        SplitTask.connect_common_tasks(output)
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the actual task for splitting the source file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def define_split_file_task(path, output)
        ::Rake::FileTask.define_task(output =&gt; [ path ] + Rake.configuration_files(@configurations)) do
          run_split_application(path, output)
        end
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the Split application for a single source file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def run_split_application(path, output)
        options = Rake.application_options(output, @configurations)
        options &lt;&lt; path
        Application.with_argv(options) { Split.new.run }
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define common Rake split tasks. This method may be invoked several times,
only the first invocation actually defined the tasks. The common tasks are
codnar_split (for splitting all the source files) and clean_codnar (for
getting rid of the chunks directory).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def self.define_common_tasks
        @defined_common_tasks ||= SplitTask.create_common_tasks
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Actually create common Rake split tasks.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def self.create_common_tasks
        desc &quot;Split all files into chunks&quot;
        ::Rake::Task.define_task(&quot;codnar_split&quot;)
        desc &quot;Clean all split chunks&quot;
        ::Rake::Task.define_task(&quot;clean_codnar&quot;) { rm_rf(Rake.chunks_dir) }
        ::Rake::Task.define_task(:clean =&gt; &quot;clean_codnar&quot;)
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Connect the task for splitting a single source file to the common task of
splitting all source files.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def self.connect_common_tasks(output)
        ::Rake::Task.define_task(&quot;codnar_split&quot; =&gt; output)
        Rake::chunk_files &lt;&lt; output
      end

    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Task for weaving chunks</h4>
<p>
To weave the chunks together, create a single WeaveTask.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rake-weave-task-rb">
<span>lib/codnar/rake/weave_task.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
module Codnar

  module Rake

</pre>
    <table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A Rake task for weaving chunks to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
    class WeaveTask &lt; ::Rake::TaskLib

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a Rake task for weaving chunks to a single HTML. The root source
file is expected to embed all the chunks into the output HTML. The chunks
are loaded from the results of all the previous created SplitTask-s.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def initialize(root, configurations, output = &quot;codnar.html&quot;)
        @root = Rake.chunks_dir + &quot;/&quot; + root
        @output = output
        @configurations = configurations
        define_tasks
      end

    protected

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the tasks for weaving the chunks to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def define_tasks
        define_weave_task
        connect_common_tasks
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the actual task for weaving the chunks to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def define_weave_task
        desc &quot;Weave chunks into HTML&quot; unless ::Rake.application.last_comment
        ::Rake::Task.define_task(&quot;codnar_weave&quot; =&gt; @output)
        ::Rake::FileTask.define_task(@output =&gt; Rake.chunk_files + Rake.configuration_files(@configurations)) do
          run_weave_application
        end
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the Weave application for a single source file.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def run_weave_application
        options = Rake.application_options(@output, @configurations)
        options &lt;&lt; @root
        options += Rake.chunk_files.reject { |chunk| chunk == @root }
        Application.with_argv(options) { Weave.new.run }
      end

</pre>
      <table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Connect the task for cleaning up after weaving (<tt>clobber_codnar</tt>) to
the common task of cleaning up everything (<tt>clobber</tt>).
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
      def connect_common_tasks
        desc &quot;Build the code narrative HTML&quot;
        ::Rake::Task.define_task(:codnar =&gt; &quot;codnar_weave&quot;)
        desc &quot;Remove woven HTML documentation&quot;
        ::Rake::Task.define_task(&quot;clobber_codnar&quot;) { rm_rf(@output) }
        ::Rake::Task.define_task(:clobber =&gt; &quot;clobber_codnar&quot;)
      end

    end

  end

end
</pre>
</div>
</div>
</p>
<h2>Building the Codnar gem</h2>
<p>
The following Rakefile is in charge of building the gem, with the help of some
tools described below.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="rakefile">
<span>Rakefile</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
$: &lt;&lt; File.dirname(__FILE__) + &quot;/lib&quot;

require &quot;codnar/rake&quot;
require &quot;rake/clean&quot;
require &quot;rake/gempackagetask&quot;
require &quot;rake/rdoctask&quot;
require &quot;rake/testtask&quot;
require &quot;rcov/rcovtask&quot;
require &quot;reek/rake/task&quot;
require &quot;roodi&quot;
require &quot;roodi_task&quot;

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Overall tasks
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

task :default =&gt; :all

desc &quot;Verify, document, package&quot;
task :all =&gt; [ :verify, :doc, :gem ]

desc &quot;Generate all documentation&quot;
task :doc =&gt; [ :rdoc, :codnar ]

desc &quot;Test, coverage, analyze code&quot;
task :verify =&gt; [ :rcov, :reek, :roodi, :flay, :saikuro ]

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Source file lists
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

patterns = {
  &quot;bin&quot; =&gt; &quot;bin/*&quot;,
  &quot;css&quot; =&gt; &quot;lib/codnar/data/*.css&quot;,
  &quot;data&quot; =&gt; &quot;lib/codnar/data/**/*.*&quot;,
  &quot;doc&quot; =&gt; &quot;doc/*&quot;,
  &quot;javascript&quot; =&gt; &quot;lib/codnar/data/*.js&quot;,
  &quot;lib&quot; =&gt; &quot;lib/**/*.rb&quot;,
  &quot;test&quot; =&gt; &quot;test/*.rb&quot;,
  &quot;testlib&quot; =&gt; &quot;test/lib/*.rb&quot;,
  &quot;tools&quot; =&gt; &quot;tools/*&quot;,
}
files = patterns.merge(patterns) { |key, pattern| FileList[pattern] }


</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Gem specification and packaging
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

spec = Gem::Specification.new do |s|

  s.name = &quot;codnar&quot;
  s.version = Codnar::VERSION

  s.homepage = &quot;http://codnar.rubygems.org&quot;

  s.summary = &quot;Code narrator - an inverse literate programming tool.&quot;
  s.description = (&lt;&lt;-EOF).gsub(/^\s+/, &quot;&quot;).chomp.gsub(&quot;\n&quot;, &quot; &quot;)
    Code Narrator (Codnar) is an inverse literate programming tool. It splits the
    source files into &quot;chunks&quot; (including structured comments) and weaves them back
    into a narrative that describes the overall system.
  EOF

  s.author = &quot;Oren Ben-Kiki&quot;
  s.email = &quot;rubygems-oren@ben-kiki.org&quot;

  s.requirements &lt;&lt; &quot;GVim for syntax highlighting.&quot;

  s.add_dependency(&quot;andand&quot;)
  s.add_dependency(&quot;getoptions&quot;)
  s.add_dependency(&quot;rake&quot;)
  s.add_dependency(&quot;rdiscount&quot;)
  s.add_dependency(&quot;rdoc&quot;)

  s.add_development_dependency(&quot;fakefs&quot;)
  s.add_development_dependency(&quot;flay&quot;)
  s.add_development_dependency(&quot;rcov&quot;)
  s.add_development_dependency(&quot;reek&quot;)
  s.add_development_dependency(&quot;roodi&quot;)
  s.add_development_dependency(&quot;Saikuro&quot;)
  s.add_development_dependency(&quot;test-spec&quot;)

  s.files = files.lib + files.bin + files.doc + files.data
  s.test_files = files.test + files.testlib
  s.executables = files.bin.map { |path| path.sub(&quot;bin/&quot;, &quot;&quot;) }

  s.extra_rdoc_files = [ &quot;README.rdoc&quot;, &quot;LICENSE&quot;, &quot;ChangeLog&quot; ]
  s.rdoc_options &lt;&lt; &quot;--title&quot; &lt;&lt; &quot;Code narrator #{s.version}&quot;
  s.rdoc_options &lt;&lt; &quot;--main&quot; &lt;&lt; &quot;README.rdoc&quot;
  s.rdoc_options &lt;&lt; &quot;--line-numbers&quot;
  s.rdoc_options &lt;&lt; &quot;--all&quot;
  s.rdoc_options &lt;&lt; &quot;--quiet&quot;

end

Rake::GemPackageTask.new(spec) { |package| }

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Unit tests
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

Rcov::RcovTask.new(&quot;rcov&quot;) do |task|
  task.output_dir = &quot;rcov&quot;
  task.test_files = files.test
  task.libs &lt;&lt; &quot;lib&quot; &lt;&lt; &quot;test/lib&quot;
  task.rcov_opts &lt;&lt; &quot;--failure-threshold&quot; &lt;&lt; &quot;100&quot;
  (files.lib + files.test + files.testlib).each do |file|
    task.rcov_opts &lt;&lt; &quot;--include-file&quot; &lt;&lt; file
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Code analysis
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

Reek::Rake::Task.new do |task|
  task.reek_opts &lt;&lt; &quot;--quiet&quot;
  task.source_files = files.lib + files.bin + files.test + files.testlib
end

RoodiTask.new do |task|
  task.patterns = patterns.values
  task.config = &quot;roodi.config&quot;
end

Rake::TestTask.new(&quot;test&quot;) do |task|
  task.test_files = files.test
  task.libs &lt;&lt; &quot;lib&quot; &lt;&lt; &quot;test/lib&quot;
end

desc &quot;Check for duplicated code with Flay&quot;
task :flay do
  result = IO.popen(&quot;flay lib&quot;, &quot;r&quot;).read.chomp
  unless result == &quot;Total score (lower is better) = 0\n&quot;
    print result
    raise &quot;Flay found code duplication.&quot;
  end
end

CLOBBER &lt;&lt; &quot;saikuro&quot;

desc &quot;Check for complex code with Saikuro&quot;
task :saikuro do
  system(&quot;saikuro -c -t -i lib -y 0 -e 10 -o saikuro/ &gt; /dev/null&quot;)
  result = File.read(&quot;saikuro/index_cyclo.html&quot;)
  if result.include?(&quot;Errors and Warnings&quot;)
    raise &quot;Saikuro found complicated code.&quot;
  end
end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Documentation
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>

Rake::RDocTask.new do |rdoc|
  rdoc.rdoc_files &lt;&lt; &quot;LICENSE&quot; &lt;&lt; &quot;README.rdoc&quot;
  rdoc.rdoc_files += files.bin + files.lib + files.test + files.testlib
  rdoc.main = &quot;README.rdoc&quot;
  rdoc.rdoc_dir = &quot;rdoc&quot;
  rdoc.options = spec.rdoc_options
end

def ruby_configurations(*additional_configurations)
  return [
    &quot;classify_source_code:ruby&quot;,
    &quot;format_code_sunlight:ruby&quot;,
    &quot;classify_nested_code:ruby:html&quot;,
    &quot;format_code_sunlight:html&quot;,
    &quot;classify_shell_comments&quot;,
    &quot;format_rdoc_comments&quot;
  ] + additional_configurations
end

def javascript_configurations
  return [
    &quot;classify_source_code:javascript&quot;,
    &quot;format_code_sunlight:javascript&quot;,
    &quot;classify_c_comments&quot;,
    &quot;format_markdown_comments&quot;
  ]
end

def css_configurations
  return [
    &quot;classify_source_code:css&quot;,
    &quot;format_code_sunlight:css&quot;,
    &quot;classify_c_comments&quot;,
    &quot;format_markdown_comments&quot;
  ]
end

Codnar::Rake::SplitTask.new(files.bin + files.lib + files.testlib + [ &quot;Rakefile&quot;, &quot;tools/codnar-changelog&quot; ],
                            ruby_configurations(&quot;chunk_by_vim_regions&quot;))
Codnar::Rake::SplitTask.new(files.javascript, javascript_configurations)
Codnar::Rake::SplitTask.new(files.css, css_configurations)
Codnar::Rake::SplitTask.new(files.test + files.tools - [ &quot;tools/codnar-changelog&quot; ], ruby_configurations)
Codnar::Rake::SplitTask.new(spec.files.find_all { |file| file.end_with?(&quot;.html&quot;) }, [ :split_html_documentation ])
Codnar::Rake::SplitTask.new(spec.files.find_all { |file| file.end_with?(&quot;.rdoc&quot;) }, [ :split_rdoc_documentation ])
Codnar::Rake::SplitTask.new(spec.files.find_all { |file| file.end_with?(&quot;.markdown&quot;) }, [ :split_markdown_documentation ])
Codnar::Rake::WeaveTask.new(&quot;doc/root.html&quot;, [ :weave_include, :weave_named_chunk_with_containers ])
</pre>
</div>
</div>
</p>
<h3>Automatic gem version number</h3>
<p>
The gem version number is taken from the following tool, with combination with
a running version number extracted from <code>git</code>:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="tools-codnar-version">
<span>tools/codnar-version</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
#!/bin/sh

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Major and minor revision numbers.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
export MAJOR=0
export MINOR=1

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This is only reliable as long as one developer is doing commits on one
machine. Which, so far, is the case.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
export COMMIT=`git rev-list --all | wc -l`

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This file makes the data available to the Ruby code.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
cat &lt;&lt;EOF | sed 's/\r//g'
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This module contains all the code narrator code.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
module Codnar
</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This version number.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  VERSION = &quot;$MAJOR.$MINOR.$COMMIT&quot;
</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Edit tools/codnar-version to update this file!
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
end
EOF
</pre>
</div>
</div>
</p>
<p>
And here is the current generated version file:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-version-rb">
<span>lib/codnar/version.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This module contains all the code narrator code.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
module Codnar
</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This version number.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
  VERSION = &quot;0.1.60&quot;
</pre>
  <table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Edit tools/codnar-version to update this file!
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-ruby'>
end
</pre>
</div>
</div>
</p>
<h3>Automatic change log</h3>
<p>
A standard format change log file is maintained by the following tool:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="tools-codnar-changelog">
<span>tools/codnar-changelog</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
#!/usr/bin/ruby

subjects_by_id = {}
sorted_ids = []

log_lines = `git log --pretty='format:%ci::%an &lt;%ae&gt;::%s'`

log_lines.each do |log_line|
  date, author, subject = log_line.chomp.split(&quot;::&quot;)
  date, time, zone = date.split(&quot; &quot;)
  id = &quot;#{date}\t#{author}&quot;
  sorted_ids &lt;&lt; id
  subjects_by_id[id] ||= []
  subjects_by_id[id] &lt;&lt; subject
end

sorted_ids.uniq.each do |id|
  subjects = subjects_by_id[id]
  puts &quot;#{id}\n\n&quot;
  puts subjects.map { |subject| &quot;\t* #{subject}&quot; }.join(&quot;\n&quot;)
  puts &quot;\n&quot;
end
</pre>
</div>
</div>
</p>
<h3>Automated commit procedure</h3>
<p>
The above two tools and the build process in general assumes that every commit
to <code>git</code> (on the main branch, anyway) is done by the following automated
procedure:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="tools-codnar-commit">
<span>tools/codnar-commit</span>
</a>
</div>
<div class="chunk html">
<pre class='sunlight-highlight-ruby'>
#!/bin/sh
true \
&amp;&amp; git add . \
&amp;&amp; rake clobber \
&amp;&amp; rake verify doc \
&amp;&amp; git commit &quot;$@&quot; \
&amp;&amp; tools/codnar-version &gt; lib/codnar/version.rb \
&amp;&amp; git add lib/codnar/version.rb \
&amp;&amp; tools/codnar-changelog &gt; ChangeLog \
&amp;&amp; git add ChangeLog \
&amp;&amp; rake all \
&amp;&amp; git commit --amend
</pre>
</div>
</div>
</p>
<h2>Formatting generated HTML</h2>
<p>
The generated HTML requires some tweaking to yield aesthetic, readable results.
This tweaking consists of using Javascript to control chunk visibility,
generating a table of content, and using CSS to make the HTML look better.
</p>
<h3>Javascript chunk visibilty control</h3>
<p>
The following code injects visibility controls ("+"/"-" toggles) next to each
embedded code chunk. It also hides all the chunks by default; this increases
the readability of the overall narrative, turning it into a high-level summary.
Expanding the embedded code chunks allows the reader to delve into the details.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-data-control-chunks-js">
<span>lib/codnar/data/control_chunks.js</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Quick-and-dirty JS for inserting a "+"/"-" control for chunk visibility next
to each chunk's name. By default, all chunks are hidden.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function inject_chunk_controls() {
  var name_div;
  foreach_chunk_elements(function(div) {
    name_div = div;
  }, function(html_div) {
    var control_span = document.createElement(&quot;span&quot;);
    var hide = function() {
      control_span.innerHTML = &quot;+&quot;;
      html_div.style.display = &quot;none&quot;;
    }
    var show = function() {
      control_span.innerHTML = &quot;&amp;#8211;&quot;; // Vertical bar.
      html_div.style.display = &quot;block&quot;;
    }
    name_div.onclick = function() {
      html_div.style.display == &quot;block&quot; ? hide() : show();
    }
    hide(); // Initializes html_div.style.display
    control_span.className = &quot;control chunk&quot;;
    name_div.insertBefore(control_span, name_div.firstChild);
  })
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Loop on all DIV elements that contain a chunk name, or that contain chunk
HTML. Assumes that they come in pairs - name first, HTML second.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function foreach_chunk_elements(name_lambda, html_lambda) {
  var div_elements = document.getElementsByTagName(&quot;div&quot;);
  for (var e in div_elements) {
    var div = div_elements[e];
    classes = &quot; &quot; + div.className + &quot; &quot;;
    if (!/ chunk /.test(classes)) continue;
    if (/ name /.test(classes)) name_lambda(div);
    if (/ html /.test(classes)) html_lambda(div);
  }
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Only invoke it after all helper functions are defined.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
inject_chunk_controls();
</pre>
</div>
</div>
</p>
<h3>Javascript table of content</h3>
<p>
The following code is not very efficient or elegant but it does a basic job of
iunjecting a table of content into the generated HTML.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-data-contents-js">
<span>lib/codnar/data/contents.js</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Quick-and-dirty JS for inserting a table of content inside a DIV with the id
"contents". The table of content is a series of nested UL and LI elements,
prefixed with an H1 containing the text "0 Contents". This H1 comes in
addition to the single static H1 expected by HTML best practices. It looks
"right" and should not confuse search engines etc. since they do not execute
Javascript code.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function inject_contents() {
  var contents = document.getElementById(&quot;contents&quot;);
  var lists = contents_lists();
  contents.appendChild(contents_header()); // TRICKY: Must be done after contents_lists().
  contents.appendChild(lists);
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Create a table of contents H1.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function contents_header() {
  var h = document.createElement(&quot;h1&quot;);
  var text = document.createTextNode(&quot;Contents&quot;);
  h.appendChild(text);
  return h;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Create nested UL/LI lists for the table of content.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function contents_lists() {
  var container;
  var indices = [];
  var h_elements = all_h_elements();
  for (var e in h_elements) {
    h = h_elements[e];
    var level = h.tagName.substring(1, 2) - 1;
    container = pop_container(container, indices, level);
    container = push_container(container, indices, level);
    var id = indices.join(&quot;.&quot;);
    container.appendChild(list_element(id, h));
    h.insertBefore(header_anchor(id), h.firstChild);
  }
  return pop_container(container, indices, 1);
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Get a list of all H elements in the DOM. We skip the single H1 element;
otherwise it would just have the index "1" which would be prefixed to all
other headers.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function all_h_elements() {
  var elements = document.getElementsByTagName(&quot;*&quot;);
  var h_elements = [];
  for (var e in elements) {
    var h = elements[e];
    if (/^h[2-9]$/i.test(h.tagName)) h_elements.push(h);
  }
  return h_elements;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Pop indices (and UL containers) until reaching up to a given level.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function pop_container(container, indices, level) {
  while (indices.length &gt; level) {
    container = container.parentNode;
    indices.pop();
  }
  return container;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Push indices (and UL containers) until reaching doen to a given level.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function push_container(container, indices, level) {
  while (indices.length &lt; level) {
    // TRICKY: push a 0 for the very last new level, so the ++ at the end
    // will turn it into a 1.
    indices.push(indices.level &lt; level - 1);
    var ul = document.createElement(&quot;ul&quot;);
    if (container) {
      container.appendChild(ul);
    }
    container = ul;
  }
  indices[indices.length - 1]++;
  return container;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Create a LI for an H element with some id.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function list_element(id, h) {
  var a = document.createElement(&quot;a&quot;);
  a.href = &quot;#&quot; + id;
  a.innerHTML = id + &quot;&amp;nbsp;&quot; + h.innerHTML;
  var li = document.createElement(&quot;li&quot;);
  li.appendChild(a);
  return li;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Create an anchor for an H element with some id.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
function header_anchor(id) {
  var text = document.createTextNode(id + &quot; &quot;);
  var a = document.createElement(&quot;a&quot;);
  a.id = id;
  a.appendChild(text);
  return a;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Only invoke it after all helper functions are defined.
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-javascript'>
inject_contents();
</pre>
</div>
</div>
</p>
<h3>CSS style</h3>
<p>
To avoid dealing with the different default styles used by different browsers,
we employ the YUI CSS <a href="http://developer.yahoo.com/yui/reset/">reset</a> and
<a href="http://developer.yahoo.com/yui/base/">base</a> files. Resetting and restoring the
default CSS styles is inelegant, but it is the only current way to get a
consistent presentation of HTML. Once this is out of the way, we apply styles
specific to our HTML. Some of these override the default styles established by
the base CSS file above. We do this instead of directly tweaking the base CSS
file, to allow easy upgrade to new versions if/when YUI release any.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-data-style-css">
<span>lib/codnar/data/style.css</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Margin &amp; Padding
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

div.chunk.name,
div.chunk.html,
div.chunk.containers,
div.chunk table,
div.chunk td,
div.chunk pre {
  margin: 0;
  padding: 0;
}
div.chunk *:last-child {
  margin-bottom: 0;
}
h4, h5, h6,
div.chunk,
div.comment pre {
  margin: 1em 0;
}
pre,
div.comment,
div.chunk.html {
  padding: 0.33em;
}

span.control.chunk {
  padding-left: 0.25em;
  padding-right: 0.25em;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Table of content
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

div#contents ul {
  margin-top: 0;
  margin-bottom: 0;
  padding: 0;
}

div#contents li {
  list-style-type: none;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Lists
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

ul.chunk.containers {
  padding: 0;
  margin: 0;
  display: inline;
}
ul.chunk.containers li {
  display: inline;
  list-style-type: none;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Borders
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

pre,
span.control.chunk,
div.chunk.html {
  border: 1px solid #000;
}

table.layout td.indentation,
div.chunk pre {
  border: none;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Colors
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

span.control.chunk,
table.layout td.html {
  background-color: Beige;
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Colors for GVim classes
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

span.Constant   { color: Crimson; }
span.Identifier { color: Teal; }
span.PreProc    { color: Indigo; }
span.Special    { color: Navy; }
span.Statement  { color: Maroon; }
span.Type       { color: Green; }
span.Comment    { color: Purple; }

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='markdown comment markup'>
<p>
Fonts
</p>
</div>
</td>
</tr>
</table>
<pre class='sunlight-highlight-css'>

body {
  font-family: Sans-Serif;
}
pre {
  font-family: Consolas, Inconsolata, Monaco, &quot;Courier New&quot;, Monospace;
}
div.chunk.name {
  font-weight: bold;
}
</pre>
</div>
</div>
</p>
<h3>Using Sunlight</h3>
<p>
When using Sunlight for syntax highlighting, we also need to include some CSS
and Javascript files to convert the classified <code>pre</code> elements into properly
marked-up HTML. We also need to invoke this Javascript code (a one-line
operations). See the last few lines of the <code>doc/root.html</code> file for details.
</p>
</div>
<script type="text/javascript">
/*
 * Quick-and-dirty JS for inserting a table of content inside a DIV with the id
 * "contents". The table of content is a series of nested UL and LI elements,
 * prefixed with an H1 containing the text "0 Contents". This H1 comes in
 * addition to the single static H1 expected by HTML best practices. It looks
 * "right" and should not confuse search engines etc. since they do not execute
 * Javascript code.
 */
function inject_contents() {
  var contents = document.getElementById("contents");
  var lists = contents_lists();
  contents.appendChild(contents_header()); // TRICKY: Must be done after contents_lists().
  contents.appendChild(lists);
}

/*
 * Create a table of contents H1.
 */
function contents_header() {
  var h = document.createElement("h1");
  var text = document.createTextNode("Contents");
  h.appendChild(text);
  return h;
}

/*
 * Create nested UL/LI lists for the table of content.
 */
function contents_lists() {
  var container;
  var indices = [];
  var h_elements = all_h_elements();
  for (var e in h_elements) {
    h = h_elements[e];
    var level = h.tagName.substring(1, 2) - 1;
    container = pop_container(container, indices, level);
    container = push_container(container, indices, level);
    var id = indices.join(".");
    container.appendChild(list_element(id, h));
    h.insertBefore(header_anchor(id), h.firstChild);
  }
  return pop_container(container, indices, 1);
}

/*
 * Get a list of all H elements in the DOM. We skip the single H1 element;
 * otherwise it would just have the index "1" which would be prefixed to all
 * other headers.
 */
function all_h_elements() {
  var elements = document.getElementsByTagName("*");
  var h_elements = [];
  for (var e in elements) {
    var h = elements[e];
    if (/^h[2-9]$/i.test(h.tagName)) h_elements.push(h);
  }
  return h_elements;
}

/*
 * Pop indices (and UL containers) until reaching up to a given level.
 */
function pop_container(container, indices, level) {
  while (indices.length > level) {
    container = container.parentNode;
    indices.pop();
  }
  return container;
}

/*
 * Push indices (and UL containers) until reaching doen to a given level.
 */
function push_container(container, indices, level) {
  while (indices.length < level) {
    // TRICKY: push a 0 for the very last new level, so the ++ at the end
    // will turn it into a 1.
    indices.push(indices.level < level - 1);
    var ul = document.createElement("ul");
    if (container) {
      container.appendChild(ul);
    }
    container = ul;
  }
  indices[indices.length - 1]++;
  return container;
}

/*
 * Create a LI for an H element with some id.
 */
function list_element(id, h) {
  var a = document.createElement("a");
  a.href = "#" + id;
  a.innerHTML = id + "&nbsp;" + h.innerHTML;
  var li = document.createElement("li");
  li.appendChild(a);
  return li;
}

/*
 * Create an anchor for an H element with some id.
 */
function header_anchor(id) {
  var text = document.createTextNode(id + " ");
  var a = document.createElement("a");
  a.id = id;
  a.appendChild(text);
  return a;
}

/* Only invoke it after all helper functions are defined. */
inject_contents();
/*
 * Quick-and-dirty JS for inserting a "+"/"-" control for chunk visibility next
 * to each chunk's name. By default, all chunks are hidden.
 */
function inject_chunk_controls() {
  var name_div;
  foreach_chunk_elements(function(div) {
    name_div = div;
  }, function(html_div) {
    var control_span = document.createElement("span");
    var hide = function() {
      control_span.innerHTML = "+";
      html_div.style.display = "none";
    }
    var show = function() {
      control_span.innerHTML = "&#8211;"; // Vertical bar.
      html_div.style.display = "block";
    }
    name_div.onclick = function() {
      html_div.style.display == "block" ? hide() : show();
    }
    hide(); // Initializes html_div.style.display
    control_span.className = "control chunk";
    name_div.insertBefore(control_span, name_div.firstChild);
  })
}

/*
 * Loop on all DIV elements that contain a chunk name, or that contain chunk
 * HTML. Assumes that they come in pairs - name first, HTML second.
 */
function foreach_chunk_elements(name_lambda, html_lambda) {
  var div_elements = document.getElementsByTagName("div");
  for (var e in div_elements) {
    var div = div_elements[e];
    classes = " " + div.className + " ";
    if (!/ chunk /.test(classes)) continue;
    if (/ name /.test(classes)) name_lambda(div);
    if (/ html /.test(classes)) html_lambda(div);
  }
}

/* Only invoke it after all helper functions are defined. */
inject_chunk_controls();
(function(h,o,f){var u=!+"\v1";var y=function(){return null;};var m=0;var q="plaintext";var l=function(A){function z(){}z.prototype=A;return new z();};var p=false;var i=function(A,C,z){for(var B=0;B<A.length;B++){if(A[B]===C){return true;}if(z&&typeof(A[B])==="string"&&typeof(C)==="string"&&A[B].toUpperCase()===C.toUpperCase()){return true;}}return false;};var e=function(z,A){if(!A){return z;}for(var B in A){z[B]=A[B];}return z;};var x=function(z){return z.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");};var j=function(C,B,A,z){return function(G){var F=C;if(B===1){A.reverse();}for(var D=0,E,H;D<A.length;D++){H=G[F+(D*B)];E=A[A.length-1-D];if(H===f){if(E.optional!==f&&E.optional){F-=B;}else{return false;}}else{if(H.name===E.token&&(E.values===f||i(E.values,H.value,z))){continue;}else{if(E.optional!==f&&E.optional){F-=B;}else{return false;}}}}return true;};};var c=function(B,A,C,z){return function(F){var D=B,E;var G=false;while((E=F[--D])!==f){if(E.name===C.token&&i(C.values,E.value)){if(E.name===A.token&&i(A.values,E.value,z)){G=true;break;}return false;}if(E.name===A.token&&i(A.values,E.value,z)){G=true;break;}}if(!G){return false;}D=B;while((E=F[++D])!==f){if(E.name===A.token&&i(A.values,E.value,z)){if(E.name===C.token&&i(C.values,E.value,z)){G=true;break;}return false;}if(E.name===C.token&&i(C.values,E.value,z)){G=true;break;}}return G;};};var w=function(){var z=function(A){return function(C){var B=o.createElement("span");B.className="sunlight-"+A;B.appendChild(C.createTextNode(C.tokens[C.index].value));return C.addNode(B)||true;};};return{handleToken:function(A){return z(A.tokens[A.index].name)(A);},handle_default:function(A){return A.addNode(A.createTextNode(A.tokens[A.index].value));},handle_ident:function(A){var B=function(D,E){D=D||[];for(var C=0;C<D.length;C++){if(typeof(D[C])==="function"){if(D[C](A)){return z("named-ident")(A);}}else{if(E&&E(D[C])(A.tokens)){return z("named-ident")(A);}}}return false;};return B(A.language.namedIdentRules.custom)||B(A.language.namedIdentRules.follows,function(C){return j(A.index-1,-1,C.slice(0),A.language.caseInsensitive);})||B(A.language.namedIdentRules.precedes,function(C){return j(A.index+1,1,C.slice(0),A.language.caseInsensitive);})||B(A.language.namedIdentRules.between,function(C){return c(A.index,C.opener,C.closer,A.language.caseInsensitive);})||z("ident")(A);}};}();var r=function(E){E=E.replace(/\r\n/g,"\n").replace(/\r/g,"\n");var C=0;var H=1;var A=1;var z=E.length;var B=f;var G=z>0?E.charAt(0):B;var F=false;var D=function(J){if(J===0){return"";}J=J||1;var K="",I=1;while(I<=J&&E.charAt(C+I)!==""){K+=E.charAt(C+I++);}return K===""?B:K;};return{toString:function(){return"length: "+z+", index: "+C+", line: "+H+", column: "+A+", current: ["+G+"]";},peek:function(I){return D(I);},read:function(I){var K=D(I);if(K!==B){C+=K.length;A+=K.length;if(F){H++;A=1;F=false;}var J=K.substring(0,K.length-1).replace(/[^\n]/g,"").length;if(J>0){H+=J;A=1;}if(K.charAt(K.length-1)==="\n"){F=true;}G=K.charAt(K.length-1);}else{C=z;G=B;}return K;},getLine:function(){return H;},getColumn:function(){return A;},isEof:function(){return C>=z;},EOF:B,current:function(){return G;}};};var b=function(B,G,C,z){G=G||[];var F=B.reader.current();if(B.language.caseInsensitive){F=F.toUpperCase();}if(!G[F]){return null;}G=G[F];for(var E=0,A,H;E<G.length;E++){A=G[E].value;H=F+B.reader.peek(A.length);if(A===H||G[E].regex.test(H)){var I=B.reader.getLine(),D=B.reader.getColumn();return B.createToken(C,B.reader.current()+B.reader[z?"peek":"read"](A.length-1),I,D);}}return null;};var v=function(){var z=function(I,J){var G=I[2]||[];var F=I[1].length;var K=typeof(I[1])==="string"?new RegExp(x(I[1])):I[1].regex;var H=I[3]||false;return function(P,L,N,M,R,O){var Q=false,N=N||"";O=O?1:0;var S=function(V){var T;var W=P.reader.current();for(var U=0;U<G.length;U++){T=(V?W:"")+P.reader.peek(G[U].length-V);if(T===G[U]){N+=P.reader.read(T.length-V);return true;}}T=(V?W:"")+P.reader.peek(F-V);if(K.test(T)){Q=true;return false;}N+=V?W:P.reader.read();return true;};if(!O||S(true)){while(P.reader.peek()!==P.reader.EOF&&S(false)){}}if(O){N+=P.reader.current();P.reader.read();}else{N+=H||P.reader.peek()===P.reader.EOF?"":P.reader.read(F);}if(!Q){P.continuation=L;}return P.createToken(J,N,M,R);};};var D=function(H){var N=function(){return H.language.identFirstLetter&&H.language.identFirstLetter.test(H.reader.current());};var J=function(){return b(H,H.language.keywords,"keyword");};var O=function(){if(H.language.customTokens===f){return null;}for(var R in H.language.customTokens){var Q=b(H,H.language.customTokens[R],R);if(Q!==null){return Q;}}return null;};var M=function(){return b(H,H.language.operators,"operator");};var I=function(){var Q=H.reader.current();if(H.language.punctuation.test(x(Q))){return H.createToken("punctuation",Q,H.reader.getLine(),H.reader.getColumn());}return null;};var G=function(S){if(!N()){return null;}var U=H.reader.current();var R=H.reader.peek();var Q=H.reader.getLine(),T=H.reader.getColumn();while(R!==H.reader.EOF){if(!H.language.identAfterFirstLetter.test(R)){break;}U+=H.reader.read();R=H.reader.peek();}return H.createToken(S?"namedIdent":"ident",U,Q,T);};var P=function(){if(H.defaultData.text===""){H.defaultData.line=H.reader.getLine();H.defaultData.column=H.reader.getColumn();}H.defaultData.text+=H.reader.current();return null;};var F=function(){var X=H.reader.current();for(var W in H.language.scopes){var R=H.language.scopes[W];for(var T=0,V,S,U,Q;T<R.length;T++){V=R[T][0];if(V!==X+H.reader.peek(V.length-1)){continue;}S=H.reader.getLine(),U=H.reader.getColumn();H.reader.read(V.length-1);Q=z(R[T],W);return Q(H,Q,V,S,U);}}return null;};var K=function(){return H.language.numberParser(H);};var L=function(){var S=H.language.customParseRules;if(S===f){return null;}for(var R=0,Q;R<S.length;R++){Q=S[R](H);if(Q!==null){return Q;}}return null;};return L()||O()||J()||F()||G()||K()||M()||I()||P();};var E=function(I,K,F){var J=[];var H={reader:r(I),language:K,token:function(L){return J[L];},getAllTokens:function(){return J.slice(0);},count:function(){return J.length;},defaultData:{text:"",line:1,column:1},createToken:function(M,O,L,N){return{name:M,line:L,value:u?O.replace(/\n/g,"\r"):O,column:N};}};if(F){J.push(F(H,F,"",H.reader.getLine(),H.reader.getColumn(),true));}while(!H.reader.isEof()){var G=D(H);if(G!==null){if(H.defaultData.text!==""){J.push(H.createToken("default",H.defaultData.text,H.defaultData.line,H.defaultData.column));H.defaultData.text="";}if(G[0]!==f){J=J.concat(G);}else{J.push(G);}}H.reader.read();}if(H.defaultData.text!==""){J.push(H.createToken("default",H.defaultData.text,H.defaultData.line,H.defaultData.column));}return{tokens:J,continuation:H.continuation};};var B=function(I,L,J,H){var F=[];var G=E(I,L,J.continuation);var K=function(){var M=String.fromCharCode(160);var N=new Array(H.tabWidth+1).join(M);return function(O){return O.split(" ").join(M).split("\t").join(N);};}();return{tokens:(J.tokens||[]).concat(G.tokens),index:J.index?J.index+1:0,language:L,continuation:G.continuation,addNode:function(M){F.push(M);},createTextNode:function(M){return o.createTextNode(K(M));},getNodes:function(){return F;}};};var C=function(N,G,M){if(!p){p=function(){var P=null;if(o.defaultView&&o.defaultView.getComputedStyle){P=o.defaultView.getComputedStyle;}else{if(typeof(o.body.currentStyle)!=="undefined"){P=function(R,Q){return R.currentStyle;};}else{P=y;}}return function(Q,R){return P(Q,null)[R];};}();}M=M||{};var J=k[G];if(J===f){J=k[q];}var O=B(N,J,M,this.options);var L=J.analyzer;for(var K=M.index?M.index+1:0,I,H,F;K<O.tokens.length;K++){O.index=K;I=O.tokens[K].name;H="handle_"+I;L[H]?L[H](O):L.handleToken(O);}return O;};return{highlight:function(G,F){return C.call(this,G,F);},highlightNode:function A(Q){var J;if((J=Q.className.match(/(?:\s|^)sunlight-highlight-(\S+)(?:\s|$)/))===null||/(?:\s|^)sunlight-highlighted(?:\s|$)/.test(Q.className)){return;}var V=J[1];var K=0;for(var S=0,T,O,R,L;S<Q.childNodes.length;S++){if(Q.childNodes[S].nodeType===3){T=o.createElement("span");T.className="sunlight-highlighted sunlight-"+V;L=C.call(this,Q.childNodes[S].nodeValue,V,L);m++;K=K||m;O=L.getNodes();for(R=0;R<O.length;R++){T.appendChild(O[R]);}Q.replaceChild(T,Q.childNodes[S]);}else{A.call(this,Q.childNodes[S]);}}Q.className+=" sunlight-highlighted";if(this.options.lineNumbers===true||(p&&this.options.lineNumbers==="automatic"&&p(Q,"display")==="block")){var M=o.createElement("div"),F=o.createElement("pre");var P=Q.innerHTML.replace(/[^\n]/g,"").length-/\n$/.test(Q.lastChild.innerHTML);var G,W,N=this.options.lineHighlight.length>0;if(N){G=o.createElement("div");G.className="sunlight-line-highlight-overlay";}M.className="sunlight-container";F.className="sunlight-line-number-margin";for(var U=this.options.lineNumberStart,I=o.createTextNode(u?"\r":"\n"),H,X;U<=this.options.lineNumberStart+P;U++){H=o.createElement("a");X=(Q.id?Q.id:"sunlight-"+K)+"-line-"+U;H.setAttribute("name",X);H.setAttribute("href","#"+X);H.appendChild(o.createTextNode(U));F.appendChild(H);F.appendChild(I.cloneNode(false));if(N){W=o.createElement("div");if(i(this.options.lineHighlight,U)){W.className="sunlight-line-highlight-active";}G.appendChild(W);}}M.appendChild(F);Q.parentNode.insertBefore(M,Q);Q.parentNode.removeChild(Q);M.appendChild(Q);if(N){M.appendChild(G);}}}};}();var g=function(z){this.options=e(e({},a),z);};g.prototype=v;var d=function(C,z,B){B=B||1;var A=C[z+B];if(A!==f&&A.name==="default"){A=C[z+(B*2)];}return A;};var s=function(F,E,z){var A={};for(var B=0,D,C;B<F.length;B++){D=z?F[B].toUpperCase():F[B];C=D.charAt(0);if(!A[C]){A[C]=[];}A[C].push({value:D,regex:new RegExp(x(D)+E,z?"i":"")});}return A;};var t=function(C){var F=C.reader.current(),E,A=C.reader.getLine(),D=C.reader.getColumn();if(!/\d/.test(F)){if(F!=="."||!/\d/.test(C.reader.peek())){return null;}E=F+C.reader.read();}else{E=F;}var B,z=false;while((B=C.reader.peek())!==C.reader.EOF){if(!/[A-Za-z0-9]/.test(B)){if(B==="."&&!z){E+=C.reader.read();z=true;continue;}break;}E+=C.reader.read();}return C.createToken("number",E,A,D);};var a={tabWidth:4,lineNumbers:"automatic",lineNumberStart:1,lineHighlight:[]};var k={};var n={analyzer:l(w),customTokens:[],namedIdentRules:{},punctuation:/[^\w\s]/,numberParser:t,caseInsensitive:false};h.Sunlight={version:"1.3",Highlighter:g,createAnalyzer:function(){return l(w);},globalOptions:a,highlightAll:function(B){var A=new g(B);var z=o.getElementsByTagName("*");for(var C=0;C<z.length;C++){A.highlightNode(z[C]);}},registerLanguage:function(z,B){if(!z){throw'Languages must be registered with an identifier, e.g. "php" for PHP';}B=e(e({},n),B);B.name=z;B.keywords=s(B.keywords||[],"\\b",B.caseInsensitive);B.operators=s(B.operators||[],"",B.caseInsensitive);for(var A in B.customTokens){B.customTokens[A]=s(B.customTokens[A].values,B.customTokens[A].boundary,B.caseInsensitive);}k[B.name]=B;},util:{escapeSequences:["\\n","\\t","\\r","\\\\","\\v","\\f"],contains:i,matchWord:b,createHashMap:s,createBetweenRule:c,createProceduralRule:j,getNextNonWsToken:function(A,z){return d(A,z,1);},getPreviousNonWsToken:function(A,z){return d(A,z,-1);},whitespace:{token:"default",optional:true}}};h.Sunlight.registerLanguage(q,{punctuation:/(?!x)x/,numberParser:y});}(window,document));
(function(b,c){if(b===c||b.registerLanguage===c){throw"Include sunlight.js before including language files";}var a=function(d){var g,i=d.count(),j=d.getAllTokens();while((g=d.token(--i))!==c){if(g.name==="punctuation"&&g.value==="}"){break;}else{if(g.name==="punctuation"&&g.value==="{"){return null;}}}var k="",e=true,h=1;var l=d.reader.peek();var m=d.reader.getLine(),f=d.reader.getColumn();while(l.length===h){letter=l.charAt(l.length-1);if(/[^\w-]$/.test(l)){e=false;if(letter==="{"){break;}if(letter===";"){return null;}}if(e){k+=letter;}l=d.reader.peek(++h);}return k;};b.registerLanguage("css",{caseInsensitive:true,keywords:["background-color","background-image","background-repeat","background-attachment","background-position","background-clip","background-origin","background-size","background","border-collapse","border-top-style","border-right-style","border-left-style","border-bottom-style","border-style","border-top-width","border-right-width","border-left-width","border-bottom-width","border-width","border-top-color","border-right-color","border-left-color","border-bottom-color","border-color","border-radius","border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius","border-image-repeat","border-image-source","border-image-slice","border-image-width","border-image-outset","border-image","border-top","border-bottom","border-right","border-left","border-spacing","border","box-decoration-break","box-shadow","voice-volume","voice-balance","pause-before","pause-after","pause","rest-before","rest-after","rest","cue-before","cue-after","cue","mark-before","mark-after","mark","voice-family","voice-rate","voice-pitch","voice-pitch-range","voice-stress","voice-duration","phonemes","speak-header","speak-numeral","speak-punctuation","pitch-range","play-during","richness","speak","speech-rate","appearance","icon","box-sizing","outline-width","outline-style","outline-color","outline-offset","outline","resize","cursor","nav-index","nav-up","nav-right","nav-down","nav-left","display","position","float","clear","visibility","bottom","top","left","right","overflow","overflow-x","overflow-y","overflow-style","marquee-style","marquee-direction","marquee-play-count","marquee-speed","padding-top","padding-right","padding-bottom","padding-left","padding","margin-top","margin-right","margin-bottom","margin-left","margin","width","height","min-width","max-width","min-height","max-height","rotation-point","rotation","white-space-collapsing","white-space","line-break","word-break","hyphens","hyphenate-character","hyphenate-limit-before","hyphenate-limit-after","hyphenate-limit-lines","hyphenate-limit-last","hyphenate-resource","text-wrap","word-wrap","text-align-first","text-align-last","text-align","text-justify","word-spacing","letter-spacing","text-trim","text-autospace","text-indent","hanging-punctuation","text-decoration-line","text-decoration-color","text-decoration-style","text-decoration-skip","text-decoration","text-underline-position","text-emphasis-position","text-emphasis-style","text-emphasis-color","text-emphasis","text-shadow","text-outline","text-transform","vertical-align","direction","unicode-bidi","writing-mode","text-orientation","text-combine","color","opacity","font-family","font-weight","font-stretch","font-style","font-size-adjust","font-size","font-synthesis","src","unicode-range","font-feature-settings","font-kerning","vertical-position","font-variant-ligatures","font-variant-caps","font-variant-numeric","font-variant-alternates","font-variant-east-asian","font-variant","font-feature-settings","font-language-override","font","line-height","text-height","transform-origin","transform-style","perspective-origin","perspective","backface-visibility","transform","transition-property","transition-duration","transition-timing-function","transition-delay","list-style-type","list-style-image","list-style-position","list-style","column-width","column-count","colunns","column-gap","column-rule-color","column-rule-style","column-rule-width","column-rule","break-before","break-after","break-inside","column-span","column-fill","caption-side","table-layout","empty-cells","fit-position","fit","image-orientation","orphans","page-break-after","page-break-before","page-break-inside","page","size","widows","content","z-index","counter-increment","counter-reset","azimuth","elevation","quotes","filter","zoom","-moz-appearance","-moz-background-clip","-moz-background-inline-policy","-moz-background-origin","-moz-background-size","-moz-binding","-moz-border-bottom-colors","-moz-border-left-colors","-moz-border-right-colors","-moz-border-top-colors","-moz-border-end","-moz-border-end-color","-moz-border-end-style","-moz-border-end-width","-moz-border-image","-moz-border-start","-moz-border-start-color","-moz-border-start-style","-moz-border-start-width","-moz-box-align","-moz-box-direction","-moz-box-flex","-moz-box-flexgroup","-moz-box-ordinal-group","-moz-box-orient","-moz-box-pack","-moz-box-sizing","-moz-column-count","-moz-column-gap","-moz-column-width","-moz-column-rule","-moz-column-rule-width","-moz-column-rule-style","-moz-column-rule-color","-moz-float-edge","-moz-font-feature-settings","-moz-font-language-override","-moz-force-broken-image-icon","-moz-image-region","-moz-margin-end","-moz-margin","-moz-opacity","-moz-outline","-moz-outline-color","-moz-outline-offset","-moz-outline-radius","-moz-outline-radius-bottomleft","-moz-outline-radius-bottomright","-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-style","-moz-outline-width","-moz-padding-end","-moz-padding-start","-moz-stack-sizing","-moz-tab-size","-moz-transform","-moz-transform-origin","-moz-transition","-moz-transition-delay","-moz-transition-duration","-moz-transition-property","-moz-transition-timing-function","-moz-user-focus","-moz-user-input","-moz-user-modify","-moz-user-select","-moz-window-shadow","-webkit-appearance","-webkit-background-clip","-webkit-background-composite","-webkit-background-origin","-webkit-background-size","-webkit-binding","-webkit-border-bottom-left-radius","-webkit-border-bottom-right-radius","-webkit-border-fit","-webkit-border-horizontal-spacing","-webkit-border-image","-webkit-border-radius","-webkit-border-top-left-radius","-webkit-border-top-right-radius","-webkit-border-vertical-spacing","-webkit-box-align","-webkit-box-direction","-webkit-box-flex","-webkit-box-flex-group","-webkit-box-lines","-webkit-box-ordinal-group","-webkit-box-orient","-webkit-box-pack","-webkit-box-shadow","-webkit-box-sizing","-webkit-column-break-after","-webkit-column-break-before","-webkit-column-break-inside","-webkit-column-count","-webkit-column-gap","-webkit-column-rule","-webkit-column-rule-color","-webkit-column-rule-style","-webkit-column-rule-width","-webkit-column-width","-webkit-columns","-webkit-dashboard-region","-webkit-font-size-delta","-webkit-highlight","-webkit-line-break","-webkit-line-clamp","-webkit-margin-bottom-collapse","-webkit-margin-collapse	#","-webkit-margin-start","-webkit-margin-top-collapse","-webkit-marquee","-webkit-marquee-direction","-webkit-marquee-increment","-webkit-marquee-repetition","-webkit-marquee-speed","-webkit-marquee-style","-webkit-match-nearest-mail-blockquote-color","-webkit-nbsp-mode","-webkit-padding-start","-webkit-rtl-ordering","-webkit-text-decorations-in-effect","-webkit-text-fill-color","-webkit-text-security","-webkit-text-size-adjust","-webkit-text-stroke","-webkit-text-stroke-color","-webkit-text-stroke-width","-webkit-user-drag","-webkit-user-modify","-webkit-user-select","-o-border-image","-o-device-pixel-ratio","-o-linear-gradient","-o-repeating-linear-gradient","-o-object-fit","-o-object-position","-o-tab-size","-o-table-baseline","-o-transform","-o-transform-origin","-o-transition","-o-transition-delay","-o-transition-duration","-o-transition-property","-o-transition-timing-function","-o-zoom-in","-o-zoom-out","-ms-accelerator","-ms-background-position-x","-ms-background-position-y","-ms-behavior","-ms-block-progression","-ms-filter","-ms-ime-mode","-ms-layout-grid","-ms-layout-grid-char","-ms-layout-grid-line","-ms-layout-grid-mode","-ms-layout-grid-type","-ms-line-break","-ms-line-grid-mode","-ms-interpolation-mode","-ms-overflow-x","-ms-overflow-y","-ms-scrollbar-3dlight-color","-ms-scrollbar-arrow-color","-ms-scrollbar-base-color","-ms-scrollbar-darkshadow-color","-ms-scrollbar-face-color","-ms-scrollbar-highlight-color","-ms-scrollbar-shadow-color","-ms-scrollbar-track-color","-ms-text-align-last","-ms-text-autospace","-ms-text-justify","-ms-text-kashida-space","-ms-text-overflow","-ms-text-underline-position","-ms-word-break","-ms-word-wrap","-ms-writing-mode","-ms-zoom"],customParseRules:[function(){var d=b.util.createHashMap(["matrix","translate","translateX","translateY","scaleX","scaleY","rotate","skewX","skewY","skew","translate3d","scaleZ","translateZ","rotate3d","perspective","url","alpha","basicimage","blur","dropshadow","engrave","glow","light","maskfilter","motionblur","shadow","wave"],"\\b",true);return function(g){var f=b.util.matchWord(g,d,"function",true);if(f===null){return null;}var h=f.value.length,e=g.reader.peek(h);while(e.length===h&&e!==g.reader.EOF){if(!/\s$/.test(e)){if(e.charAt(e.length-1)==="("){g.reader.read(f.value.length-1);return f;}break;}e=g.reader.peek(++h);}return null;};}(),function(){var d=b.util.createHashMap(["root","nth-child","nth-last-child","nth-of-type","nth-last-of-type","first-child","last-child","first-of-type","last-of-type","only-child","only-of-type","empty","link","visited","active","hover","focus","target","lang","enabled","disabled","checked","first-line","first-letter","before","after","not","read-only","read-write","default","valid","invalid","in-range","out-of-range","required","optional"],"\\b",true);return function(e){var f=b.util.getPreviousNonWsToken(e.getAllTokens(),e.count());if(!f||f.name!=="operator"||f.value!==":"){return null;}return b.util.matchWord(e,d,"pseudoClass");};}(),function(){var d=b.util.createHashMap(["before","after","value","choices","repeat-item","repeat-index","marker"],"\\b",true);return function(e){var f=b.util.getPreviousNonWsToken(e.getAllTokens(),e.count());if(!f||f.name!=="operator"||f.value!=="::"){return null;}return b.util.matchWord(e,d,"pseudoElement");};}(),function(e){if(e.reader.current()!=="."){return null;}var g=a(e);if(g===null){return null;}var d=e.reader.getLine(),f=e.reader.getColumn();e.reader.read(g.length);return[e.createToken("operator",".",d,f),e.createToken("class",g,d,f+1)];},function(f){var i=f.reader.current();if(!/[A-Za-z_]/.test(i)){return null;}var h=b.util.getPreviousNonWsToken(f.getAllTokens(),f.count());if(h&&h.name==="operator"&&(h.value===":"||h.value==="::")){return null;}var e=a(f);if(e===null){return null;}var d=f.reader.getLine(),g=f.reader.getColumn();f.reader.read(e.length);return f.createToken("element",i+e,d,g);},function(f){if(f.reader.current()!=="#"){return null;}var e=f.reader.peek(),j=1,k="#",i,h=true;var d=f.reader.getLine(),g=f.reader.getColumn();while(e.length===j){i=e.charAt(e.length-1);if(i==="}"||i===";"){break;}if(i==="{"){return null;}if(h&&/[A-Fa-f0-9]/.test(i)){k+=i;}else{h=false;}e=f.reader.peek(++j);}f.reader.read(k.length-1);return f.createToken("hexColor",k,d,g);}],customTokens:{rule:{values:["@import","@media","@font-face","@phonetic-alphabet","@hyphenate-resource","@font-feature-values","@charset","@namespace","@page","@bottom-left-corner","@bottom-left","@bottom-center","@bottom-right","@bottom-right-corner","@top-left-corner","@top-left","@top-center","@top-right","@top-right-corner"],boundary:"\\b"},microsoftFilterPrefix:{values:["progid:DXImageTransform.Microsoft"],boundary:"\\b"}},scopes:{string:[['"','"',['\\"',"\\\\"]],["'","'",["\\'","\\\\"]]],comment:[["/*","*/"]],id:[["#",{length:1,regex:/[^-\w]/},null,true]]},identFirstLetter:/[A-Za-z-]/,identAfterFirstLetter:/[\w-]/,operators:["::",":",">","+","~=","^=","$=","|=","=",".","*"]});}(window.Sunlight));
(function(a,b){if(a===b||a.registerLanguage===b){throw"Include sunlight.js before including language files";}a.registerLanguage("javascript",{keywords:["break","case","catch","continue","default","delete","do","else","finally","for","function","if","in","instanceof","new","return","switch","this","throw","try","typeof","var","void","while","with","true","false","null"],customTokens:{reservedWord:{values:["abstract","boolean","byte","char","class","const","debugger","double","enum","export","extends","final","float","goto","implements","import","int","interface","long","native","package","private","protected","public","short","static","super","synchronized","throws","transient","volatile"],boundary:"\\b"},globalVariable:{values:["NaN","Infinity"],boundary:"\\b"},globalFunction:{values:["encodeURI","encodeURIComponent","decodeURI","decodeURIComponent","parseInt","parseFloat","isNaN","isFinite","eval"],boundary:"\\b"},globalObject:{values:["Math","JSON","XMLHttpRequest","XDomainRequest","ActiveXObject","Boolean","Date","Array","Image","Function","Object","Number","RegExp","String"],boundary:"\\b"}},scopes:{string:[['"','"',a.util.escapeSequences.concat(['\\"'])],["'","'",a.util.escapeSequences.concat(["\\'","\\\\"])]],comment:[["//","\n",null,true],["/*","*/"]]},customParseRules:[function(e){var d=e.reader.peek();if(e.reader.current()!=="/"||d==="/"||d==="*"){return null;}var j=function(){var l=e.token(e.count()-1);var k=null;if(e.defaultData.text!==""){k=e.createToken("default",e.defaultData.text);}if(!k){k=l;}if(k===b){return true;}if(k.name==="default"&&k.value.indexOf("\n")>-1){return true;}if(l.name==="keyword"||l.name==="ident"||l.name==="number"){return false;}return true;}();if(!j){return null;}var i="/";var c=e.reader.getLine();var g=e.reader.getColumn();var h,f;while(e.reader.peek()!==e.reader.EOF){h=e.reader.peek(2);if(h==="\\/"||h==="\\\\"){i+=e.reader.read(2);continue;}i+=(f=e.reader.read());if(f==="/"){break;}}while(e.reader.peek()!==e.reader.EOF){if(!/[A-Za-z]/.test(e.reader.peek())){break;}i+=e.reader.read();}return e.createToken("regexLiteral",i,c,g);}],identFirstLetter:/[$A-Za-z_]/,identAfterFirstLetter:/[\w\$]/,namedIdentRules:{follows:[[{token:"keyword",values:["function"]},a.util.whitespace]]},operators:["++","+=","+","--","-=","-","*=","*","/=","/","%=","%","&&","||","|=","|","&=","&","^=","^",">>>=",">>>",">>=",">>","<<=","<<","<=","<",">=",">","===","==","!==","!=","!","~","?",":",".","="]});}(window.Sunlight));
(function(c,a,d){if(c===d||c.registerLanguage===d){throw"Include sunlight.js before including language files";}var b=[];c.registerLanguage("ruby",{keywords:["BEGIN","END","__ENCODING__","__END__","__FILE__","__LINE__","alias","and","begin","break","case","class","def","defined?","do","else","elsif","end","ensure","false","for","if","in","module","next","nil","not","or","redo","rescue","retry","return","self","super","then","true","undef","unless","until","when","while","yield"],customTokens:{"function":{values:["Array","Float","Integer","String","at_exit","autoload","binding","caller","catch","chop!","chop","chomp!","chomp","eval","exec","exit!","exit","fail","fork","format","gets","global_variables","gsub!","gsub","iterator?","lambda","load","local_variables","loop","open","p","print","printf","proc","putc","puts","raise","rand","readline","readlines","require","select","sleep","split","sprintf","srand","sub!","sub","syscall","system","test","trace_var","trap","untrace_var"],boundary:"\\W"},specialOperator:{values:["defined?","eql?","equal?"],boundary:"\\W"}},customParseRules:[function(g){var f=g.reader.peek();if(g.reader.current()!=="/"||f==="/"||f==="*"){return null;}var l=function(){var n=g.token(g.count()-1);var m=null;if(g.defaultData.text!==""){m=g.createToken("default",g.defaultData.text);}if(!m){m=n;}if(m===d){return true;}if(m.name==="default"&&m.value.indexOf("\n")>-1){return true;}if(n.name==="keyword"||n.name==="ident"||n.name==="number"){return false;}return true;}();if(!l){return null;}var k="/";var e=g.reader.getLine();var i=g.reader.getColumn();var j,h;while(g.reader.peek()!==g.reader.EOF){j=g.reader.peek(2);if(j==="\\/"||j==="\\\\"){k+=g.reader.read(2);continue;}k+=(h=g.reader.read());if(h==="/"){break;}}while(g.reader.peek()!==g.reader.EOF){if(!/[A-Za-z]/.test(g.reader.peek())){break;}k+=g.reader.read();}return g.createToken("regexLiteral",k,e,i);},function(g){if(g.reader.current()!=="<"||g.reader.peek()!=="<"){return null;}var e=c.util.getPreviousNonWsToken(g.getAllTokens(),g.count()-1);if(e&&(e.name==="ident"||e.name==="number"||e.name==="string")){return null;}var o=g.reader.getLine(),i=g.reader.getColumn();var m="<<",j="";g.reader.read(2);var l=g.reader.current();var f="";if(l==="-"){g.reader.read();m+=l;l=g.reader.current();}if(c.util.contains(['"',"'","`"],l)){f=l;}else{j=l;}m+=l;var n;while((n=g.reader.peek())!==g.reader.EOF){if(n==="\n"||(f===""&&/\W/.test(n))){break;}if(n==="\\"){var k=g.reader.peek(2);if(f!==""&&c.util.contains(["\\"+f,"\\\\"],k)){m+=k;j+=g.reader.read(2);continue;}}m+=g.reader.read();if(f!==""&&n===f){break;}j+=n;}b.push(j);var h=g.createToken("heredocDeclaration",m,o,i);return h;},function(g){if(b.length===0){return null;}if(g.defaultData.text.replace(/[^\n]/g,"").length===0){return null;}var j=[],k,f,h,i=g.reader.current();while(b.length>0&&g.reader.peek()!==g.reader.EOF){k=b.shift();f=g.reader.getLine(),h=g.reader.getColumn();while(g.reader.peek()!==g.reader.EOF){var e=g.reader.peek(k.length+2);if(e==="\n"+k||e==="\n"+k+"\n"){i+=g.reader.read(k.length+2);break;}i+=g.reader.read();}j.push(g.createToken("heredoc",i,f,h));i="";}return j.length>0?j:null;},function(h){if(h.reader.current()!=="%"){return null;}var k="%",j=1,l=false;var g=h.reader.peek();if(g==="q"||g==="Q"||g==="r"){j++;if(g==="r"){l=true;}}if(/[A-Za-z0-9=]$/.test(h.reader.peek(j))){return null;}var e=h.reader.getLine(),i=h.reader.getColumn();k+=h.reader.read(j);var f=k.charAt(k.length-1);switch(f){case"(":f=")";break;case"[":f="]";break;case"{":f="}";break;}while((g=h.reader.peek())!==h.reader.EOF){if(g==="\\"&&c.util.contains(["\\"+f,"\\\\"],h.reader.peek(2))){k+=h.reader.read(2);continue;}k+=h.reader.read();if(g===f){break;}}if(l){while(h.reader.peek()!==h.reader.EOF){if(!/[A-Za-z]/.test(h.reader.peek())){break;}k+=h.reader.read();}}return h.createToken(l?"regexLiteral":"rawString",k,e,i);},function(h){if(h.reader.current()!=="="||h.reader.peek(5)!=="begin"){return null;}if((h.count()===0&&h.defaultData.text==="")||h.defaultData.text.charAt(h.defaultData.text.length-1)!=="\n"){return null;}var j="=begin";var f=h.reader.getLine();var i=h.reader.getColumn();h.reader.read(5);var e=false,g;while((g=h.reader.peek())!==h.reader.EOF){if(!e&&h.reader.peek(5)==="\n=end"){e=true;j+=h.reader.read(5);continue;}if(e&&g==="\n"){break;}j+=h.reader.read();}return h.createToken("docComment",j,f,i);}],scopes:{string:[['"','"',c.util.escapeSequences.concat(['\\"'])],["'","'",["\\'","\\\\"]]],comment:[["#","\n",null,true]],subshellCommand:[["`","`",["\\`"]]],globalVariable:[["$",{length:1,regex:/[\W]/},null,true]],instanceVariable:[["@",{length:1,regex:/[\W]/},null,true]]},identFirstLetter:/[A-Za-z_]/,identAfterFirstLetter:/\w/,namedIdentRules:{follows:[[{token:"keyword",values:["class","def"]},c.util.whitespace],[{token:"keyword",values:["class"]},c.util.whitespace,{token:"ident"},c.util.whitespace,{token:"operator",values:["<","<<"]},c.util.whitespace]],precedes:[[c.util.whitespace,{token:"operator",values:["::"]}],[c.util.whitespace,{token:"operator",values:["."]},c.util.whitespace,{token:"ident",values:["new"]},c.util.whitespace,{token:"punctuation",values:["("]}]]},operators:["?","...","..",".","::",":","[]","+=","+","-=","-","**=","*=","**","*","/=","/","%=","%","&&=","&=","&&","&","||=","|=","||","|","^=","^","~","<=>","<<=","<<","<=","<",">>=",">>",">=",">","!~","!=","!","=>","===","==","=~","="]});}(window.Sunlight,document));
Sunlight.globalOptions.lineNumbers = false;
Sunlight.highlightAll();
</script>
</body>
</html>
