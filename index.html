<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Code narrator - an inverse literate programming tool.</title>
<style type="text/css">
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * YUI Reset
 * @module reset
 * @namespace
 * @requires 
 */
html {
	color: #000;
	background: #FFF;
}

body,
div,
dl,
dt,
dd,
ul,
ol,
li,
h1,
h2,
h3,
h4,
h5,
h6,
pre,
code,
form,
fieldset,
legend,
input,
button,
textarea,
p,
blockquote,
th,
td {
	margin: 0;
	padding: 0;
}

table {
	border-collapse: collapse;
	border-spacing: 0;
}

fieldset,
img {
	border: 0;
}

address,
caption,
cite,
code,
dfn,
em,
strong,
th,
var,
optgroup {
	font-style: inherit;
	font-weight: inherit;
}

del,
ins {
	text-decoration: none;
}

li {
	list-style: none;
}

caption,
th {
	text-align: left;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-size: 100%;
	font-weight: normal;
}

q:before,
q:after {
	content: '';
}

abbr,
acronym {
	border: 0;
	font-variant: normal;
}

sup {
	vertical-align: baseline;
}

sub {
	vertical-align: baseline;
}

/*because legend doesn't inherit in IE */
legend {
	color: #000;
}

input,
button,
textarea,
select,
optgroup,
option {
	font-family: inherit;
	font-size: inherit;
	font-style: inherit;
	font-weight: inherit;
}

/*@purpose To enable resizing for IE */
/*@branch For IE6-Win, IE7-Win */
input,
button,
textarea,
select {
	*font-size: 100%;
}



/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * YUI Base
 * @module base
 * @namespace yui-
 * @requires reset, fonts
*/

body {
	/* For breathing room between content and viewport. */
	margin:10px;
}

h1 {
	/* 18px via YUI Fonts CSS foundation. */
	font-size: 138.5%;
}

h2 {
	/* 16px via YUI Fonts CSS foundation. */
	font-size: 123.1%;
}

h3 {
	/* 14px via YUI Fonts CSS foundation. */
	font-size: 108%;
}

h1,h2,h3 {
	/* Top & bottom margin based on font size. */
	margin: 1em 0;
}

h1,h2,h3,h4,h5,h6,strong,dt {
	/* Bringing boldness back to headers and the strong element. */
	font-weight: bold;
}
optgroup {
	font-weight:normal;
}

abbr,acronym {
	/* Indicating to users that more info is available. */
	border-bottom: 1px dotted #000;
	cursor: help;
}

em {
	/* Bringing italics back to the em element. */
	font-style: italic;
}

del {
	/* Striking deleted phrases. */
	text-decoration: line-through;
}

blockquote,ul,ol,dl {
	/* Giving blockquotes and lists room to breath. */
	margin: 1em;
}

ol,ul,dl {
	/* Bringing lists on to the page with breathing room. */
	margin-left: 2em;
}

ol li {
	/* Giving OL's LIs generated numbers. */
	list-style: decimal outside;
}

ul li {
	/* Giving UL's LIs generated disc markers. */
	list-style: disc outside;
}

dl dd {
	/* Giving UL's LIs generated numbers. */
	margin-left: 1em;
}

th,td {
	/* Borders and padding to make the table readable. */
	border: 1px solid #000;
	padding: .5em;
}

th {
	/* Distinguishing table headers from data cells. */
	font-weight: bold;
	text-align: center;
}

caption {
	/* Coordinated margin to match cell's padding. */
	margin-bottom: .5em;
	/* Centered so it doesn't blend in to other content. */
	text-align: center;
}

sup {
	/* to preserve line-height and selector appearance */
	vertical-align: super;
}

sub {
	/* to preserve line-height and selector appearance */
	vertical-align: sub;
}

p,
fieldset,
table,
pre {
	/* So things don't run into each other. */
	margin-bottom: 1em;
}
/* Opera requires 1px of passing to render with contemporary native chrome */
button,
input[type="checkbox"],
input[type="radio"],
input[type="reset"],
input[type="submit"] {
	padding:1px;
}
/* Margin & Padding */

div.chunk.name,
div.chunk.html,
div.chunk.containers,
div.chunk table,
div.chunk td,
div.chunk pre {
  margin: 0;
  padding: 0;
}
div.chunk *:last-child {
  margin-bottom: 0;
}
h4, h5, h6,
div.chunk,
div.comment pre {
  margin: 1em 0;
}
pre,
div.comment,
div.chunk.html {
  padding: 0.33em;
}

/* Table of content */

div#contents ul {
  margin-top: 0;
  margin-bottom: 0;
  padding: 0;
}

div#contents li {
  list-style-type: none;
}

/* Lists */

ul.chunk.containers {
  padding: 0;
  margin: 0;
  display: inline;
}
ul.chunk.containers li {
  display: inline;
  list-style-type: none;
}

/* Borders */

table.layout td.indentation {
  border: none;
}
pre,
div.chunk.html {
  border: 1px solid #000;
}
div.chunk pre {
  border: none;
}

/* Colors */

table.layout td.html {
  background-color: Beige;
}
span.Constant {
  color: Crimson;
}
span.Identifier {
  color: Teal;
}
span.PreProc {
  color: Indigo;
}
span.Special {
  color: Navy;
}
span.Statement {
  color: Maroon;
}
span.Type {
  color: Green;
}
span.Comment {
  color: Purple;
}

/* Fonts */

body {
  font-family: Sans-Serif;
}
pre {
  font-family: Consolas, Monospace;
}
div.chunk.name {
  font-weight: bold;
}
</style>
<script type="text/javascript">
/*
 * Quick-and-dirty JS for inserting a table of content inside a DIV with the id
 * "contents". The table of content is a series of nested UL and LI elements,
 * prefixed with an H1 containing the text "0 Contents". This H1 comes in
 * addition to the single static H1 expected by HTML best practices. It looks
 * "right" and should not confuse search engines etc. since they do not execute
 * Javascript code.
 */
if (document.getElementById) onload = function () {
  var contents = document.getElementById("contents");
  var lists = contents_lists();
  contents.appendChild(contents_header()); // TRICKY: Must be done after contents_lists().
  contents.appendChild(lists);
}

/*
 * Create a table of contents H1.
 */
function contents_header() {
  var h = document.createElement("h1");
  var text = document.createTextNode("Contents");
  h.appendChild(text);
  return h;
}

/*
 * Create nested UL/LI lists for the table of content.
 */
function contents_lists() {
  var container;
  var indices = [];
  foreach_h_element(function (h, level) {
    container = pop_container(container, indices, level);
    container = push_container(container, indices, level);
    var id = indices.join(".");
    container.appendChild(list_element(id, h));
    h.insertBefore(header_anchor(id), h.firstChild);
  });
  return pop_container(container, indices, 1);
}

/*
 * Apply a lambda to all H elements in the DOM. We skip the single H1 element;
 * otherwise it would just have the index "1" which would be prefixed to all
 * other headers.
 */
function foreach_h_element(lambda) {
  var elements = document.getElementsByTagName("*");
  for (var e in elements) {
    var h = elements[e];
    if (!/^h[2-9]$/i.test(h.tagName)) continue;
    var level = h.tagName.substring(1, 2) - 1;
    lambda(h, level);
  }
}

/*
 * Pop indices (and UL containers) until reaching up to a given level.
 */
function pop_container(container, indices, level) {
  while (indices.length > level) {
    container = container.parentNode;
    indices.pop();
  }
  return container;
}

/*
 * Push indices (and UL containers) until reaching doen to a given level.
 */
function push_container(container, indices, level) {
  while (indices.length < level) {
    // TRICKY: push a 0 for the very last new level, so the ++ at the end
    // will turn it into a 1.
    indices.push(indices.level < level - 1);
    var ul = document.createElement("ul");
    if (container) {
      container.appendChild(ul);
    }
    container = ul;
  }
  indices[indices.length - 1]++;
  return container;
}

/*
 * Create a LI for an H element with some id.
 */
function list_element(id, h) {
  var a = document.createElement("a");
  a.href = "#" + id;
  a.innerHTML = id + "&nbsp;" + h.innerHTML;
  var li = document.createElement("li");
  li.appendChild(a);
  return li;
}

/*
 * Create an anchor for an H element with some id.
 */
function header_anchor(id) {
  var text = document.createTextNode(id + " ");
  var a = document.createElement("a");
  a.id = id;
  a.appendChild(text);
  return a;
}
</script>
</head>
<body>
<div id="contents"></div>
<div class='rdoc doc markup'>
<h1>Codnar</h1>
<p>
Code Narrator - an inverse literate programming tool.
</p>
<h2>TL;DR</h2>

<h3>Description</h3>
<p>
Code Narrator (Codnar) is an inverse literate programming tool. It splits
the source files into “chunks” (including structured comments) and
weaves them back into a narrative that describes the overall system.
</p>
<h3>Installation</h3>
<p>
A simple <tt>gem install codnar</tt> should do the trick, assuming you have
Ruby gems set up. If you want to use the VIM-based syntax highlighting, you
also need to install <tt>gvim</tt>.
</p>
<h3>Usage</h3>
<p>
The basic usage is:
</p>
<pre>
codnar-split [options] source-file &gt; chunks-file
codnar-weave [options] chunks-files... &gt; codnar.html
</pre>
<p>
Both programs accept a <tt>-h</tt> or <tt>--help</tt> flag to print more
detailed usage messages. You can also invoke Codnar from a Rakefile:
</p>
<pre>
require &quot;codnar/rake&quot;

Codnar::Rake::SplitTask([ source-files... ], [ configurations... ])
Codnar::Rake::WeaveTask(root-file, [ configurations... ], output)
</pre>
</div>
<div class='markdown doc markup'>
<h2>The Story</h2>
<p>
This is the story of the Code Narrator (Codnar) tool. It serves a dual purpose.
It describes the Codnar tool itself, but it also serves as an example of why it
exists in the first place. To explain this more fully, we'll have to make a
little detour into the issue of system documentation.
</p>
<h3>The Documentation Problem</h3>
<p>
Documentation for any system can be grouped to two kinds. The first kind is the
reference manual. If you know of a small piece of the system, this kind of
documentation will give you the details about it. A good reference will help
you find this piece even if you only have a rough idea of what it is named. A
really good reference will also link it to related pieces. A great reference
will even give you example of how to use the related pieces in a realistic
context.
</p>
<p>
Reference manuals are invaluable, and there are plenty of tools to help you
create them. The common approach is the use of structured comments (e.g.,
<a href="http://en.wikipedia.org/wiki/Javadoc">JavaDoc</a>,
<a href="http://en.wikipedia.org/wiki/Doxygen">Doxygen</a>, and a <a href="http://en.wikipedia.org/wiki/Comparison_of_documentation_generators">host of similar
tools</a>).
However, reference manuals by themselves are insufficient.
</p>
<p>
A reference manual only works if you have some idea about how the system works
as a whole. For that, you need some sort of overview. Here there is much less
to help you produce good documentation. The common practice is to sprinkle
small tutorials inside your reference documentation (the <a href="http://msdn.microsoft.com/en-us/library">MSDN
library</a> is a good example). This
doesn't really solve the problem: how do you sufficiently explain a complex new
system, so that references and small tutorials become useful?
</p>
<p>
One possible solution to this problem, <a href="http://en.wikipedia.org/wiki/Literate_programming">literate
programming</a>, was proposed
by Knuth. In a nutshell, the idea was that the source code for the system
fulfilled a dual role. You could compile it into the executable code, as
expected. But you could also generate documentation from it.
</p>
<p>
So far this sounds a lot like structured comments, and indeed structured
comments were inspired by literate programming. The key difference between the
two approaches is that in literate programming, the generated documentation was
not a reference manual. It was a linear narrative describing the system - a
story which walked you through the system in an specific path chosen for
optimal presentation.
</p>
<p>
To achieve this, the sources contained the linear documentation, with embedded
code "chunks". The order of the chunks in the sources was determined by the
narrative, not the programming language requirements. Extracting and
re-ordering these chunks was part of the build process, so the regular compiler
could process them as usual.
</p>
<p>
This was the great strength, but also the great weakness, of literate
programming. For example, it is next to impossible to create IDEs and similar
tools for literate programming source code. The code chunks are split any which
way and spread around the source files in any order; the same source file may
contain chunks in several languages; etc. Automatically figuring out, say, the
list of members of some class would be a daunting task.
</p>
<p>
In contrast, structured comments stay out of the way of the IDE and similar
tools. The source code is still structured exactly the way the compiler wants,
which allows for easy, localized processing. The trade-off, of course, is that
structured comments produce a reference manual, not a narrative.
</p>
<p>
Today, structured comments have taken over the coding world, and literate
programming has all but been forgotten. The problem it tried to solve, however,
is still very much with us. How do we explain a new complex system?
</p>
<h3>A Different Approach</h3>
<p>
Codnar is an example of a different approach for solving this problem, "inverse
literate programming" (similar to, for example,
<a href="http://packages.python.org/antiweb/">antiweb</a>). This approach is a combination
of structured comments and literate programming. Note that this approach is
similar to, but different in key aspects from, <a href="http://ssw.jku.at/Research/Projects/RevLitProg/">reverse literate
programming</a>.
</p>
<p>
In inverse literate programming, the source files are organized just
the way the compiler, IDE, and similar tools expect them to be. Structured
comments are used to document the pieces of code, and a reference manual can be
generated from the sources as usual.
</p>
<p>
In addition, the code is split into (possibly nested) named "chunks". This is
done using specially formatted comments. It turns out this functionality is
already supported by most coding editors and IDEs, in the form of "folds" or
"regions". These allow the developer to collapse or expand such chunks at will.
</p>
<p>
At this point, inverse literate programming kicks in. The developer writes
additional documentation source files, next to the usual code source files.
These documentation source files contain a narrative that describes the system,
much in the same way that a literate programming documentation would have done,
with two important differences.
</p>
<p>
The first difference is that the documentation source files refer to and embed
the code chunks (using their names), as opposed to a literate programming
system, where the documentation source files actually contain the code chunks.
</p>
<p>
The second difference is that the documentation source files do not need to
repeat the information that is already covered in the structured comments. When
a code chunk is embedded into the documentation, it includes these comments, so
all the documentation source files need to contain is the narrative "glue" for
placing these pieces into a comprehensible context for the reader.
</p>
<p>
In this way, inverse literate programming allows generating a linear narrative
describing the system, without abandoning the existing code processing tools.
It also makes it easy to retrofit such documentation to an existing code base;
all that's needed is to mark the already-documented code chunks (or even just
treat each source code file as a single chunk), and provide the narrative glue
around them.
</p>
<h3>Maintaining the Documentation</h3>
<p>
Structutred comments have the advantage that they are easy to maintain. Every
time you change a piece of code, change its comment to match. Simiarlt,
literate programming forced one to maintain the documentation as well, since
the same source file was used for code and documentation. Inverse literate
programming does not share this advantage. The linear documentation is in a
separate file, so it isn't immediately visible to the developer who is making
the changes. Also, it is easy to just forget to include some chunks of code in
the documentation.
</p>
<p>
These issues are very similar to the issues of unit testing. Unit tests live in
a separate file from the code they test, and it is easy to forget to test some
chunks of code. One way to ensure all code is tested is to use a code coverage
tool. Similarly, inverse literate programming tools should complain about code
chunks that are left out of the final narrative.
</p>
<p>
A different approach,
<a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a>, ensures that the
tests are up-to-date and complete by writing the tests before the code. The
same approach can be used for documentation.
<a href="http://thinkingphp.org/spliceit/docs/0.1_alpha/pages/ddd_info.html">DDD</a> means
that you first document what you are about to do, and only then follow up with
the actual coding. Inverse literate programming and TDD are an excellent
practical way to achieve that.
</p>
<p>
The unit tests are code like any other code. As such, they should be documented
using structured comments. Certain unit test tools like
<a href="http://rspec.info/">RSpec</a>, <a href="http://cukes.info/">Cucumber</a> and other
<a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> tools blur the
line between the tests-as-code and the tests-as-documentation anyway, so the
amount of unit test structured documentation should be small.
</p>
<p>
Therefore, if you are writing the tests first, you have done the heavy lifting
of documenting what the new code will do. All that is left is providing a bit
of surrounding context and embedding it all in the currect location in the
narrative. Then, when you write the new code itself, it should be easy to
connect it to the narrative at the appropriate point.
</p>
<p>
In the case of Code Narrator itself, the number of (raw) lines in the code
itself is ~1800 lines, the number of test lines is ~1600 lines, while the
number of narrative documentation lines is ~800 lines. Given narrative
documentation are easier to write than system (or test) code, this indicates
maintaining a narrative is not an unreasonable burden for a well-tested project.
</p>
<h3>Code Narrator</h3>
<p>
Codnar is an inverse literate programming tool. It allows you to tell a story
about your system, which will explain it to others: developers, maintainers,
and/or users. It builds on the structured comments you would write anyway to
generate a reference manual for the system, requires minimal or no changes to
your source code files, and works perfectly well inside your favorite IDE or
editor. If you follow TDD or BDD, Codnar will make it easier for you to
complement it with DDD.
</p>
<p>
The rest of this document goes into the details of Codnar's implementation. The
core of the system is the following simple data flow: A set of source files is
split into chunks; the chunks are woven into a single HTML. This simple flow
can be enhanced by pre-processing the sources, or post-processing the HTML. In
a realistic project, all this would be managed by some build tool; either using
the command-line (for arbitrary build tools) or using the provided Ruby classes
for Rake integration.
</p>
</div>
<div class='markdown doc markup'>
<h2>Utilities</h2>
<p>
Before delving into the code, here are a few low-level generic utilities which
are used all over it. These arguably belong in a separate library.
</p>
<h3>Overall module</h3>
<p>
Executable scripts (tests, command-line applications) starts with a <code>require
'codnar'</code> line to access to the full Codnar code. This also serves as a
convenient list of all of Codnar's parts and dependencies:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rb">
<span>lib/codnar.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">andand</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">cgi</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">erb</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">fileutils</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">getoptions</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rdiscount</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rdoc/markup/to_html</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">yaml</span><span class="Special">&quot;</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/core_ext/hash</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/core_ext/markdown</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/core_ext/rdoc</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/core_ext/string</span><span class="Special">&quot;</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/version</span><span class="Special">&quot;</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/application.rb</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/configuration.rb</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/errors</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/formatter</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/globals.rb</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/grouper</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/gvim</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/merger</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/split</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/reader</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/scanner</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/splitter</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/weave</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/weaver</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/writer</span><span class="Special">&quot;</span>
</pre>
</div>
</div>
</p>
<h3>Base test case</h3>
<p>
This class is used as the base class of all test cases; it allows creating
temporary files.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-test-case-rb">
<span>test/lib/test_case.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Tests with additional utilities.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">TestCase</span> &lt; <span class="Type">Test</span>::<span class="Type">Unit</span>::<span class="Type">TestCase</span>

    <span class="PreProc">def</span> <span class="Identifier">test_nothing</span>
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Shuts test-spec about “no tests” in this base class.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    end

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a temporary file on the disk. There’s no need to clean it up since
most times we’ll be using FakeFS.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">write_tempfile</span>(path, content)
      file = <span class="Type">Tempfile</span>.open(path)
      file.write(content)
      file.close(<span class="Constant">false</span>)
      <span class="Statement">return</span> file.path
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h3>Collecting and testing for errors</h3>
<p>
Since Codnar needs to process multiple input files (in general, all the source
and most documentation files of a complex system), it is important that errors
will be reported with appropriate location information, and that processing
will continue so the full set of errors will be reported. This also makes the
code easier to test, using a special test case base class supporting error
collection:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-with-errors-rb">
<span>test/lib/with_errors.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">test_case</span><span class="Special">&quot;</span>

<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Tests that collect Errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">TestWithErrors</span> &lt; <span class="Type">TestCase</span>

    <span class="PreProc">def</span> <span class="Identifier">setup</span>
      <span class="Statement">super</span>
      <span class="Identifier">@errors</span> = <span class="Type">Errors</span>.new
    <span class="PreProc">end</span>

  <span class="PreProc">end</span>

end
</pre>
</div>
</div>
</p>
<p>
Here is a simple test that demonstrates error collection:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-collect-errors-rb">
<span>test/collect_errors.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_errors&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test collecting errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestCollectErrors &lt; TestWithErrors

    def test_one_error
      @errors &lt;&lt; &quot;Oops&quot;
      @errors.should == [ &quot;#{$0}: Oops&quot; ]
    end

    def test_path_error
      @errors.in_path(&quot;foo&quot;) do
        @errors &lt;&lt; &quot;Eeek&quot;
      end
      @errors &lt;&lt; &quot;Oops&quot;
      @errors.should == [ &quot;#{$0}: Eeek in file: foo&quot;, &quot;#{$0}: Oops&quot; ]
    end

    def test_line_error
      @errors.in_path(&quot;foo&quot;) do
        @errors.at_line(1)
        @errors &lt;&lt; &quot;Eeek&quot;
      end
      @errors &lt;&lt; &quot;Oops&quot;
      @errors.should == [ &quot;#{$0}: Eeek in file: foo at line: 1&quot;, &quot;#{$0}: Oops&quot; ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-errors-rb">
<span>lib/codnar/errors.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Collect a list of errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Errors</span> &lt; <span class="Type">Array</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create an empty errors collection.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>
      <span class="Identifier">@path</span> = <span class="Constant">nil</span>
      <span class="Identifier">@line</span> = <span class="Constant">nil</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Associate all errors collected by a block with a specific disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">in_path</span>(path, &amp;block)
      prev_path, prev_line = <span class="Identifier">@path</span>, <span class="Identifier">@line</span>
      <span class="Identifier">@path</span>, <span class="Identifier">@line</span> = path, <span class="Constant">nil</span>
      block.call
      <span class="Identifier">@path</span>, <span class="Identifier">@line</span> = prev_path, prev_line
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Set the line number for any errors collected from here on.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">at_line</span>(line)
      <span class="Identifier">@line</span> = line
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Add a single error to the collection, with automatic context annotation
(current disk file and line). Other methods (push, += etc.) do not
automatically add the context annotation.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">&lt;&lt;</span>(message)
      push(annotate_error_message(message))
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Annotate an error message with the context (current file and line).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">annotate_error_message</span>(message)
      <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: </span><span class="Special">#{</span>message<span class="Special">}</span><span class="Special">&quot;</span> <span class="Statement">unless</span> <span class="Identifier">@path</span>
      <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: </span><span class="Special">#{</span>message<span class="Special">}</span><span class="Constant"> in file: </span><span class="Special">#{</span><span class="Identifier">@path</span><span class="Special">}</span><span class="Special">&quot;</span> <span class="Statement">unless</span> <span class="Identifier">@line</span>
      <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: </span><span class="Special">#{</span>message<span class="Special">}</span><span class="Constant"> in file: </span><span class="Special">#{</span><span class="Identifier">@path</span><span class="Special">}</span><span class="Constant"> at line: </span><span class="Special">#{</span><span class="Identifier">@line</span><span class="Special">}</span><span class="Special">&quot;</span>
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h3>Tests with a fake file system</h3>
<p>
Since Codnar manipulates files (source files, chunk files, generated HTML
files), it is very useful to be able to execute file-related tests with a fake
file system. This is a more elegant alternative to creating and cleaning a
temporary physical directory for the test. For simplicity we assume all(most)
such tests also collect errors.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-lib-with-fakefs-rb">
<span>test/lib/with_fakefs.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">fakefs/safe</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">with_errors</span><span class="Special">&quot;</span>

<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Seup tests that use the FakeFS fake file system.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">TestWithFakeFS</span> &lt; <span class="Type">TestWithErrors</span>

    <span class="PreProc">def</span> <span class="Identifier">setup</span>
      <span class="Statement">super</span>
      <span class="Type">FakeFS</span>.activate!
      <span class="Type">FakeFS</span>::<span class="Type">FileSystem</span>.clear
    <span class="PreProc">end</span>

    <span class="PreProc">def</span> <span class="Identifier">teardown</span>
      <span class="Statement">super</span>
      <span class="Type">FakeFS</span>.deactivate!
    <span class="PreProc">end</span>

  <span class="PreProc">end</span>

end
</pre>
</div>
</div>
</p>
<h3>Extending the Hash class</h3>
<p>
We extend the builtin Hash class in three ways. Two will be described further
below; a third is to make all Hash objects behave as OpenStruct, that is, allow
accessing and setting values using "." notation. This allows us to avoid
defining classes for "dumb" data structures, while allowing them to be dumped
and loaded from clean YAML files. Here is a simple test of accessing missing
keys:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-missing-keys-rb">
<span>test/missing_keys.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test accessing missing keys as members.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestMissingKey &lt; TestCase

    def test_read_missing_key
      {}.missing.should == nil
    end

    def test_set_missing_key
      hash = {}
      hash.missing = &quot;value&quot;
      hash.missing.should == &quot;value&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-hash-rb">
<span>lib/codnar/core_ext/hash.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extend the core Hash class.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">class</span> <span class="Type">Hash</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Provide OpenStruct/JavaScript-like implicit .key and .key= methods.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Identifier">method_missing</span>(method, *arguments)
    method = method.to_s
    key = method.chomp(<span class="Special">&quot;</span><span class="Constant">=</span><span class="Special">&quot;</span>)
    <span class="Statement">return</span> method == key ? <span class="Constant">self</span>[key] : <span class="Constant">self</span>[key] = arguments[<span class="Constant">0</span>]
  <span class="PreProc">end</span>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#deep-clone'>Deep clone</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#deep-merge'>Deep merge</a>
</pre>
<pre class='ruby code syntax'>

end
</pre>
</div>
</div>
</p>
<h3>Extending the String class</h3>
<p>
We extend the builtin String class to manage indentation and convert chunk
names to identifiers. These functions will be decribed below when used in the
code.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-string-rb">
<span>lib/codnar/core_ext/string.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extend the core String class.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">class</span> <span class="Type">String</span>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#unindent-text'>Unindent text</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#convert-names-to-identifiers'>Convert names to identifiers</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
  <a class='nested chunk' href='#clean-markup-html'>Clean markup HTML</a>
</pre>
<pre class='ruby code syntax'>

end
</pre>
</div>
</div>
</p>
<p>
In addition, we also provide a method for cleaning up messy HTML code generated
by markup formatters:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="clean-markup-html">
<span>Clean markup HTML</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Clean HTML generated by markup formatters. Such HTML tends to have extra
empty lines for no apparent reason. Cleaning it up seems to be safe enough,
and eliminates the ugly additional vertical space in the final HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">clean_markup_html</span>
  <span class="Statement">return</span> gsub(<span class="Special">/</span><span class="Special">\n</span><span class="Special">*</span><span class="Constant">&lt;p&gt;</span><span class="Special">\n</span><span class="Special">*</span><span class="Special">/</span>, <span class="Special">&quot;</span><span class="Special">\n</span><span class="Constant">&lt;p&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>) \
        .gsub(<span class="Special">/</span><span class="Special">\n</span><span class="Special">*</span><span class="Constant">&lt;</span><span class="Special">\/</span><span class="Constant">p&gt;</span><span class="Special">\n</span><span class="Special">*</span><span class="Special">/</span>, <span class="Special">&quot;</span><span class="Special">\n</span><span class="Constant">&lt;/p&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>) \
        .gsub(<span class="Special">/</span><span class="Special">\n</span><span class="Special">*</span><span class="Constant">&lt;pre&gt;</span><span class="Special">\n</span><span class="Special">*</span><span class="Special">/</span>, <span class="Special">&quot;</span><span class="Special">\n</span><span class="Constant">&lt;pre&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>) \
        .gsub(<span class="Special">/</span><span class="Special">\n</span><span class="Special">*</span><span class="Constant">&lt;</span><span class="Special">\/</span><span class="Constant">pre&gt;</span><span class="Special">\n</span><span class="Special">*</span><span class="Special">/</span>, <span class="Special">&quot;</span><span class="Special">\n</span><span class="Constant">&lt;/pre&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>) \
        .sub(<span class="Special">/</span><span class="Special">^</span><span class="Special">\n</span><span class="Special">*</span><span class="Special">/</span>, <span class="Special">&quot;&quot;</span>)
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-string-rb">lib/codnar/core_ext/string.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h2>Splitting files into chunks</h2>
<p>
Codnar makes the reasonable assumption that each source file can be effectively
processed as a sequence of lines. This works well in practice for all "text"
source files. It fails miserably for "binary" source files, but such files
don't work that well in most generic source management tools (such as version
management systems).
</p>
<p>
A second, less obvious assumption is that it is possible to classify the source
file lines to "kinds" using a simple state machine. The classified lines are
then grouped into nested chunks based on the two special line kinds
<code>begin_chunk</code> and <code>end_chunk</code>. The other line kinds are used to control how the
lines are formatted into HTML.
</p>
<p>
The collected chunks, with the formatted HTML for each one, are then stored in
a chunks file to be used later for weaving the overall HTML narrative.
</p>
<h3>Scanning Lines</h3>
<p>
Scanning a file into classified lines is done by the <code>Scanner</code> class.
Here is a simple test that demonstrates using the scanner:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-scan-lines-rb">
<span>test/scan_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test scanning classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestScanLines &lt; TestWithFakeFS

    def test_scan_lines
      File.open(&quot;comments&quot;, &quot;w&quot;) { |file| file.write(INPUT) }
      scanner = Scanner.new(@errors, SYNTAX)
      scanner.lines(&quot;comments&quot;).should == LINES
      @errors.should == ERRORS
    end

    SYNTAX = {
      &quot;start_state&quot; =&gt; &quot;comment&quot;,
      &quot;patterns&quot; =&gt; {
        &quot;shell&quot; =&gt; {
          &quot;regexp&quot; =&gt; &quot;^(\\s*)#+\\s*(.*)$&quot;,
          &quot;groups&quot; =&gt; [ &quot;indentation&quot;, &quot;payload&quot; ],
          &quot;kind&quot; =&gt; &quot;comment&quot;,
        },
        &quot;c++&quot; =&gt; {
          &quot;regexp&quot; =&gt; /^(\s*)\/\/+\s*(.*)$/,
          &quot;groups&quot; =&gt; [ &quot;indentation&quot;, &quot;payload&quot; ],
          &quot;kind&quot; =&gt; &quot;comment&quot;,
        },
        &quot;invalid&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;(&quot; },
      },
      &quot;states&quot; =&gt; {
        &quot;comment&quot; =&gt; {
          &quot;transitions&quot; =&gt; [
            { &quot;pattern&quot; =&gt; &quot;shell&quot; },
            { &quot;pattern&quot; =&gt; &quot;c++&quot; },
            { &quot;pattern&quot; =&gt; &quot;no-such-pattern&quot;, &quot;next_state&quot; =&gt; &quot;no-such-state&quot; },
          ],
        },
      },
    }

    INPUT = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #! foo
       // bar
        baz
    EOF

    LINES = [ {
      &quot;kind&quot; =&gt; &quot;comment&quot;,
      &quot;line&quot; =&gt; &quot;# foo&quot;,
      &quot;indentation&quot; =&gt; &quot;&quot;,
      &quot;payload&quot; =&gt; &quot;foo&quot;,
      &quot;number&quot; =&gt; 1,
    }, {
      &quot;kind&quot; =&gt; &quot;comment&quot;,
      &quot;line&quot; =&gt; &quot; // bar&quot;,
      &quot;indentation&quot; =&gt; &quot; &quot;,
      &quot;payload&quot; =&gt; &quot;bar&quot;,
      &quot;number&quot; =&gt; 2,
    }, {
      &quot;kind&quot; =&gt; &quot;error&quot;,
      &quot;line&quot; =&gt; &quot;  baz&quot;,
      &quot;indentation&quot; =&gt; &quot;  &quot;,
      &quot;payload&quot; =&gt; &quot;baz&quot;,
      &quot;state&quot; =&gt; &quot;comment&quot;,
      &quot;number&quot; =&gt; 3,
    } ]

    ERRORS = [
      &quot;#{$0}: Invalid pattern: invalid regexp: ( error: premature end of regular expression: /(/&quot;,
      &quot;#{$0}: Reference to a missing pattern: no-such-pattern&quot;,
      &quot;#{$0}: Reference to a missing state: no-such-state&quot;,
      &quot;#{$0}: State: comment failed to classify line: baz in file: comments at line: 3&quot;
    ]

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-scanner-rb">
<span>lib/codnar/scanner.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan a file into classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Scanner</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Construct a scanner based on a syntax in the following structure:
</p>
<pre>
patterns:
  &lt;name&gt;:
    name: &lt;name&gt;
    kind: &lt;kind&gt;
    regexp: &lt;regexp&gt;
    groups:
    - &lt;name&gt;
states:
  &lt;name&gt;:
    name: &lt;name&gt;
    transitions:
    - pattern: &lt;pattern&gt;
      kind: &lt;kind&gt;
      next_state: &lt;state&gt;
start_state: &lt;state&gt;
</pre>
<p>
To allow for cleaner YAML files to specify the syntax, the following
shorthands are supported:
</p>
<ul><li>
<p>
A pattern or state reference can be presented by the string name of the
pattern or state.
</p>
</li><li>
<p>
The name field of a state or pattern can be ommitted. If specified, it must
be identical to the key in the states or patterns mapping.
</p>
</li><li>
<p>
The kind field of a pattern can be ommitted; by default it is assumed to be
identical to the pattern name.
</p>
</li><li>
<p>
A pattern regexp can be presented by a plain string.
</p>
</li><li>
<p>
The pattern groups field can be ommitted or contain null if it is equal to
[ “indentation”, “payload” ].
</p>
</li><li>
<p>
The kind field of a transition can be ommitted; by default it is assumed to
be identical to the pattern kind.
</p>
</li><li>
<p>
The next state of a transition can be ommitted; by default it is assumed to
be identical to the containing state.
</p>
</li><li>
<p>
The start state can be ommitted; by default it is assumed to be named
“start”.
</p>
</li></ul>
<p>
When the Scanner is constructed, a deep clone of the syntax object is
created and modified to expand all the above shorthands. Any problems
detected during this process are pushed into the errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(errors, syntax)
      <span class="Identifier">@errors</span> = errors
      <span class="Identifier">@syntax</span> = syntax.deep_clone
      <span class="Identifier">@syntax</span>.patterns.each { |<span class="Identifier">name</span>, <span class="Identifier">pattern</span>| expand_pattern_shorthands(name, pattern) }
      <span class="Identifier">@syntax</span>.states.each { |<span class="Identifier">name</span>, <span class="Identifier">state</span>| expand_state_shorthands(name, state) }
      <span class="Identifier">@syntax</span>.start_state = resolve_start_state
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan a disk file into classified lines in the following format (where the
groups contain the text extracted by the matching pattern):
</p>
<pre>
- kind: &lt;kind&gt;
  line: &lt;text&gt;
  &lt;group&gt;: &lt;text&gt;
</pre>
<p>
By convention, each classified line has a “payload” group that contains
the “main” content of the line (chunk name for begin/end/nested chunk
lines, clean comment text for comment lines, etc.). In addition, most
classified lines have an “indentation” group that contains the leading
white space (which is not included in the payload).
</p>
<p>
If at some state, a file line does not match any pattern, the scanner will
push a message into the errors. In addition it will classify the line as
follows:
</p>
<pre>
- kind: error
  state: &lt;name&gt;
  line: &lt;text&gt;
  indentation: &lt;leading white space&gt;
  payload: &lt;line text following the indentation&gt;
</pre>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">lines</span>(path)
      <span class="Identifier">@path</span> = path
      <span class="Identifier">@lines</span> = []
      <span class="Identifier">@state</span> = <span class="Identifier">@syntax</span>.start_state
      <span class="Identifier">@errors</span>.in_path(path) { scan_path }
      <span class="Statement">return</span> <span class="Identifier">@lines</span>
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-pattern-shorthands'>Scanner pattern shorthands</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-state-shorthands'>Scanner state shorthands</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-file-processing'>Scanner file processing</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#scanner-line-processing'>Scanner line processing</a>
</pre>
<pre class='ruby code syntax'>

  end

end
</pre>
</div>
</div>
</p>
<p>
As we can see, the implementation is split into two main parts. First, all
shorthands in the syntax definition are expanded (possibly generating errors).
Then, the expanded syntax is applied to a file, to generate a sequence of
classified lines.
</p>
<h4>Scanner Syntax Shorthands</h4>
<p>
The syntax is expected to be written by hand in a YAML file. We therefore
provide some convenient shorthands (listed above) to make YAML syntax files
more readable. These shorthands must be expanded to their full form before we
can apply the syntax to a file. There are two sets of shorthands we need to
expand:
</p>
<ul>
<li>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-pattern-shorthands">
<span>Scanner pattern shorthands</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand all the shorthands used in the pattern.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">expand_pattern_shorthands</span>(name, pattern)
  pattern.kind ||= fill_name(name, pattern, <span class="Special">&quot;</span><span class="Constant">Pattern</span><span class="Special">&quot;</span>)
  pattern.groups ||= [ <span class="Special">&quot;</span><span class="Constant">indentation</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">payload</span><span class="Special">&quot;</span> ]
  pattern.regexp = convert_to_regexp(name, pattern.regexp)
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a string regexp to a real Regexp.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">convert_to_regexp</span>(name, regexp)
  <span class="Statement">return</span> regexp <span class="Statement">if</span> <span class="Type">Regexp</span> == regexp
  <span class="Statement">begin</span>
    <span class="Statement">return</span> <span class="Type">Regexp</span>.new(regexp)
  <span class="Statement">rescue</span>
    <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Invalid pattern: </span><span class="Special">#{</span>name<span class="Special">}</span><span class="Constant"> regexp: </span><span class="Special">#{</span>regexp<span class="Special">}</span><span class="Constant"> error: </span><span class="Special">#{</span><span class="Identifier">$!</span><span class="Special">}</span><span class="Special">&quot;</span>
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Fill in the name field for state or pattern object.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">fill_name</span>(name, data, type)
  data_name = data.name ||= name
  <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Special">#{</span>type<span class="Special">}</span><span class="Constant">: </span><span class="Special">#{</span>name<span class="Special">}</span><span class="Constant"> has wrong name: </span><span class="Special">#{</span>data_name<span class="Special">}</span><span class="Special">&quot;</span> <span class="Statement">if</span> data_name != name
  <span class="Statement">return</span> data_name
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
</li>
<li>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-state-shorthands">
<span>Scanner state shorthands</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand all the shorthands used in the state.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">expand_state_shorthands</span>(name, state)
  fill_name(name, state, <span class="Special">&quot;</span><span class="Constant">State</span><span class="Special">&quot;</span>)
  state.transitions.each <span class="Statement">do</span> |<span class="Identifier">transition</span>|
    pattern = transition.pattern = lookup(<span class="Identifier">@syntax</span>.patterns, <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span>, transition.pattern)
    transition.kind ||= pattern.andand.kind
    transition.next_state = lookup(<span class="Identifier">@syntax</span>.states, <span class="Special">&quot;</span><span class="Constant">state</span><span class="Special">&quot;</span>, transition.next_state || state)
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a string name to an actual data reference.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">lookup</span>(mapping, type, reference)
  <span class="Statement">return</span> reference <span class="Statement">unless</span> <span class="Type">String</span> === reference
  data = mapping[reference]
  <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Reference to a missing </span><span class="Special">#{</span>type<span class="Special">}</span><span class="Constant">: </span><span class="Special">#{</span>reference<span class="Special">}</span><span class="Special">&quot;</span> <span class="Statement">unless</span> data
  <span class="Statement">return</span> data
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Resolve the start state reference.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">resolve_start_state</span>
  <span class="Statement">return</span> lookup(<span class="Identifier">@syntax</span>.states, <span class="Special">&quot;</span><span class="Constant">state</span><span class="Special">&quot;</span>, <span class="Identifier">@syntax</span>.start_state || <span class="Special">&quot;</span><span class="Constant">start</span><span class="Special">&quot;</span>) || {
    <span class="Special">&quot;</span><span class="Constant">name</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">missing_start_state</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">kind</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">error</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">transitions</span><span class="Special">&quot;</span> =&gt; []
  }
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
</li>
</ul>
<p>
The above code modifies the syntax object in place. This is safe because we are
working on a <code>deep_clone</code> of the original syntax:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="deep-clone">
<span>Deep clone</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Obtain a deep clone which shares nothing with this hash.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">deep_clone</span>
  <span class="Statement">return</span> <span class="Type">YAML</span>.load(to_yaml)
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-hash-rb">lib/codnar/core_ext/hash.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Classifying Source Lines</h4>
<p>
Scanning a file to classified lines is a simple matter of applying the current
state transitions to each line:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-file-processing">
<span>Scanner file processing</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan a disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">scan_path</span>
  <span class="Type">File</span>.open(<span class="Identifier">@path</span>, <span class="Special">&quot;</span><span class="Constant">r</span><span class="Special">&quot;</span>) <span class="Statement">do</span> |<span class="Identifier">file</span>|
    scan_file(file)
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan an opened file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">scan_file</span>(file)
  <span class="Identifier">@line_number</span> = <span class="Constant">0</span>
  file.read.each_line <span class="Statement">do</span> |<span class="Identifier">line</span>|
    <span class="Identifier">@errors</span>.at_line(<span class="Identifier">@line_number</span> += <span class="Constant">1</span>)
    scan_line(line.chomp)
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Scan the next file line.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">scan_line</span>(line)
  <span class="Identifier">@state</span>.transitions.each <span class="Statement">do</span> |<span class="Identifier">transition</span>|
    <span class="Statement">return</span> <span class="Statement">if</span> transition.pattern &amp;&amp; transition.next_state &amp;&amp; classify_matching_line(line, transition)
  <span class="Statement">end</span>
  unclassified_line(line, <span class="Identifier">@state</span>.name)
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
If a line matches a state transition, it is classified accordingly. Otherwise,
it is reported as an error:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="scanner-line-processing">
<span>Scanner line processing</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Handle a file line, only if it matches the pattern.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">classify_matching_line</span>(line, transition)
  match = (pattern = transition.pattern).regexp.match(line)
  <span class="Statement">return</span> <span class="Constant">false</span> <span class="Statement">unless</span> match
  <span class="Identifier">@lines</span> &lt;&lt; <span class="Type">Scanner</span>.extracted_groups(match, pattern.groups).update({
    <span class="Special">&quot;</span><span class="Constant">line</span><span class="Special">&quot;</span> =&gt; line,
    <span class="Special">&quot;</span><span class="Constant">kind</span><span class="Special">&quot;</span> =&gt; transition.kind,
    <span class="Special">&quot;</span><span class="Constant">number</span><span class="Special">&quot;</span> =&gt; <span class="Identifier">@line_number</span>
  })
  <span class="Identifier">@state</span> = transition.next_state
  <span class="Statement">return</span> <span class="Constant">true</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extract named groups from a match. As a special case, indentation is nil if
there is no payload.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">extracted_groups</span>(match, groups)
  extracted = {}
  groups.each_with_index <span class="Statement">do</span> |<span class="Identifier">group</span>, <span class="Identifier">index</span>|
    extracted[group] = match[index + <span class="Constant">1</span>]
  <span class="Statement">end</span>
  extracted.indentation = <span class="Constant">nil</span> <span class="Statement">if</span> match[<span class="Constant">0</span>] == <span class="Special">&quot;&quot;</span>
  <span class="Statement">return</span> extracted
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Handle a file line that couldn’t be classified.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">unclassified_line</span>(line, state_name)
  <span class="Identifier">@lines</span> &lt;&lt; {
    <span class="Special">&quot;</span><span class="Constant">line</span><span class="Special">&quot;</span> =&gt; line,
    <span class="Special">&quot;</span><span class="Constant">indentation</span><span class="Special">&quot;</span> =&gt; line.indentation,
    <span class="Special">&quot;</span><span class="Constant">payload</span><span class="Special">&quot;</span> =&gt; line.unindent,
    <span class="Special">&quot;</span><span class="Constant">kind</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">error</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">state</span><span class="Special">&quot;</span> =&gt; state_name,
    <span class="Special">&quot;</span><span class="Constant">number</span><span class="Special">&quot;</span> =&gt; <span class="Identifier">@line_number</span>
  }
  <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">State: </span><span class="Special">#{</span>state_name<span class="Special">}</span><span class="Constant"> failed to classify line: </span><span class="Special">#{</span><span class="Identifier">@lines</span>.last.payload<span class="Special">}</span><span class="Special">&quot;</span>
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-scanner-rb">lib/codnar/scanner.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h3>Merging scanned lines to chunks</h3>
<p>
Once we have the array of scanned classified lines, we need to merge them into
nested chunks. Here is a simple test that demonstrates using the merger:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-merge-lines-rb">
<span>test/merge_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_errors&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test merging classified lines to chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestMergeLines &lt; TestWithErrors

    def test_merge_no_chunks
      lines = [ { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;foo&quot;, &quot;number&quot; =&gt; 1, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;foo&quot; } ]
      chunks = Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;path&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;lines&quot; =&gt; lines
      } ]
    end

    def test_valid_merge
      chunks = Merger.chunks(@errors, &quot;path&quot;, VALID_LINES)
      @errors.should == []
      chunks.should == VALID_CHUNKS
    end

    VALID_LINES = [
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot;before top&quot;,               &quot;number&quot; =&gt; 1,  &quot;indentation&quot; =&gt; &quot;&quot;,    &quot;payload&quot; =&gt; &quot;before top&quot;          },
      { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;line&quot; =&gt; &quot; {{{ top chunk&quot;,           &quot;number&quot; =&gt; 2,  &quot;indentation&quot; =&gt; &quot; &quot;,   &quot;payload&quot; =&gt; &quot;top chunk&quot;           },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot; before intermediate&quot;,     &quot;number&quot; =&gt; 3,  &quot;indentation&quot; =&gt; &quot; &quot;,   &quot;payload&quot; =&gt; &quot;before intermediate&quot; },
      { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;line&quot; =&gt; &quot;  {{{ intermediate chunk&quot;, &quot;number&quot; =&gt; 4,  &quot;indentation&quot; =&gt; &quot;  &quot;,  &quot;payload&quot; =&gt; &quot;intermediate chunk&quot;  },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot;  before inner&quot;,           &quot;number&quot; =&gt; 5,  &quot;indentation&quot; =&gt; &quot;  &quot;,  &quot;payload&quot; =&gt; &quot;before inner&quot;        },
      { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;line&quot; =&gt; &quot;   {{{ inner chunk&quot;,       &quot;number&quot; =&gt; 6,  &quot;indentation&quot; =&gt; &quot;   &quot;, &quot;payload&quot; =&gt; &quot;inner chunk&quot;         },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot;   inner line&quot;,            &quot;number&quot; =&gt; 7,  &quot;indentation&quot; =&gt; &quot;   &quot;, &quot;payload&quot; =&gt; &quot;inner line&quot;          },
      { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;line&quot; =&gt; &quot;   }}} inner chunk&quot;,       &quot;number&quot; =&gt; 8,  &quot;indentation&quot; =&gt; &quot;   &quot;, &quot;payload&quot; =&gt; &quot;inner chunk&quot;         },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot;  after inner&quot;,            &quot;number&quot; =&gt; 9,  &quot;indentation&quot; =&gt; &quot;  &quot;                                      },
      { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;line&quot; =&gt; &quot;  }}}&quot;,                    &quot;number&quot; =&gt; 10, &quot;indentation&quot; =&gt; &quot;  &quot;,  &quot;payload&quot; =&gt; &quot;&quot;                    },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot; after intermediate&quot;,      &quot;number&quot; =&gt; 11, &quot;indentation&quot; =&gt; &quot; &quot;,   &quot;payload&quot; =&gt; &quot;after intermediate&quot;  },
      { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;line&quot; =&gt; &quot; }}} TOP CHUNK&quot;,           &quot;number&quot; =&gt; 12, &quot;indentation&quot; =&gt; &quot; &quot;,   &quot;payload&quot; =&gt; &quot;TOP CHUNK&quot;           },
      { &quot;kind&quot; =&gt; &quot;code&quot;,        &quot;line&quot; =&gt; &quot;after top&quot;,                &quot;number&quot; =&gt; 13, &quot;indentation&quot; =&gt; &quot;&quot;,    &quot;payload&quot; =&gt; &quot;after top&quot;           }
    ]

    VALID_CHUNKS = [
      { &quot;name&quot; =&gt; &quot;path&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [ &quot;top chunk&quot; ],
        &quot;lines&quot; =&gt; [
          VALID_LINES[0].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          { &quot;kind&quot; =&gt; &quot;nested_chunk&quot;, &quot;line&quot; =&gt; &quot; {{{ top chunk&quot;, &quot;number&quot; =&gt; 2, &quot;indentation&quot; =&gt; &quot; &quot;, &quot;payload&quot; =&gt; &quot;top chunk&quot; },
          VALID_LINES[12].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
        ] },
      { &quot;name&quot; =&gt; &quot;top chunk&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 2 } ],
        &quot;containers&quot; =&gt; [ &quot;path&quot; ],
        &quot;contained&quot; =&gt; [ &quot;intermediate chunk&quot; ],
        &quot;lines&quot; =&gt; [
          VALID_LINES[1].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[2].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          { &quot;kind&quot; =&gt; &quot;nested_chunk&quot;, &quot;line&quot; =&gt; &quot;  {{{ intermediate chunk&quot;, &quot;number&quot; =&gt; 4, &quot;indentation&quot; =&gt; &quot; &quot;, &quot;payload&quot; =&gt; &quot;intermediate chunk&quot; },
          VALID_LINES[10].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[11].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
        ] },
      { &quot;name&quot; =&gt; &quot;intermediate chunk&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 4 } ],
        &quot;containers&quot; =&gt; [ &quot;top chunk&quot; ],
        &quot;contained&quot; =&gt; [ &quot;inner chunk&quot; ],
        &quot;lines&quot; =&gt; [
          VALID_LINES[3].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[4].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          { &quot;kind&quot; =&gt; &quot;nested_chunk&quot;, &quot;line&quot; =&gt; &quot;   {{{ inner chunk&quot;, &quot;number&quot; =&gt; 6, &quot;indentation&quot; =&gt; &quot; &quot;, &quot;payload&quot; =&gt; &quot;inner chunk&quot; },
          VALID_LINES[8].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[9].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
        ] },
      { &quot;name&quot; =&gt; &quot;inner chunk&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;path&quot;, &quot;line&quot; =&gt; 6 } ],
        &quot;containers&quot; =&gt; [ &quot;intermediate chunk&quot; ],
        &quot;contained&quot; =&gt; [],
        &quot;lines&quot; =&gt; [
          VALID_LINES[5].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[6].merge(&quot;indentation&quot; =&gt; &quot;&quot;),
          VALID_LINES[7].merge(&quot;indentation&quot; =&gt; &quot;&quot;)
        ] }
    ]

    def test_mismatching_end_chunk_line
      lines = [
        { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;line&quot; =&gt; &quot;{{{ top chunk&quot;,     &quot;number&quot; =&gt; 1, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;top chunk&quot;     },
        { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;line&quot; =&gt; &quot;}}} not top chunk&quot;, &quot;number&quot; =&gt; 2, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;not top chunk&quot; }
      ]
      Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == [
        &quot;#{$0}: End line for chunk: not top chunk mismatches begin line for chunk: top chunk in file: path at line: 2&quot;
      ]
    end

    def test_missing_begin_chunk_name
      lines = [
        { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;line&quot; =&gt; &quot;{{{&quot;, &quot;number&quot; =&gt; 1, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;&quot; },
        { &quot;kind&quot; =&gt; &quot;end_chunk&quot;,   &quot;line&quot; =&gt; &quot;}}}&quot;, &quot;number&quot; =&gt; 2, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;&quot; }
      ]
      Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == [ &quot;#{$0}: Begin line for chunk with no name in file: path at line: 1&quot; ]
    end

    def test_missing_end_chunk_line
      lines = [ { &quot;kind&quot; =&gt; &quot;begin_chunk&quot;, &quot;line&quot; =&gt; &quot;{{{ top chunk&quot;, &quot;number&quot; =&gt; 1, &quot;indentation&quot; =&gt; &quot;&quot;, &quot;payload&quot; =&gt; &quot;top chunk&quot; } ]
      Merger.chunks(@errors, &quot;path&quot;, lines)
      @errors.should == [ &quot;#{$0}: Missing end line for chunk: top chunk in file: path at line: 1&quot; ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-merger-rb">
<span>lib/codnar/merger.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge classified lines into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Merger</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert classified lines from a disk file into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">chunks</span>(errors, path, lines)
      <span class="Statement">return</span> <span class="Type">Merger</span>.new(errors, path, lines).chunks
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return merged chunks containing the classified lines. Each chunk lines are
only indented relative to the chunk. This allows nested chunks to be
presented unindented in the final weaved HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">chunks</span>
      <span class="Identifier">@chunks</span> = [ file_chunk ]
      <span class="Identifier">@stack</span> = <span class="Identifier">@chunks</span>.dup
      <span class="Identifier">@errors</span>.in_path(<span class="Identifier">@path</span>) { merge_lines }
      <span class="Identifier">@chunks</span>.each { |<span class="Identifier">chunk</span>| <span class="Type">Merger</span>.unindent_lines(chunk.lines) }
      <span class="Statement">return</span> <span class="Identifier">@chunks</span>
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert classified lines from a disk file into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(errors, path, lines)
      <span class="Identifier">@errors</span> = errors
      <span class="Identifier">@path</span> = path
      <span class="Identifier">@lines</span> = lines
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The top-level all-the-disk-file chunk (without any classified lines)
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">file_chunk</span>
      <span class="Statement">return</span> {
        <span class="Special">&quot;</span><span class="Constant">name</span><span class="Special">&quot;</span> =&gt; <span class="Identifier">@path</span>,
        <span class="Special">&quot;</span><span class="Constant">locations</span><span class="Special">&quot;</span> =&gt; [ { <span class="Special">&quot;</span><span class="Constant">file</span><span class="Special">&quot;</span> =&gt; <span class="Identifier">@path</span>, <span class="Special">&quot;</span><span class="Constant">line</span><span class="Special">&quot;</span> =&gt; <span class="Constant">1</span> } ],
        <span class="Special">&quot;</span><span class="Constant">containers</span><span class="Special">&quot;</span> =&gt; [],
        <span class="Special">&quot;</span><span class="Constant">contained</span><span class="Special">&quot;</span> =&gt; [],
        <span class="Special">&quot;</span><span class="Constant">lines</span><span class="Special">&quot;</span> =&gt; []
      }
    <span class="PreProc">end</span>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#merging-nested-chunk-lines'>Merging nested chunk lines</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#unindenting-chunk-lines'>Unindenting chunk lines</a>
</pre>
<pre class='ruby code syntax'>

  end

end
</pre>
</div>
</div>
</p>
<h4>Merging nested chunk lines</h4>
<p>
To merge the nested chunk lines, we maintain a stack of the current chunks.
Each <code>begin_chunk</code> line pushes another chunk on the stack, and each <code>end_chunk</code>
line pops it. If any chunks are not properly terminated, they will remain in
the stack when all the lines are processed.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="merging-nested-chunk-lines">
<span>Merging nested chunk lines</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge all the classified lines into chunks
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">merge_lines</span>
  <span class="Identifier">@lines</span>.each <span class="Statement">do</span> |<span class="Identifier">line</span>|
    <span class="Identifier">@errors</span>.at_line(line.number)
    merge_line(line)
  <span class="Statement">end</span>
  end_unterminated_chunks
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
End all chunks missing a terminating end chunk classified line.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">end_unterminated_chunks</span>
  <span class="Identifier">@stack</span>.shift
  <span class="Identifier">@stack</span>.each <span class="Statement">do</span> |<span class="Identifier">chunk</span>|
    <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Missing end line for chunk: </span><span class="Special">#{</span>chunk.name<span class="Special">}</span><span class="Special">&quot;</span>
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge the next classified line.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">merge_line</span>(line)
  <span class="Statement">case</span> line.kind
  <span class="Statement">when</span> <span class="Special">&quot;</span><span class="Constant">begin_chunk</span><span class="Special">&quot;</span>
    begin_chunk_line(line)
  <span class="Statement">when</span> <span class="Special">&quot;</span><span class="Constant">end_chunk</span><span class="Special">&quot;</span>
    end_chunk_line(line)
  <span class="Statement">else</span>
    <span class="Identifier">@stack</span>.last.lines &lt;&lt; line
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a classified line that starts a new chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">begin_chunk_line</span>(line)
  chunk = contained_chunk(container = <span class="Identifier">@stack</span>.last, line)
  container.contained &lt;&lt; chunk.name
  container.lines &lt;&lt; line.merge(<span class="Special">&quot;</span><span class="Constant">kind</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">nested_chunk</span><span class="Special">&quot;</span>)
  <span class="Identifier">@chunks</span> &lt;&lt; chunk
  <span class="Identifier">@stack</span> &lt;&lt; chunk
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A chunk contained in another chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">contained_chunk</span>(container, line)
  <span class="Statement">return</span> {
    <span class="Special">&quot;</span><span class="Constant">name</span><span class="Special">&quot;</span> =&gt; new_chunk_name(line.payload),
    <span class="Special">&quot;</span><span class="Constant">locations</span><span class="Special">&quot;</span> =&gt; [ { <span class="Special">&quot;</span><span class="Constant">file</span><span class="Special">&quot;</span> =&gt; <span class="Identifier">@path</span>, <span class="Special">&quot;</span><span class="Constant">line</span><span class="Special">&quot;</span> =&gt; line.number } ],
    <span class="Special">&quot;</span><span class="Constant">containers</span><span class="Special">&quot;</span> =&gt; [ container.name ],
    <span class="Special">&quot;</span><span class="Constant">contained</span><span class="Special">&quot;</span> =&gt; [],
    <span class="Special">&quot;</span><span class="Constant">lines</span><span class="Special">&quot;</span> =&gt; [ line ]
  }
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return the name of a new chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">new_chunk_name</span>(name)
  <span class="Statement">return</span> name <span class="Statement">unless</span> name.nil? || name == <span class="Special">&quot;&quot;</span>
  <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Begin line for chunk with no name</span><span class="Special">&quot;</span>
  <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">@path</span><span class="Special">}</span><span class="Constant">/</span><span class="Special">#{</span><span class="Identifier">@chunks</span>.size<span class="Special">}</span><span class="Special">&quot;</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a classified line that ends an existing chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">end_chunk_line</span>(line)
  <span class="Statement">return</span> missing_begin_chunk_line(line) <span class="Statement">if</span> <span class="Identifier">@stack</span>.size == <span class="Constant">1</span>
  chunk = <span class="Identifier">@stack</span>.last
  <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">End line for chunk: </span><span class="Special">#{</span>line.payload<span class="Special">}</span><span class="Constant"> mismatches begin line for chunk: </span><span class="Special">#{</span>chunk.name<span class="Special">}</span><span class="Special">&quot;</span> \
    <span class="Statement">unless</span> <span class="Type">Merger</span>.matching_end_chunk_line?(chunk, line)
  chunk.lines &lt;&lt; line
  <span class="Identifier">@stack</span>.pop
<span class="Statement">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Check whether an end chunk classified line matches the begin chunk
classified line.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">matching_end_chunk_line?</span>(chunk, line)
  line_name = line.payload
  <span class="Statement">return</span> line_name.to_s == <span class="Special">&quot;&quot;</span> || line_name.to_id == chunk.name.to_id
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-merger-rb">lib/codnar/merger.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Unindenting merged chunk lines</h4>
<p>
Nested chunks are typically indented relative to their container chunks.
However, in the generated documentation, these chunks are displayed on their
own, and preserving this relative indentation would reduce their readability.
We therefore unindent all chunks as much as possible as the final step.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="unindenting-chunk-lines">
<span>Unindenting chunk lines</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Remove the common indentation from a sequence of classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">unindent_lines</span>(lines)
  indentation = <span class="Type">Merger</span>.minimal_indentation(lines)
  lines.each <span class="Statement">do</span> |<span class="Identifier">line</span>|
    line.indentation = line.indentation.andand.unindent(indentation)
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Find out the minimal indentation of all the classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">minimal_indentation</span>(lines)
  <span class="Statement">return</span> lines.map { |<span class="Identifier">line</span>| line.indentation }.compact.min
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-merger-rb">lib/codnar/merger.rb</a>
</li>
</ul>
</div>
</div>
</p>
<p>
The <code>unindent</code> method is an extension to the String class. Here is a simple
test that demonstrates unindenting text:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-unindent-text-rb">
<span>test/unindent_text.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test unindenting a multi-line text.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestUnindentText &lt; TestCase

    def test_automatic_unindent
      &quot;  a\n    b\n&quot;.unindent.should == &quot;a\n  b\n&quot;
    end

    def test_invalid_unindent
      &quot;    a\n  b\n&quot;.unindent.should == &quot;a\n  b\n&quot;
    end

    def test_integer_unindent
      &quot;  a\n    b\n&quot;.unindent(1).should == &quot; a\n   b\n&quot;
    end

    def test_string_unindent
      &quot;  a\n    b\n&quot;.unindent(&quot; &quot;).should == &quot; a\n   b\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="unindent-text">
<span>Unindent text</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Strip away common indentation from the beginning of each line in this
String. By default, detects the indentation from the first line. This can
be overriden to the exact (String) indentation to strip, or to the (Fixnum)
number of spaces the first line is further-indented from the rest of the
text.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">unindent</span>(unindentation = <span class="Constant">0</span>)
  unindentation = <span class="Special">&quot;</span><span class="Constant"> </span><span class="Special">&quot;</span> * (indentation.length - unindentation) <span class="Statement">if</span> <span class="Type">Fixnum</span> === unindentation
  <span class="Statement">return</span> gsub(<span class="Special">/</span><span class="Special">^</span><span class="Special">#{</span>unindentation<span class="Special">}</span><span class="Special">/</span>, <span class="Special">&quot;&quot;</span>)
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extract the indentation from the beginning of this String.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">indentation</span>
  <span class="Statement">return</span> sub(<span class="Special">/</span><span class="Special">[^</span><span class="Constant"> </span><span class="Special">]</span><span class="Special">.</span><span class="Special">*</span><span class="Special">$</span><span class="Special">/m</span>, <span class="Special">&quot;&quot;</span>)
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-string-rb">lib/codnar/core_ext/string.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h3>Generating chunk HTML</h3>
<p>
Now that we have each chunk's lines, we need to convert them to HTML.
</p>
<h4>Grouping lines of the same kind</h4>
<p>
Instead of formatting each line on its own, we batch the operations to work on
all lines of the same kind at once. Here is a simple test that demonstrates
using the grouper:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-group-lines-rb">
<span>test/group_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test grouping classified lines by their kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestGroupLines &lt; TestCase

    def test_group_empty_lines
      Grouper.lines_to_groups([]).should == []
    end

    def test_group_one_line
      Grouper.lines_to_groups([ { &quot;kind&quot; =&gt; &quot;code&quot; } ]).should == [ [ { &quot;kind&quot; =&gt; &quot;code&quot; } ] ]
    end

    def test_group_lines
      Grouper.lines_to_groups([
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;0&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;1&quot; },
        { &quot;kind&quot; =&gt; &quot;comment&quot;, &quot;line&quot; =&gt; &quot;2&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;3&quot; },
      ]).should == [ [
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;0&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;1&quot; },
      ], [
        { &quot;kind&quot; =&gt; &quot;comment&quot;, &quot;line&quot; =&gt; &quot;2&quot; },
      ], [
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;line&quot; =&gt; &quot;3&quot; },
      ] ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-grouper-rb">
<span>lib/codnar/grouper.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Group classified lines according to kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">module</span> <span class="Type">Grouper</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert array of classified lines to array of classified line groups with
the same line kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">lines_to_groups</span>(lines)
      groups = lines.reduce([], &amp;method(<span class="Constant">:group_next_line</span>))
      <span class="Statement">return</span> groups
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Add the next classified line to the classified line groups.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">group_next_line</span>(groups, next_line)
      last_group = groups.last
      <span class="Statement">if</span> last_group.andand.last.andand.kind == next_line.kind
        last_group.push(next_line)
      <span class="Statement">else</span>
        groups.push([ next_line ])
      <span class="Statement">end</span>
      <span class="Statement">return</span> groups
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h4>Formatting lines as HTML</h4>
<p>
Formatting is based on a configuration that specifies, for (a group of) lines
of each kind, how to convert it to HTML. Here is a simple test that
demonstrates using the formatter:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-format-lines-rb">
<span>test/format_lines.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_errors&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test converting classified lines to HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestFormatLines &lt; TestWithErrors

    def setup
      super
      Formatter.send(:public, *Formatter.protected_instance_methods)
      @formatter = Formatter.new(@errors, &quot;code&quot; =&gt; &quot;Formatter.lines_to_pre_html(lines)&quot;, &quot;fail&quot; =&gt; &quot;TestFormatLines.fail&quot;)
    end

    def test_process_html_lines
      lines_group = @formatter.process_lines_group([
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo&quot;, },
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 2, &quot;payload&quot; =&gt; &quot;bar&quot;, },
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 3, &quot;payload&quot; =&gt; &quot;baz&quot;, },
      ])
      @errors.should == []
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo\nbar\nbaz&quot; } ]
    end

    def test_process_unknown_lines
      lines_group = @formatter.process_lines_group([
        { &quot;kind&quot; =&gt; &quot;unknown-kind&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;foo&gt;&quot;, },
      ])
      @errors.should == [ &quot;#{$0}: No formatter specified for lines of kind: unknown-kind&quot; ]
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;pre class='missing formatter error'&gt;\n&amp;lt;foo&amp;gt;\n&lt;/pre&gt;&quot; } ]
    end

    def test_process_code_lines
      lines_group = @formatter.process_lines_group([
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;foo&gt;&quot;, },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;number&quot; =&gt; 2, &quot;payload&quot; =&gt; &quot;bar&quot;, },
      ])
      @errors.should == []
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;pre&gt;\n&amp;lt;foo&amp;gt;\nbar\n&lt;/pre&gt;&quot; } ]
    end

    def test_failed_formatter
      lines_group = @formatter.process_lines_group([ { &quot;kind&quot; =&gt; &quot;fail&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo&quot;, } ])
      @errors.size.should == 1
      @errors.last.should =~ /#{$0}: Formatter: TestFormatLines.fail for lines of kind: fail failed with exception:.*in `fail': Reason/
      lines_group.should == [ { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;&lt;pre class='failed formatter error'&gt;\nfoo\n&lt;/pre&gt;&quot; } ]
    end

    def test_lines_to_html
      lines_group = @formatter.lines_to_html([
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 1, &quot;payload&quot; =&gt; &quot;foo&quot; },
        { &quot;kind&quot; =&gt; &quot;code&quot;, &quot;number&quot; =&gt; 2, &quot;payload&quot; =&gt; &quot;&lt;bar&gt;&quot; },
        { &quot;kind&quot; =&gt; &quot;html&quot;, &quot;number&quot; =&gt; 3, &quot;payload&quot; =&gt; &quot;baz&quot; },
      ])
      @errors.should == []
      lines_group.should == &quot;foo\n&lt;pre&gt;\n&amp;lt;bar&amp;gt;\n&lt;/pre&gt;\nbaz&quot;
    end

    def self.fail
      raise &quot;Reason&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-formatter-rb">
<span>lib/codnar/formatter.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format chunks into HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Formatter</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Construct a Formatter based on a mapping from a classified line kind, to a
Ruby expression, that converts an array of classified lines of that kind,
into an array of lines of another kind. This expression is simply eval-ed,
and is expected to make use of a variable called “lines” that contains
an array of classified lines, as produced by a Scanner. The result of
evaluating the expressions is expected to be an array of any number of
classified lines of any kind.
</p>
<p>
Formatting repeatedly applies these formatting expressions, until the
result is an array containing a single classified line, which has the kind
“html” and whose payload field contains the unified final HTML
presentation of the original classified lines. In each processing round,
all consecutive lines of the same kind are formated together. This allows
for properly formating line kinds that use a multi-line notation such as
Markdown.
</p>
<p>
The default formatting expression for the kind “html” simply joins all
the payloads of all the classified lines into a single html, and returns a
single “line” containing this joined HTML. All other line kinds need to
have a formatting expression explicitly specified in the formatters
mapping.
</p>
<p>
If no formatting expression is specified for some classified line kind, an
error is reported and the classified lines are wrapped in a pre HTML
element with a “missing_formatter” class. Similarly, if a formatting
expression fails (raises an exception), an error is reported and the lines
are wrapped in a pre HTML element with a “failed_formatter” class.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(errors, formatters)
      <span class="Identifier">@errors</span> = errors
      <span class="Identifier">@formatters</span> = { <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.merge_html_lines(lines)</span><span class="Special">&quot;</span> }.merge(formatters)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Repeatedly process an array of classified lines of arbitrary kinds until we
obtain a single classified “line” containing a unified final HTML
presentation of the original classified lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">lines_to_html</span>(lines)
      <span class="Statement">until</span> <span class="Type">Formatter</span>.single_html_line?(lines)
        lines = <span class="Type">Grouper</span>.lines_to_groups(lines).map { |<span class="Identifier">group</span>| process_lines_group(group) }.flatten
      <span class="Statement">end</span>
      <span class="Statement">return</span> lines.last.andand.payload.to_s
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Check whether we have finally got a single HTML classified “line” for
the whole classified lines sequence.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">single_html_line?</span>(lines)
      <span class="Statement">return</span> lines.size &lt;= <span class="Constant">1</span> &amp;&amp; lines[<span class="Constant">0</span>].andand.kind == <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Perform one pass of processing toward HTML on a group of consecutive
classified lines with the same kind.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">process_lines_group</span>(lines)
      kind = lines.last.kind
      formatter = <span class="Identifier">@formatters</span>[kind] ||= missing_formatter(kind)
      <span class="Statement">begin</span>
        <span class="Statement">return</span> <span class="Statement">eval</span> formatter
      <span class="Statement">rescue</span>
        <span class="Statement">return</span> failed_formatter(lines, formatter, <span class="Identifier">$!</span>)
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return an expression for formatting classified lines of some kind that
doesn’t have such a formatting expression already specified.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">missing_formatter</span>(kind)
      <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">No formatter specified for lines of kind: </span><span class="Special">#{</span>kind<span class="Special">}</span><span class="Special">&quot;</span>
      <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Constant">Formatter.lines_to_pre_html(lines, :class =&gt; 'missing formatter error')</span><span class="Special">&quot;</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format classified lines as HTML if the original specified formatting
expression failed.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">failed_formatter</span>(lines, formatter, exception)
      <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Formatter: </span><span class="Special">#{</span>formatter<span class="Special">}</span><span class="Constant"> for lines of kind: </span><span class="Special">#{</span>lines.last.kind<span class="Special">}</span><span class="Constant"> failed with exception: </span><span class="Special">#{</span>exception<span class="Special">}</span><span class="Special">&quot;</span>
      <span class="Statement">return</span> <span class="Type">Formatter</span>.lines_to_pre_html(lines, <span class="Constant">:class</span> =&gt; <span class="Special">&quot;</span><span class="Constant">failed formatter error</span><span class="Special">&quot;</span>)
    <span class="PreProc">end</span>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#basic-formatters'>Basic formatters</a>
</pre>
<pre class='ruby code syntax'>

  end

end
</pre>
</div>
</div>
</p>
<h4>Basic formatters</h4>
<p>
The implementation contains some basic formatting functions. These are
sufficient for generic source code processing.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="basic-formatters">
<span>Basic formatters</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a group of consecutive HTML classified lines into a group with a
single HTML classified “line”. This is the default formatting
expression for HTML lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">merge_html_lines</span>(lines)
  merged_line = lines[<span class="Constant">0</span>]
  merged_line.payload = lines.map { |<span class="Identifier">line</span>| line.payload }.join(<span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span>)
  <span class="Statement">return</span> [ merged_line ]
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format classified lines into HTML using a pre element with optional
attributes. This is the default formatting expression for classified lines
of unknown kinds.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">lines_to_pre_html</span>(lines, attributes = {})
  merged_line = lines[<span class="Constant">0</span>]
  merged_line.kind = <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span>
  merged_line.payload = <span class="Special">&quot;</span><span class="Constant">&lt;pre</span><span class="Special">&quot;</span> + <span class="Type">Formatter</span>.html_attributes(attributes) + <span class="Special">&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
                      + lines.map { |<span class="Identifier">line</span>| (line.indentation || <span class="Special">&quot;&quot;</span>) + <span class="Type">CGI</span>.escapeHTML(line.payload) + <span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span> }.join \
                      + <span class="Special">&quot;</span><span class="Constant">&lt;/pre&gt;</span><span class="Special">&quot;</span>
  <span class="Statement">return</span> [ merged_line ]
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert an attribute mapping to HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">html_attributes</span>(attributes)
  <span class="Statement">return</span> attributes == {} ? <span class="Special">&quot;&quot;</span> : <span class="Special">&quot;</span><span class="Constant"> </span><span class="Special">&quot;</span> + attributes.map { |<span class="Identifier">name</span>, <span class="Identifier">value</span>| <span class="Special">&quot;</span><span class="Special">#{</span>name<span class="Special">}</span><span class="Constant">='</span><span class="Special">#{</span><span class="Type">CGI</span>.escapeHTML(value.to_s)<span class="Special">}</span><span class="Constant">'</span><span class="Special">&quot;</span> }.join(<span class="Special">&quot;</span><span class="Constant"> </span><span class="Special">&quot;</span>)
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format classified lines that indicate a nested chunk to HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">nested_chunk_lines_to_html</span>(lines)
  <span class="Statement">return</span> lines.map <span class="Statement">do</span> |<span class="Identifier">line</span>|
    (line = line.dup).kind = <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span>
    chunk_name = line.payload
    line.payload = <span class="Special">&quot;</span><span class="Constant">&lt;pre class='nested chunk'&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
                 + <span class="Special">&quot;</span><span class="Special">#{</span>line.indentation<span class="Special">}</span><span class="Constant">&lt;a class='nested chunk' href='#</span><span class="Special">#{</span>chunk_name.to_id<span class="Special">}</span><span class="Constant">'&gt;</span><span class="Special">#{</span><span class="Type">CGI</span>.escapeHTML(chunk_name)<span class="Special">}</span><span class="Constant">&lt;/a&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
                 + <span class="Special">&quot;</span><span class="Constant">&lt;/pre&gt;</span><span class="Special">&quot;</span>
    line
  <span class="Statement">end</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Indent arbitrary HTML lines to line up with the rest of the lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">unindented_lines_to_html</span>(lines)
  merged_line = lines[<span class="Constant">0</span>]
  html = lines.map { |<span class="Identifier">line</span>| line.payload + <span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span> }.join
  merged_line.payload = <span class="Constant">self</span>.indent_html(merged_line.indentation, html)
  merged_line.kind = <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span>
  <span class="Statement">return</span> [ merged_line ]
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Indent a chunk of HTML by some spaces. This uses a table, which is arguably
the wrong way to do it.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">indent_html</span>(indentation, html)
  <span class="Statement">return</span> html.chomp <span class="Statement">if</span> indentation.nil?
  <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Constant">&lt;table class='layout'&gt;</span><span class="Special">\n</span><span class="Constant">&lt;tr&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + <span class="Special">&quot;</span><span class="Constant">&lt;td class='indentation'&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + <span class="Special">&quot;</span><span class="Constant">&lt;pre&gt;</span><span class="Special">#{</span>indentation<span class="Special">}</span><span class="Constant">&lt;/pre&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + <span class="Special">&quot;</span><span class="Constant">&lt;/td&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + <span class="Special">&quot;</span><span class="Constant">&lt;td class='html'&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + html \
       + <span class="Special">&quot;</span><span class="Constant">&lt;/td&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + <span class="Special">&quot;</span><span class="Constant">&lt;/tr&gt;</span><span class="Special">\n</span><span class="Constant">&lt;/table&gt;</span><span class="Special">&quot;</span>
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Cast a sequence of classified lines into a different kind without any
processing.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">cast_lines</span>(lines, kind)
  lines = lines.dup
  lines.each { |<span class="Identifier">line</span>| line.kind = kind }
  <span class="Statement">return</span> lines
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a sequence of marked-up classified lines to (unindented) HTML
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">markup_lines_to_html</span>(lines, klass)
  merged_line = lines[<span class="Constant">0</span>]
  merged_payload = lines.map { |<span class="Identifier">line</span>| line.payload + <span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span> }.join
  merged_line.payload = <span class="Type">Formatter</span>.markup_to_html(merged_payload, klass, merged_line.kind)
  merged_line.kind = <span class="Special">&quot;</span><span class="Constant">unindented_html</span><span class="Special">&quot;</span>
  <span class="Statement">return</span> [ merged_line ]
<span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert some markup text to div-wrapped HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">markup_to_html</span>(markup, klass, kind)
  implementation = <span class="Type">String</span> === klass ? <span class="Type">Kernel</span>.const_get(klass) : klass
  <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Constant">&lt;div class='</span><span class="Special">#{</span>klass.downcase<span class="Special">}</span><span class="Constant"> </span><span class="Special">#{</span>kind<span class="Special">}</span><span class="Constant"> markup'&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> \
       + implementation.to_html(markup) \
       + <span class="Special">&quot;</span><span class="Constant">&lt;/div&gt;</span><span class="Special">&quot;</span>
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-formatter-rb">lib/codnar/formatter.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Markup formats</h4>
<p>
The <code>markup_lines_to_html</code> formatter above relies on the existence of a class
for converting comments from the specific markup format to HTML. Currently, two
such formats are supported:
</p>
<ul>
<li>
<p>
RDoc, the default markup format used in Ruby comments. Here is a simple test
that demonstrates using RDoc:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-expand-rdoc-rb">
<span>test/expand_rdoc.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test expanding RDoc text.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestExpandRDoc &lt; TestCase

    def test_emphasis_text
      RDoc.to_html(&quot;_text_&quot;).should == &quot;&lt;p&gt;\n&lt;em&gt;text&lt;/em&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_strong_text
      RDoc.to_html(&quot;*text*&quot;).should == &quot;&lt;p&gt;\n&lt;b&gt;text&lt;/b&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_indented_pre
      RDoc.to_html(&quot;base\n  indented\n    more\nback\n&quot;).should == &quot;&lt;p&gt;\nbase\n&lt;/p&gt;\n&lt;pre&gt;\nindented\n  more\n&lt;/pre&gt;\n&lt;p&gt;\nback\n&lt;/p&gt;\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-rdoc-rb">
<span>lib/codnar/core_ext/rdoc.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand RDoc text with some Codnar extensions.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">RDoc</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process a RDoc String and return the resulting HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">to_html</span>(rdoc)
    <span class="Statement">return</span> ::<span class="Type">RDoc</span>::<span class="Type">Markup</span>::<span class="Type">ToHtml</span>.new.convert(rdoc).clean_markup_html
  <span class="PreProc">end</span>

end
</pre>
</div>
</div>
</p>
</li>
<li>
<p>
Markdown, a generic markup syntax used across many systems and languages.
Here is a simple test that demonstrates using Markdown:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-expand-markdown-rb">
<span>test/expand_markdown.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test expanding Markdown text.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestExpandMarkdown &lt; TestCase

    def test_emphasis_text
      Markdown.to_html(&quot;*text*&quot;).should == &quot;&lt;p&gt;\n&lt;em&gt;text&lt;/em&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_strong_text
      Markdown.to_html(&quot;**text**&quot;).should == &quot;&lt;p&gt;\n&lt;strong&gt;text&lt;/strong&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_embed_chunk
      Markdown.to_html(&quot;[[Chunk|template]]&quot;).should == &quot;&lt;p&gt;\n&lt;embed src='chunk' type='x-codnar/template'/&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_embed_anchor
      Markdown.to_html(&quot;[[#Name]]&quot;).should == &quot;&lt;p&gt;\n&lt;a id='name'/&gt;\n&lt;/p&gt;\n&quot;
    end

    def test_embed_link
      Markdown.to_html(&quot;[Label](#Name)&quot;).should == &quot;&lt;p&gt;\n&lt;a href=\&quot;#name\&quot;&gt;Label&lt;/a&gt;\n&lt;/p&gt;\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-core-ext-markdown-rb">
<span>lib/codnar/core_ext/markdown.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand Markdown text with some Codnar extensions.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">class</span> <span class="Type">Markdown</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process a Markdown String and return the resulting HTML. In addition to the
normal Markdown syntax, processing supports the following Codnar-specific
extensions:
</p>
<ul><li>
<p>
The notation [[chunk|template]] is expanded to embedding the specified
chunk (name) using the specified template at Weave time.
</p>
</li><li>
<p>
The notation [[#name]] defines an empty anchor. The HTML anchor id is not
the specified name, but rather the identifier generated from it (in the
same way that chunk names are converted to identifiers).
</p>
</li><li>
<p>
The notation […](#name) defines a link to an anchor, which is either the
chunk with the specified name, or an empty anchor defined as above.
</p>
</li></ul>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">to_html</span>(markdown)
    markdown = <span class="Type">Markdown</span>.embed_chunks(markdown)
    markdown = <span class="Type">Markdown</span>.id_anchors(markdown)
    html = <span class="Type">RDiscount</span>.new(markdown).to_html
    html = <span class="Type">Markdown</span>.id_links(html)
    <span class="Statement">return</span> html.clean_markup_html
  <span class="PreProc">end</span>

<span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand [[chunk|template]] to HTML embed tags.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">embed_chunks</span>(markdown)
    <span class="Statement">return</span> markdown.gsub(<span class="Special">/</span><span class="Special">\[\[</span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Special">\|</span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Special">\]\]</span><span class="Special">/</span>) { <span class="Special">&quot;</span><span class="Constant">&lt;embed src='</span><span class="Special">#{</span><span class="Identifier">$1</span>.to_id<span class="Special">}</span><span class="Constant">' type='x-codnar/</span><span class="Special">#{</span><span class="Identifier">$2</span><span class="Special">}</span><span class="Constant">'/&gt;</span><span class="Special">&quot;</span> }
  <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand [[#name]] anchors to HTML anchor tags with the matching identifier.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">id_anchors</span>(markdown)
    <span class="Statement">return</span> markdown.gsub(<span class="Special">/</span><span class="Special">\[\[</span><span class="Constant">#</span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Special">\]\]</span><span class="Special">/</span>) { <span class="Special">&quot;</span><span class="Constant">&lt;a id='</span><span class="Special">#{</span><span class="Identifier">$1</span>.to_id<span class="Special">}</span><span class="Constant">'/&gt;</span><span class="Special">&quot;</span> }
  <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Expand href=‘#name’ links to the matching href=‘#id’ links.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">id_links</span>(html)
    <span class="Statement">return</span> html.gsub(<span class="Special">/</span><span class="Constant">href=</span><span class="Special">(</span><span class="Special">[</span><span class="Constant">&quot;'</span><span class="Special">]</span><span class="Special">)</span><span class="Constant">#</span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)(</span><span class="Special">[</span><span class="Constant">&quot;'</span><span class="Special">]</span><span class="Special">)</span><span class="Special">/</span>) { <span class="Special">&quot;</span><span class="Constant">href=</span><span class="Special">#{</span><span class="Identifier">$1</span><span class="Special">}</span><span class="Constant">#</span><span class="Special">#{</span><span class="Identifier">$2</span>.to_id<span class="Special">}#{</span><span class="Identifier">$3</span><span class="Special">}</span><span class="Special">&quot;</span> }
  <span class="PreProc">end</span>

end
</pre>
</div>
</div>
</p>
</li>
</ul>


<h4>Syntax highlighting using GVIM</h4>
<p>
If you have <code>gvim</code> istalled, it is possible to use it to generate syntax
highlighting. This is a <em>slow</em> operation, as <code>gvim</code> was never meant to be used
as a command-line tool. However, what it lacks in speed it compensates for in
scope; almost any language you can think of has a <code>gvim</code> syntax highlighting
definition. Here is a simple test that demonstrates using <code>gvim</code> for syntax
highlighting:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-highlight-syntax-rb">
<span>test/highlight_syntax.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test highlighting syntax using GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestHighlightSyntax &lt; TestCase

    def test_ruby_no_css
      ruby = &lt;&lt;-EOF.unindent
        def foo
          return bar = baz
        end
      EOF
      Codnar::GVim.syntax_to_html(ruby, &quot;ruby&quot;).should == &lt;&lt;-EOF.unindent
        &lt;div class='ruby code syntax' bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;
        &lt;font face=&quot;monospace&quot;&gt;
        &lt;font color=&quot;#ff40ff&quot;&gt;def&lt;/font&gt;&amp;nbsp;&lt;font color=&quot;#00ffff&quot;&gt;foo&lt;/font&gt;&lt;br /&gt;
        &amp;nbsp;&amp;nbsp;&lt;font color=&quot;#ffff00&quot;&gt;return&lt;/font&gt;&amp;nbsp;bar = baz&lt;br /&gt;
        &lt;font color=&quot;#ff40ff&quot;&gt;end&lt;/font&gt;&lt;br /&gt;
        &lt;/font&gt;
        &lt;/div&gt;
      EOF
    end

    def test_ruby_css
      ruby = &lt;&lt;-EOF.unindent
        def foo
          return bar = baz
        end
      EOF
      Codnar::GVim.syntax_to_html(ruby, &quot;ruby&quot;, [ &quot;+:let html_use_css=1&quot; ]).should == &lt;&lt;-EOF.unindent
        &lt;pre class='ruby code syntax'&gt;
        &lt;span class=&quot;PreProc&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;foo&lt;/span&gt;
          &lt;span class=&quot;Statement&quot;&gt;return&lt;/span&gt; bar = baz
        &lt;span class=&quot;PreProc&quot;&gt;end&lt;/span&gt;
        &lt;/pre&gt;
      EOF
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-gvim-rb">
<span>lib/codnar/gvim.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">tempfile</span><span class="Special">&quot;</span>

<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Syntax highlight using GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">GVim</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Highlight syntax of text using GVim. This uses the GVim standard CSS
classes to mark keywords, identifiers, and so on. See the GVim
documentation for details. The commands array allows configuring the way
that GVim will format the output. For example:
</p>
<ul><li>
<p>
The command “+:colorscheme &lt;name&gt;” will override the default
color scheme used.
</p>
</li><li>
<p>
The command “+:let html_use_css=1” will just annotate each HTML tag
with a CSS class, instead of embedding some specific style directly into
the tag. In this case the colorscheme and background are ignored; you will
need to provide your own CSS stylesheet as part of the final woven document
to style the marked-up words.
</p>
</li></ul>
<p>
Additional commands may be useful; GVim provides a full scripting
environment so there is no theoretical limit to what can be done here.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">syntax_to_html</span>(text, syntax, commands = [])
      file = write_temporary_file(text)
      run_gvim(file, syntax, commands)
      html = read_html_file(file)
      delete_temporary_files(file)
      <span class="Statement">return</span> clean_html(html, syntax)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert a sequence of classified code lines to HTML using GVim syntax
highlighting. The commands array allows configuring the way that GVim will
format the output (see the `syntax_to_html` method for details).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">lines_to_html</span>(lines, syntax, commands = [])
      merged_line = lines[<span class="Constant">0</span>]
      merged_line.kind = <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span>
      payload = lines.map { |<span class="Identifier">line</span>| (line.indentation || <span class="Special">&quot;&quot;</span>) + line.payload + <span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span> }.join
      merged_line.payload = <span class="Type">GVim</span>.syntax_to_html(payload, syntax, commands).chomp
      <span class="Statement">return</span> [ merged_line ]
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write the text to highlight the syntax of into a temporary file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">write_temporary_file</span>(text)
      file = <span class="Type">Tempfile</span>.open(<span class="Special">&quot;</span><span class="Constant">codnar-</span><span class="Special">&quot;</span>)
      file.write(text)
      file.close(<span class="Constant">false</span>)
      <span class="Statement">return</span> file
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run GVim to highlight the syntax of a temporary file. This uses the
little-known ability of GVim to emit the syntax highlighting as HTML using
only command-line arguments.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">run_gvim</span>(file, syntax, commands)
      path = file.path
      <span class="Identifier">ENV</span>[<span class="Special">&quot;</span><span class="Constant">DISPLAY</span><span class="Special">&quot;</span>] = <span class="Special">&quot;</span><span class="Constant">none</span><span class="Special">&quot;</span> <span class="Comment"># Otherwise the X11 server *does* affect the result.</span>
      command = [
        <span class="Special">&quot;</span><span class="Constant">gvim</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">-f</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">-X</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">-u</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">none</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">-U</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">none</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:let html_ignore_folding=1</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:let use_xhtml=1</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:let html_use_css=0</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:syn on</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:set syntax=</span><span class="Special">#{</span>syntax<span class="Special">}</span><span class="Special">&quot;</span>,
        commands,
        <span class="Special">&quot;</span><span class="Constant">+run! syntax/2html.vim</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:f </span><span class="Special">#{</span>path<span class="Special">}</span><span class="Special">&quot;</span>,
        <span class="Special">&quot;</span><span class="Constant">+:wq</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">+:q</span><span class="Special">&quot;</span>,
        path
      ]
      system(<span class="Special">&quot;</span><span class="Constant">echo '</span><span class="Special">\n</span><span class="Constant">' | '</span><span class="Special">#{</span>command.flatten.join(<span class="Special">&quot;</span><span class="Constant">' '</span><span class="Special">&quot;</span>)<span class="Special">}</span><span class="Constant">' &gt; /dev/null 2&gt;&amp;1</span><span class="Special">&quot;</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Read the HTML with the syntax highlighting written out by GVim.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">read_html_file</span>(file)
      <span class="Statement">return</span> <span class="Type">File</span>.read(file.path + <span class="Special">&quot;</span><span class="Constant">.xhtml</span><span class="Special">&quot;</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Delete both the text and HTML temporary files.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">delete_temporary_files</span>(file)
      <span class="Type">File</span>.delete(file.path + <span class="Special">&quot;</span><span class="Constant">.xhtml</span><span class="Special">&quot;</span>)
      file.delete
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Extract the clean highlighted syntax HTML from GVim’s HTML output.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">clean_html</span>(html, syntax)
      <span class="Statement">if</span> html =~ <span class="Special">/</span><span class="Constant">&lt;pre&gt;</span><span class="Special">/</span>
        html.sub!(<span class="Special">/</span><span class="Special">.</span><span class="Special">*?</span><span class="Constant">&lt;pre&gt;</span><span class="Special">/m</span>, <span class="Special">&quot;</span><span class="Constant">&lt;pre class='</span><span class="Special">#{</span>syntax<span class="Special">}</span><span class="Constant"> code syntax'&gt;</span><span class="Special">&quot;</span>)
        html.sub!(<span class="Special">&quot;</span><span class="Constant">&lt;/body&gt;</span><span class="Special">\n</span><span class="Constant">&lt;/html&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>, <span class="Special">&quot;&quot;</span>)
      <span class="Statement">else</span>
        html.sub!(<span class="Special">/</span><span class="Special">.</span><span class="Special">*?</span><span class="Constant">&lt;body</span><span class="Special">/m</span>, <span class="Special">&quot;</span><span class="Constant">&lt;div class='</span><span class="Special">#{</span>syntax<span class="Special">}</span><span class="Constant"> code syntax'</span><span class="Special">&quot;</span>)
        html.sub!(<span class="Special">&quot;</span><span class="Constant">&lt;/body&gt;</span><span class="Special">\n</span><span class="Constant">&lt;/html&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">&lt;/div&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>)
      <span class="Statement">end</span>
      <span class="Statement">return</span> html
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h3>Putting it all together</h3>
<p>
Now that we have all the separate pieces of functionality for splitting source
files into HTML chunks, we need to combine them to a single convenient service.
</p>
<h4>Splitting code files</h4>
<p>
Here is a simple test that demonstrates using the splitter for source code
files:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-code-rb">
<span>test/split_code.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_errors&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test splitting code files.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestSplitCode &lt; TestWithErrors

    def test_split_ruby
      splitter = Splitter.new(@errors, RUBY_CONFIGURATION)
      path = write_tempfile(&quot;ruby.rb&quot;, RUBY_FILE)
      chunks = splitter.chunks(path)
      @errors.should == []
      chunks.should == ruby_chunks(path)
    end

  protected

    def ruby_chunks(path)
      RUBY_CHUNKS[0].name = path
      RUBY_CHUNKS[1].containers[0] = path
      RUBY_CHUNKS.each { |chunk| chunk.locations[0].file = path }
      return RUBY_CHUNKS
    end

    RUBY_FILE = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #! This is *rdoc*.
        #! {{{ assignment
        local = $global
          indented
        #! }}}
    EOF

    RUBY_CONFIGURATION = {
      &quot;formatters&quot; =&gt; {
        &quot;code&quot; =&gt; &quot;Formatter.cast_lines(lines, 'ruby')&quot;,
        &quot;comment&quot; =&gt; &quot;Formatter.cast_lines(lines, 'rdoc')&quot;,
        &quot;ruby&quot; =&gt; &quot;GVim.lines_to_html(lines, 'ruby')&quot;,
        &quot;rdoc&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'RDoc')&quot;,
        &quot;begin_chunk&quot; =&gt; &quot;[]&quot;,
        &quot;end_chunk&quot; =&gt; &quot;[]&quot;,
        &quot;nested_chunk&quot; =&gt; &quot;Formatter.nested_chunk_lines_to_html(lines)&quot;,
        &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
      },
      &quot;syntax&quot; =&gt; {
        &quot;start_state&quot; =&gt; &quot;ruby&quot;,
        &quot;patterns&quot; =&gt; {
          &quot;comment&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)#\\s*(.*)$&quot; },
          &quot;code&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)(.*)$&quot; },
          &quot;begin_chunk&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)\\W*\\{\\{\\{\\s*(.*?)\\s*$&quot; },
          &quot;end_chunk&quot; =&gt; { &quot;regexp&quot; =&gt; &quot;^(\\s*)\\W*\\}\\}\\}\\s*(.*?)\\s*$&quot; },
        },
        &quot;states&quot; =&gt; {
          &quot;ruby&quot; =&gt; {
            &quot;transitions&quot; =&gt; [
              { &quot;pattern&quot; =&gt; &quot;begin_chunk&quot; },
              { &quot;pattern&quot; =&gt; &quot;end_chunk&quot; },
              { &quot;pattern&quot; =&gt; &quot;comment&quot; },
              { &quot;pattern&quot; =&gt; &quot;code&quot; },
            ],
          },
        },
      },
    }

    RUBY_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;PATH&quot;,
      &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;PATH&quot;, &quot;line&quot; =&gt; 1 ],
      &quot;containers&quot; =&gt; [],
      &quot;contained&quot; =&gt; [ &quot;assignment&quot; ],
      &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent.chomp,
        &lt;table class='layout'&gt;
        &lt;tr&gt;
        &lt;td class='indentation'&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class='html'&gt;
        &lt;div class='rdoc rdoc markup'&gt;
        &lt;p&gt;
        This is &lt;b&gt;rdoc&lt;/b&gt;.
        &lt;/p&gt;
        &lt;/div&gt;
        &lt;/td&gt;
        &lt;/tr&gt;
        &lt;/table&gt;
        &lt;pre class='nested chunk'&gt;
          &lt;a class='nested chunk' href='#assignment'&gt;assignment&lt;/a&gt;
        &lt;/pre&gt;
      EOF
    }, {
      &quot;name&quot; =&gt; &quot;assignment&quot;,
      &quot;containers&quot; =&gt; [ &quot;PATH&quot; ],
      &quot;contained&quot; =&gt; [],
      &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;PATH&quot;, &quot;line&quot; =&gt; 2 ],
      &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent.chomp,
        &lt;div class='ruby code syntax' bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;
        &lt;font face=&quot;monospace&quot;&gt;
        local =&amp;nbsp;&lt;font color=&quot;#00ffff&quot;&gt;$global&lt;/font&gt;&lt;br /&gt;
        &amp;nbsp;&amp;nbsp;indented&lt;br /&gt;
        &lt;/font&gt;
        &lt;/div&gt;
      EOF
    } ]

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-splitter-rb">
<span>lib/codnar/splitter.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split disk files into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Splitter</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Construct a splitter based on a configuration in the following structure:
</p>
<pre>
syntax: &lt;syntax&gt;
formatters:
  &lt;kind&gt;: &lt;expression&gt;
</pre>
<p>
Where the syntax is passed as-is to (and expanded in-place by) a Scanner,
and the formatters are passed as-is to a Formatter to convert the chunk’s
classified lines into HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(errors, configuration)
      <span class="Identifier">@errors</span> = errors
      <span class="Identifier">@configuration</span> = configuration
      <span class="Identifier">@scanner</span> = <span class="Type">Scanner</span>.new(errors, configuration.syntax)
      <span class="Identifier">@formatter</span> = <span class="Type">Formatter</span>.new(errors, configuration.formatters)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split a disk file into HTML chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">chunks</span>(path)
      lines = <span class="Identifier">@scanner</span>.lines(path)
      chunks = <span class="Type">Merger</span>.chunks(<span class="Identifier">@errors</span>, path, lines)
      chunks.each { |<span class="Identifier">chunk</span>| chunk.html = <span class="Identifier">@formatter</span>.lines_to_html(chunk.delete(<span class="Special">&quot;</span><span class="Constant">lines</span><span class="Special">&quot;</span>)) }
      <span class="Statement">return</span> chunks
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h4>Splitting documentation files</h4>
<p>
The narrative documentation is expected to reside in one or more files, which
are also "split" to a single chunk each. Having both documentation and code
exist as chunks allows for uniform treatment of both when weaving, as well as
allowing for pre-processing the documentation files, if necessary. For example,
Codnar currently supports for documentation the same two markup formats that
are also supported for code comments. Here is a simple test that demonstrates
"splitting" documentation (using the same implementation as above):
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-documentation-rb">
<span>test/split_documentation.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test “splitting” documentation files.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestSplitDocumentation &lt; TestWithFakeFS

    def test_split_raw
      File.open(&quot;raw.html&quot;, &quot;w&quot;) { |file| file.write(&quot;&lt;foo&gt;\nbar\n&lt;/foo&gt;\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;html&quot;))
      chunks = splitter.chunks(&quot;raw.html&quot;)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;raw.html&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;raw.html&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;foo&gt;\nbar\n&lt;/foo&gt;&quot;
      } ]
    end

    def test_split_markdown
      File.open(&quot;markdown.md&quot;, &quot;w&quot;) { |file| file.write(&quot;*foo*\nbar\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;markdown&quot;))
      chunks = splitter.chunks(&quot;markdown.md&quot;)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;markdown.md&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;markdown.md&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;div class='markdown markdown markup'&gt;\n&lt;p&gt;\n&lt;em&gt;foo&lt;/em&gt;\nbar\n&lt;/p&gt;\n&lt;/div&gt;&quot;
      } ]
    end

    def test_split_rdoc
      File.open(&quot;rdoc.rdoc&quot;, &quot;w&quot;) { |file| file.write(&quot;*foo*\nbar\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;rdoc&quot;))
      chunks = splitter.chunks(&quot;rdoc.rdoc&quot;)
      @errors.should == []
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;rdoc.rdoc&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;rdoc.rdoc&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;div class='rdoc rdoc markup'&gt;\n&lt;p&gt;\n&lt;b&gt;foo&lt;/b&gt; bar\n&lt;/p&gt;\n&lt;/div&gt;&quot;
      } ]
    end

    def test_split_unknown_kind
      File.open(&quot;unknown.kind&quot;, &quot;w&quot;) { |file| file.write(&quot;foo\nbar\n&quot;) }
      splitter = Splitter.new(@errors, configuration(&quot;unknown-kind&quot;))
      chunks = splitter.chunks(&quot;unknown.kind&quot;)
      @errors.should == [ &quot;#{$0}: No formatter specified for lines of kind: unknown-kind&quot; ]
      chunks.should == [ {
        &quot;name&quot; =&gt; &quot;unknown.kind&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;unknown.kind&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;pre class='missing formatter error'&gt;\nfoo\nbar\n&lt;/pre&gt;&quot;
      } ]
    end

  protected

    def configuration(kind)
      return {
        &quot;formatters&quot; =&gt; {
          &quot;markdown&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'Markdown')&quot;,
          &quot;unindented_html&quot; =&gt; &quot;Formatter.unindented_lines_to_html(lines)&quot;,
          &quot;rdoc&quot; =&gt; &quot;Formatter.markup_lines_to_html(lines, 'RDoc')&quot;,
        },
        &quot;syntax&quot; =&gt; {
          &quot;start_state&quot; =&gt; kind,
          &quot;patterns&quot; =&gt; {
            kind =&gt; { &quot;regexp&quot; =&gt; &quot;^(.*)$&quot;, &quot;groups&quot; =&gt; [ &quot;payload&quot; ] },
          },
          &quot;states&quot; =&gt; {
            kind =&gt; {
              &quot;transitions&quot; =&gt; [
                { &quot;pattern&quot; =&gt; kind }
              ]
            }
          }
        }
      }
    end

  end

end
</pre>
</div>
</div>
</p>
<h3>Built-in configurations</h3>
<p>
The splitting mechanism defined above is pretty generic. To apply it to a
specific system requires providing the appropriate configuration. The system
provides a few specific built-in configurations which may be useful "out of the
box". Currently, these built-in configurations are focused on documenting Ruby
code and GVim.
</p>
<p>
If one is willing to give up altogether on syntax highlighting and comment
formatting, the system would be applicable as-is to any programming language.
Properly highlighting almost any known programming language syntax would be a
simple matter of passing the correct syntax parameter to GVIM.
</p>
<p>
Properly formatting comments in additional mark-up formats would be trickier.
First, a proper pattern needs to be established for extracting the comments
(<code>/*</code>, <code>//</code>, <code>--</code>, etc.). Them, the results need to be converted to HTML. One
way would be to pass them through GVim syntax highlighting with an appropriate
format (e.g, <code>syntax=doxygen</code>). Another would be to invoke some Ruby library;
finally, one could invoke some external tool to do the job. The latter two
options would require providing additional glue Ruby code, similar to the GVim
class above.
</p>
<p>
At any rate, here are the built-in configurations:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-configuration-rb">
<span>lib/codnar/configuration.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A module for all the “built-in” configurations. The names of these
configurations can be passed to the –require option of any Codnar
Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">module</span> <span class="Type">Configuration</span>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#built-in-documentation-splitting-configurations'>Built-in documentation &quot;splitting&quot; configurations</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#built-in-chunk-splitting-configurations'>Built-in chunk splitting configurations</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#built-in-comment-splitting-configurations'>Built-in comment splitting configurations</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#built-in-syntax-highlighting-configurations'>Built-in syntax highlighting configurations</a>
</pre>
<pre class='ruby code syntax'>

</pre>
<pre class='nested chunk'>
    <a class='nested chunk' href='#built-in-weaving-templates'>Built-in weaving templates</a>
</pre>
<pre class='ruby code syntax'>

  end

end
</pre>
</div>
</div>
</p>
<p>
(Built-in weaving templates are described later.)
</p>
<h4>Documentation "Splitting"</h4>
<p>
These are pretty simple configurations, applicable to files containing a piece
of the narrative in some supported format.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="built-in-documentation-splitting-configurations">
<span>Built-in documentation &quot;splitting&quot; configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file. All lines are assumed to have the same
kind “doc” and no indentation is collected. Unless overriden by
additional configuration(s), the lines are assumed to contain formatted
HTML, and are passed as-is to the output.
</p>
<p>
This is the default configuration as it performs the minimal amount of
processing on the input. It isn’t the most useful configuration.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">SPLIT_HTML_DOCUMENTATION</span> = {
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.cast_lines(lines, 'html')</span><span class="Special">&quot;</span>,
  },
  <span class="Special">&quot;</span><span class="Constant">syntax</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">patterns</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">regexp</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">^(.*)$</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">groups</span><span class="Special">&quot;</span> =&gt; [ <span class="Special">&quot;</span><span class="Constant">payload</span><span class="Special">&quot;</span> ] },
    },
    <span class="Special">&quot;</span><span class="Constant">states</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">start</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">transitions</span><span class="Special">&quot;</span> =&gt; [ { <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> } ] },
    },
  },
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file containing arbitrary text, which is
preserved by escaping it and wrapping it in an HTML pre element.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">SPLIT_PRE_DOCUMENTATION</span> = <span class="Type">SPLIT_HTML_DOCUMENTATION</span>.deep_merge(
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.lines_to_pre_html(lines, :class =&gt; :doc)</span><span class="Special">&quot;</span>,
  }
)

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file containing pure RDoc documentation.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">SPLIT_RDOC_DOCUMENTATION</span> = <span class="Type">SPLIT_HTML_DOCUMENTATION</span>.deep_merge(
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.markup_lines_to_html(lines, 'RDoc')</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">unindented_html</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.unindented_lines_to_html(lines)</span><span class="Special">&quot;</span>,
  }
)

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
“Split” a documentation file containing pure Markdown documentation.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">SPLIT_MARKDOWN_DOCUMENTATION</span> = <span class="Type">SPLIT_HTML_DOCUMENTATION</span>.deep_merge(
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.markup_lines_to_html(lines, 'Markdown')</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">unindented_html</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.unindented_lines_to_html(lines)</span><span class="Special">&quot;</span>,
  }
)

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Chunk Splitting</h4>
<p>
There are many ways to denote code regions (and, therefore, chunks). The
following covers GVim's default scheme; there is also VisualStudio <code>#region</code>
notation, as well as many others.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="built-in-chunk-splitting-configurations">
<span>Built-in chunk splitting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Group lines into chunks using VIM-style “{{{”/“}}}” region
designations. Assumes other configurations handle the actual content lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">CHUNK_BY_VIM_REGIONS</span> = {
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">begin_chunk</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">[]</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">end_chunk</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">[]</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">nested_chunk</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.nested_chunk_lines_to_html(lines)</span><span class="Special">&quot;</span>,
  },
  <span class="Special">&quot;</span><span class="Constant">syntax</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">patterns</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">begin_chunk</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">regexp</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">^(</span><span class="Special">\\</span><span class="Constant">s*)</span><span class="Special">\\</span><span class="Constant">W*</span><span class="Special">\\</span><span class="Constant">{</span><span class="Special">\\</span><span class="Constant">{</span><span class="Special">\\</span><span class="Constant">{</span><span class="Special">\\</span><span class="Constant">s*(.*?)</span><span class="Special">\\</span><span class="Constant">s*$</span><span class="Special">&quot;</span> },
      <span class="Special">&quot;</span><span class="Constant">end_chunk</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">regexp</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">^(</span><span class="Special">\\</span><span class="Constant">s*)</span><span class="Special">\\</span><span class="Constant">W*</span><span class="Special">\\</span><span class="Constant">}</span><span class="Special">\\</span><span class="Constant">}</span><span class="Special">\\</span><span class="Constant">}</span><span class="Special">\\</span><span class="Constant">s*(.*?)</span><span class="Special">\\</span><span class="Constant">s*$</span><span class="Special">&quot;</span> },
    },
    <span class="Special">&quot;</span><span class="Constant">states</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">start</span><span class="Special">&quot;</span> =&gt; {
        <span class="Special">&quot;</span><span class="Constant">transitions</span><span class="Special">&quot;</span> =&gt; [
          { <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">begin_chunk</span><span class="Special">&quot;</span> },
          { <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">end_chunk</span><span class="Special">&quot;</span> },
          [],
        ],
      },
    },
  },
}

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Comment splitting</h4>
<p>
The following only covers shell-like <code>#</code>  comments, and a few markup formats.
There are too many other alternatives to list here.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="built-in-comment-splitting-configurations">
<span>Built-in comment splitting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Classify lines to two kinds, “code” and (#-style) “comment”. It
accepts a restricted format: each comment is expected to start with exactly
one “#” and the following space, if any, is stripped from the payload.
As a convenience, “#!” is not taken to start a comment. This both
protects the 1st line of scripts, and also any other line you wish to avoid
being treated as a comment.
</p>
<p>
This configuration is typically complemented by an additional one
specifying how to format the code and the (stripped!) comments; by default
both are just displayed as-is using an HTML pre element, which isn’t very
useful.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">CLASSIFY_SHELL_COMMENTS</span> = {
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">code</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.lines_to_pre_html(lines, :class =&gt; :code)</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">comment</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.lines_to_pre_html(lines, :class =&gt; :comment)</span><span class="Special">&quot;</span>,
  },
  <span class="Special">&quot;</span><span class="Constant">syntax</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">patterns</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">comment_as_code</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">regexp</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">^(</span><span class="Special">\\</span><span class="Constant">s*)(#!.*)$</span><span class="Special">&quot;</span> },
      <span class="Special">&quot;</span><span class="Constant">comment</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">regexp</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">^(</span><span class="Special">\\</span><span class="Constant">s*)#</span><span class="Special">\\</span><span class="Constant">s?(.*)$</span><span class="Special">&quot;</span> },
      <span class="Special">&quot;</span><span class="Constant">code</span><span class="Special">&quot;</span> =&gt; { <span class="Special">&quot;</span><span class="Constant">regexp</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">^(</span><span class="Special">\\</span><span class="Constant">s*)(.*)$</span><span class="Special">&quot;</span> },
    },
    <span class="Special">&quot;</span><span class="Constant">states</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">start</span><span class="Special">&quot;</span> =&gt; {
        <span class="Special">&quot;</span><span class="Constant">transitions</span><span class="Special">&quot;</span> =&gt; [
          { <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">comment_as_code</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">kind</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">code</span><span class="Special">&quot;</span> },
          { <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">comment</span><span class="Special">&quot;</span> },
          { <span class="Special">&quot;</span><span class="Constant">pattern</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">code</span><span class="Special">&quot;</span> },
        ],
      },
    },
  },
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format comments that use the RDoc notation. Is used to complement a
configuration that classifies some lines as “comment”. Assumes some
previous configuration already classified the comment lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">FORMAT_RDOC_COMMENTS</span> = {
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">comment</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.markup_lines_to_html(lines, 'RDoc')</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">unindented_html</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.unindented_lines_to_html(lines)</span><span class="Special">&quot;</span>,
  },
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format comments that use the Markdown notation. Is used to complement a
configuration that classifies some lines as “comment”. Assumes some
previous configuration already classifies the comment lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">FORMAT_MARKDOWN_COMMENTS</span> = {
  <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
    <span class="Special">&quot;</span><span class="Constant">comment</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.markup_lines_to_html(lines, 'Markdown')</span><span class="Special">&quot;</span>,
    <span class="Special">&quot;</span><span class="Constant">unindented_html</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">Formatter.unindented_lines_to_html(lines)</span><span class="Special">&quot;</span>,
  },
}

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Syntax highlighting</h4>
<p>
Supporting a specific programming language (other than dealing with comments)
is very easy using GVim for syntax highlighting, as demonstrated here:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="built-in-syntax-highlighting-configurations">
<span>Built-in syntax highlighting configurations</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format code using GVim’s Ruby syntax highlighting. Assumes some previous
configuration already classifies the code lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">HIGHLIGHT_CODE_SYNTAX</span> = <span class="Statement">lambda</span> <span class="Statement">do</span> |<span class="Identifier">syntax</span>|
  {
    <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">code</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">GVim.lines_to_html(lines, '</span><span class="Special">#{</span>syntax<span class="Special">}</span><span class="Constant">')</span><span class="Special">&quot;</span>,
    },
  }
<span class="Statement">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format code using GVim’s Ruby syntax highlighting, using CSS classes
instead of explicit font and color styles. Assumes some previous
configuration already classifies the code lines.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">CSS_CODE_SYNTAX</span> = <span class="Statement">lambda</span> <span class="Statement">do</span> |<span class="Identifier">syntax</span>|
  {
    <span class="Special">&quot;</span><span class="Constant">formatters</span><span class="Special">&quot;</span> =&gt; {
      <span class="Special">&quot;</span><span class="Constant">code</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">GVim.lines_to_html(lines, '</span><span class="Special">#{</span>syntax<span class="Special">}</span><span class="Constant">', [ '+:let html_use_css=1' ])</span><span class="Special">&quot;</span>,
    },
  }
<span class="Statement">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>Combining configurations</h4>
<p>
The above configurations can be used in combination with each other, as
demonstrated by the following tests:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-split-configurations-rb">
<span>test/split_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_errors&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test the built-in split configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestSplitConfigurations &lt; TestWithErrors

    def test_split_html_documentation
      check_split_file(Configuration::SPLIT_HTML_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; RUBY_FILE.chomp
        } ]
      end
    end

    def test_split_pre_documentation
      check_split_file(Configuration::SPLIT_PRE_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; &quot;&lt;pre class='doc'&gt;\n&quot; + RUBY_FILE + &quot;&lt;/pre&gt;&quot;
        } ]
      end
    end

    RDOC_HTML = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;).chomp
      &lt;div class='rdoc doc markup'&gt;
      &lt;p&gt;
      #! This is &lt;b&gt;special&lt;/b&gt;.
      &lt;/p&gt;
      &lt;pre&gt;
      #! {{{ assignment
      local = $global
        indented
      #! }}}
      &lt;/pre&gt;
      &lt;/div&gt;
    EOF

    def test_split_rdoc_documentation
      check_split_file(Configuration::SPLIT_RDOC_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; RDOC_HTML,
        } ]
      end
    end

    MARKDOWN_HTML = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;).chomp
      &lt;div class='markdown doc markup'&gt;
      &lt;h1&gt;This is &lt;em&gt;special&lt;/em&gt;.&lt;/h1&gt;
      &lt;p&gt;
        #! {{{ assignment
        local = $global
      &lt;/p&gt;
      &lt;pre&gt;
      &lt;code&gt;indented
      &lt;/code&gt;
      &lt;/pre&gt;
      &lt;p&gt;
        #! }}}
      &lt;/p&gt;
      &lt;/div&gt;
    EOF

    def test_split_markdown_documentation
      check_split_file(Configuration::SPLIT_MARKDOWN_DOCUMENTATION) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; MARKDOWN_HTML,
        } ]
      end
    end

    SHELL_COMMENTS_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='comment'&gt;
      This is *special*.
        {{{ assignment
      &lt;/pre&gt;
      &lt;pre class='code'&gt;
        local = $global
          indented
      &lt;/pre&gt;
      &lt;pre class='comment'&gt;
        }}}
      &lt;/pre&gt;
    EOF

    def test_classify_shell_comments
      check_split_file(Configuration::CLASSIFY_SHELL_COMMENTS) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; SHELL_COMMENTS_HTML,
        } ]
      end
    end

    INDENTATION_TABLE_PREFIX = &lt;&lt;-EOF.unindent.chomp
      &lt;table class='layout'&gt;
      &lt;tr&gt;
      &lt;td class='indentation'&gt;
      &lt;pre&gt;INDENTATION&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class='html'&gt;
    EOF

    INDENTATION_TABLE_SUFFIX = &lt;&lt;-EOF.unindent.chomp
      &lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
    EOF

    RDOC_SHELL_COMMENTS_HTML = &lt;&lt;-EOF.unindent.chomp
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_PREFIX.sub(“INDENTATION”, “”)}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;div class='rdoc comment markup'&gt;
      &lt;p&gt;
      This is &lt;b&gt;special&lt;/b&gt;. {{{ assignment
      &lt;/p&gt;
      &lt;/div&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_SUFFIX}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;pre class='code'&gt;
        local = $global
          indented
      &lt;/pre&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_PREFIX.sub(“INDENTATION”, “  ”)}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;div class='rdoc comment markup'&gt;
      &lt;p&gt;
      }}}
      &lt;/p&gt;
      &lt;/div&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_SUFFIX}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
    EOF

    def test_classify_shell_comments_and_format_rdoc_comments
      check_split_file(Configuration::CLASSIFY_SHELL_COMMENTS,
                       Configuration::FORMAT_RDOC_COMMENTS) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; RDOC_SHELL_COMMENTS_HTML,
        } ]
      end
    end

    MARKDOWN_SHELL_COMMENTS_HTML = &lt;&lt;-EOF.unindent.chomp
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_PREFIX.sub(“INDENTATION”, “”)}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;div class='markdown comment markup'&gt;
      &lt;p&gt;
      This is &lt;em&gt;special&lt;/em&gt;.
      {{{ assignment
      &lt;/p&gt;
      &lt;/div&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_SUFFIX}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;pre class='code'&gt;
        local = $global
          indented
      &lt;/pre&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_PREFIX.sub(“INDENTATION”, “  ”)}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;div class='markdown comment markup'&gt;
      &lt;p&gt;
      }}}
      &lt;/p&gt;
      &lt;/div&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_SUFFIX}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
    EOF

    def test_classify_shell_comments_and_format_markdown_comments
      check_split_file(Configuration::CLASSIFY_SHELL_COMMENTS,
                       Configuration::FORMAT_MARKDOWN_COMMENTS) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; MARKDOWN_SHELL_COMMENTS_HTML,
        } ]
      end
    end

    HIGHLIGHT_RUBY_HTML = &lt;&lt;-EOF.unindent.chomp
      &lt;pre class='comment'&gt;
      This is *special*.
        {{{ assignment
      &lt;/pre&gt;
      &lt;div class='ruby code syntax' bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;
      &lt;font face=&quot;monospace&quot;&gt;
      &amp;nbsp;&amp;nbsp;local =&amp;nbsp;&lt;font color=&quot;#00ffff&quot;&gt;$global&lt;/font&gt;&lt;br /&gt;
      &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;indented&lt;br /&gt;
      &lt;/font&gt;
      &lt;/div&gt;
      &lt;pre class='comment'&gt;
        }}}
      &lt;/pre&gt;
    EOF

    def test_classify_shell_comments_and_highlight_ruby_code_syntax
      check_split_file(Configuration::CLASSIFY_SHELL_COMMENTS,
                       Configuration::HIGHLIGHT_CODE_SYNTAX.call('ruby')) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; HIGHLIGHT_RUBY_HTML,
        } ]
      end
    end

    FULL_RUBY_PROCESSING_TOP_CHUNK_HTML = &lt;&lt;-EOF.unindent.chomp
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_PREFIX.sub(“INDENTATION”, “”)}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;div class='rdoc comment markup'&gt;
      &lt;p&gt;
      This is &lt;b&gt;special&lt;/b&gt;.
      &lt;/p&gt;
      &lt;/div&gt;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
{INDENTATION_TABLE_SUFFIX}
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      &lt;pre class='nested chunk'&gt;
        &lt;a class='nested chunk' href='#assignment'&gt;assignment&lt;/a&gt;
      &lt;/pre&gt;
    EOF

    FULL_RUBY_PROCESSING_NESTED_CHUNK_HTML = &lt;&lt;-EOF.unindent.chomp
     &lt;pre class='ruby code syntax'&gt;
     local = &lt;span class=&quot;Identifier&quot;&gt;$global&lt;/span&gt;
       indented
     &lt;/pre&gt;
    EOF

    def test_classify_shell_comments_and_css_ruby_code_syntax_and_format_rdoc_comments_and_chunk_by_vim_regions
      check_split_file(Configuration::CLASSIFY_SHELL_COMMENTS,
                       Configuration::CSS_CODE_SYNTAX.call('ruby'),
                       Configuration::FORMAT_RDOC_COMMENTS,
                       Configuration::CHUNK_BY_VIM_REGIONS) do |path|
        [ {
          &quot;name&quot; =&gt; path,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 1 } ],
          &quot;containers&quot; =&gt; [],
          &quot;contained&quot; =&gt; [ &quot;assignment&quot; ],
          &quot;html&quot; =&gt; FULL_RUBY_PROCESSING_TOP_CHUNK_HTML,
        }, {
          &quot;name&quot; =&gt; &quot;assignment&quot;,
          &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; path, &quot;line&quot; =&gt; 2 } ],
          &quot;containers&quot; =&gt; [ path ],
          &quot;contained&quot; =&gt; [],
          &quot;html&quot; =&gt; FULL_RUBY_PROCESSING_NESTED_CHUNK_HTML,
        } ]
      end
    end

  protected

    def check_split_file(*configurations, &amp;block)
      configuration = configurations.inject({}) { |merged_configuration, next_configuration| merged_configuration.deep_merge(next_configuration) }
      splitter = Splitter.new(@errors, configuration)
      chunks = splitter.chunks(path = write_tempfile(&quot;ruby.rb&quot;, RUBY_FILE))
      @errors.should == []
      chunks.should == yield(path)
    end

    RUBY_FILE = &lt;&lt;-EOF.unindent.gsub(&quot;#!&quot;, &quot;#&quot;)
      #! This is *special*.
        #! {{{ assignment
        local = $global
          indented
        #! }}}
    EOF

  end

end
</pre>
</div>
</div>
</p>
<p>
Combining configurations rquires deep-merging. This allows complex nested
structures to be merged. There is even a way for arrays to append elements
before/after the array they are merged with. Here is a simple test that
demonstrates deep-merging complex structures:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-deep-merge-rb">
<span>test/deep_merge.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test deep-merging complex structures.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestDeepMerge &lt; TestCase

    def test_deep_merge
      default = {
        &quot;only_default&quot; =&gt; &quot;default_value&quot;,
        &quot;overriden&quot; =&gt; &quot;default_value&quot;,
        &quot;overriden_array&quot; =&gt; [ &quot;default_value&quot; ],
        &quot;merged_array&quot; =&gt; [ &quot;default_value&quot; ],
      }
      override = {
        &quot;only_override&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden_array&quot; =&gt; [ &quot;overriden_value&quot; ],
        &quot;merged_array&quot; =&gt; [ &quot;overriden_value&quot;, [] ],
      }
      default.deep_merge(override).should == {
        &quot;only_default&quot; =&gt; &quot;default_value&quot;,
        &quot;only_override&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden&quot; =&gt; &quot;overriden_value&quot;,
        &quot;overriden_array&quot; =&gt; [ &quot;overriden_value&quot; ],
        &quot;merged_array&quot; =&gt; [ &quot;overriden_value&quot;, &quot;default_value&quot; ],
      }
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="deep-merge">
<span>Deep merge</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Perform a deep merge with another hash.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Identifier">deep_merge</span>(hash)
    <span class="Statement">return</span> merge(hash, &amp;<span class="Type">Hash</span>::method(<span class="Special">&quot;</span><span class="Constant">deep_merger</span><span class="Special">&quot;</span>))
  <span class="PreProc">end</span>

<span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return a Hash merger that recursively merges nested hashes.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">deep_merger</span>(key, default, override)
    <span class="Statement">if</span> <span class="Type">Hash</span> === default &amp;&amp; <span class="Type">Hash</span> === override
      default.deep_merge(override)
    <span class="Statement">elsif</span> <span class="Type">Array</span> === default &amp;&amp; <span class="Type">Array</span> === override
      <span class="Type">Hash</span>.deep_merge_arrays(default, override)
    <span class="Statement">else</span>
      override
    <span class="Statement">end</span>
  <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
If the override has a [] element, it is replaced by the default it is
overriding.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">deep_merge_arrays</span>(default, override)
    embed_index = override.find_index([])
    <span class="Statement">return</span> override <span class="Statement">unless</span> embed_index
    override = override.dup
    override[embed_index..embed_index] = default
    <span class="Statement">return</span> override
  <span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-hash-rb">lib/codnar/core_ext/hash.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h2>Storing chunks on the disk</h2>

<h3>Writing chunks to disk</h3>
<p>
In any realistic system, the number of source files and chunks will be such
that it makes sense to store the chunks on the disk for further processing.
This allows incorporating the split operation as part of a build tool chain,
and only re-splitting modified files. Here is a simple test demonstrating
writing chunks to the disk:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-write-chunks-rb">
<span>test/write_chunks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test writing chunks to files.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestWriteChunks &lt; TestWithFakeFS

    def test_write_chunks
      check_writing_data([])
      check_writing_data(&quot;name&quot; =&gt; &quot;foo&quot;)
      check_writing_data([ { &quot;name&quot; =&gt; &quot;foo&quot; }, { &quot;name&quot; =&gt; &quot;bar&quot; } ])
    end

    def test_write_invalid_data
      lambda { check_writing_data(&quot;not a chunk&quot;) }.should.raise
    end

  protected

    def check_writing_data(data)
      Writer.write(&quot;path&quot;, data)
      data = [ data ] unless Array === data
      YAML.load_file(&quot;path&quot;).should == data
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-writer-rb">
<span>lib/codnar/writer.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write chunks into a disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Writer</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write one chunk or an array of chunks to a disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">write</span>(path, data)
      <span class="Constant">self</span>.new(path) <span class="Statement">do</span> |<span class="Identifier">writer</span>|
        writer &lt;&lt; data
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Add one chunk or an array of chunks to the disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">&lt;&lt;</span>(data)
      <span class="Statement">case</span> data
      <span class="Statement">when</span> <span class="Type">Array</span>
        <span class="Identifier">@chunks</span> += data
      <span class="Statement">when</span> <span class="Type">Hash</span>
        <span class="Identifier">@chunks</span> &lt;&lt; data
      <span class="Statement">else</span>
        <span class="Statement">raise</span> <span class="Special">&quot;</span><span class="Constant">Invalid data class: </span><span class="Special">#{</span>data.class<span class="Special">}</span><span class="Special">&quot;</span>
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Write chunks into the specified disk file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(path, &amp;block)
      <span class="Identifier">@chunks</span> = []
      <span class="Type">File</span>.open(path, <span class="Special">&quot;</span><span class="Constant">w</span><span class="Special">&quot;</span>) <span class="Statement">do</span> |<span class="Identifier">file</span>|
        block.call(<span class="Constant">self</span>)
        file.print(<span class="Identifier">@chunks</span>.to_yaml)
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h3>Reading chunks to memory</h3>
<p>
Having written the chunks to the disk requires us, at some following point in
time, to read them back into memort. This is the first time we will have a view
of the whole documented system, which allows us to detect several classes of
consistency errors: Some chunks may be left out of the final narrative
(consider this the equivalent of tests code coverage); we may be referring to
missing (or misspelled) chunk names; and, finally, we need to deal with
duplicate chunks.
</p>
<p>
In literate programming, it is trivial to write a chunk once and use it in
several places in the compiled source code. The classical example is C/C++
function signatures that need to appear in both the <code>.h</code> and <code>.c</code>/<code>.cpp</code> files.
However, in some cases this practice makes sense for other pieces of code, and
since the ultimate source code contains only one copy of the chunk, this does
not suffer from the typical copy-and-paste issues.
</p>
<p>
In inverse literate programming, if the same code appears twice (as a result of
copy-and-paste), then it does suffer from the typical copy-and-paste issues.
The most serious of these is, of course, that when only one copy is changed.
The way that Codnar helps alleviate this problem is that if the same chunk
appears more than once in the source code, its content is expected to be
exactly the same in both cases (up to indentation). This should not be viewed
as endorsement of copy-and-paste programming; Using duplicate chunks should be
a last resort measure to combat restrictions in the programming language and
compilation tool chain.
</p>
<h4>Chunk identifiers</h4>
<p>
The above definition raises the obvious question: what does "the same chunk"
mean? As far as Codnar is concerned, a chunk is uniquely identified by its
name, which is specified on the <code>begin_chunk</code> line. The unique identifier is
not the literal name but a transformation of it. This allows us to ignore
capitalization, white space, and any punctuation that may appear in the name.
It also allows us to use the resulting ID as an HTML anchor name, without
worrying about HTML's restictions on such names.
</p>
<p>
Here is a simple test demonstrating converting names to identifiers:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-identify-chunks-rb">
<span>test/identify_chunks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;test_case&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test converting chunk names to identifiers.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestIdentifyChunks &lt; TestCase

    def test_lower_case_to_id
      &quot;a&quot;.to_id.should == &quot;a&quot;
    end

    def test_upper_case_to_id
      &quot;A&quot;.to_id.should == &quot;a&quot;
    end

    def test_digits_to_id
      &quot;1&quot;.to_id.should == &quot;1&quot;
    end

    def test_non_alnum_to_id
      &quot;!@-$#&quot;.to_id.should == &quot;-&quot;
    end

    def test_complex_to_id
      &quot;C# for .NET!&quot;.to_id.should == &quot;c-for-net-&quot;
    end

    def test_strip_to_id
      &quot; a &quot;.to_id.should == &quot;a&quot;
    end


  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="convert-names-to-identifiers">
<span>Convert names to identifiers</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Convert this String to an identifier. This is a stable operation, so
anything that accept a name will also accept an identifier as well.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">def</span> <span class="Identifier">to_id</span>
  <span class="Statement">return</span> <span class="Constant">self</span>.strip.gsub(<span class="Special">/</span><span class="Special">[^</span><span class="Constant">a-zA-Z0-9</span><span class="Special">]</span><span class="Special">+</span><span class="Special">/</span>, <span class="Special">&quot;</span><span class="Constant">-</span><span class="Special">&quot;</span>).downcase
<span class="PreProc">end</span>

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-core-ext-string-rb">lib/codnar/core_ext/string.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h4>In-memory chunks storage</h4>
<p>
Detecting unused and/or duplicate chunks requires us to have in-memory chunk
storage that tracks all chunks access. Here is a simple test demonstrating
reading chunks into the storage and handling the various error conditions
listed above:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-read-chunks-rb">
<span>test/read_chunks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test reading chunks from files.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestReadChunks &lt; TestWithFakeFS

    def test_read_chunks
      Writer.write(&quot;foo.chunks&quot;, { &quot;name&quot; =&gt; &quot;foo&quot; })
      Writer.write(&quot;bar.chunks&quot;, [ { &quot;name&quot; =&gt; &quot;bar&quot; }, { &quot;name&quot; =&gt; &quot;baz&quot; } ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo&quot; =&gt; { &quot;name&quot; =&gt; &quot;foo&quot; },
                              &quot;bar&quot; =&gt; { &quot;name&quot; =&gt; &quot;bar&quot; },
                              &quot;baz&quot; =&gt; { &quot;name&quot; =&gt; &quot;baz&quot; })
      @errors.should == []
    end

    def test_read_unused_chunks
      Writer.write(&quot;foo.chunks&quot;, { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot;, &quot;line&quot; =&gt; 1 } ] })
      Writer.write(&quot;bar.chunks&quot;, { &quot;name&quot; =&gt; &quot;bar&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;b&quot;, &quot;line&quot; =&gt; 2 } ] })
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo&quot; =&gt; { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot;, &quot;line&quot; =&gt; 1 } ] })
      @errors.should == [ &quot;#{$0}: Unused chunk: bar in file: b at line: 2&quot; ]
    end

    def test_read_duplicate_chunks
      Writer.write(&quot;foo.chunks&quot;, { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot; } ], &quot;contained&quot; =&gt; [ &quot;A&quot; ], &quot;containers&quot; =&gt; [ &quot;c&quot; ] })
      Writer.write(&quot;bar.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;b&quot; } ], &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [ &quot;d&quot; ] },
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;c&quot; } ], &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [] }
      ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo&quot; =&gt; {
        &quot;name&quot; =&gt; &quot;foo&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;a&quot; }, { &quot;file&quot; =&gt; &quot;b&quot; }, { &quot;file&quot; =&gt; &quot;c&quot; } ],
        &quot;contained&quot; =&gt; [ &quot;a&quot; ],
        &quot;containers&quot; =&gt; [ &quot;c&quot;, &quot;d&quot; ],
      })
    end

    def test_read_different_chunks
      Writer.write(&quot;foo.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;html&quot; =&gt; &quot;bar&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 } ], &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [] },
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;html&quot; =&gt; &quot;baz&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 2 } ], &quot;contained&quot; =&gt; [ &quot;A&quot; ], &quot;containers&quot; =&gt; [] }
      ])
      Writer.write(&quot;bar.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;foo&quot;, &quot;html&quot; =&gt; &quot;bar&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;bar.chunks&quot;, &quot;line&quot; =&gt; 1 } ], &quot;contained&quot; =&gt; [ &quot;a&quot; ], &quot;containers&quot; =&gt; [] }
      ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;).sort)
      @errors.should == [
        &quot;#{$0}: Chunk: foo is different in file: foo.chunks at line: 2, and in file: bar.chunks at line: 1 or in file: foo.chunks at line: 1&quot;
      ]
      check_read_data(reader, &quot;foo&quot; =&gt; {
        &quot;name&quot; =&gt; &quot;foo&quot;,
        &quot;html&quot; =&gt; &quot;bar&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;bar.chunks&quot;, &quot;line&quot; =&gt; 1 }, { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;contained&quot; =&gt; [ &quot;a&quot; ],
        &quot;containers&quot; =&gt; [],
      })
    end

    def test_read_fake_chunk
      reader = Reader.new(@errors, [])
      reader[&quot;foo&quot;].should == Reader.fake_chunk(&quot;foo&quot;)
      @errors.should == [ &quot;#{$0}: Missing chunk: foo&quot; ]
    end

    def test_read_equivalent_name_chunks
      Writer.write(&quot;foo.chunks&quot;, [
        { &quot;name&quot; =&gt; &quot;Foo?&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 } ], &quot;containers&quot; =&gt; [ &quot;1&quot; ], &quot;contained&quot; =&gt; [ &quot;c&quot; ] },
        { &quot;name&quot; =&gt; &quot;FOO!!&quot;, &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 2 } ], &quot;containers&quot; =&gt; [ &quot;2&quot; ], &quot;contained&quot; =&gt; [ &quot;C&quot; ] }
      ])
      reader = Reader.new(@errors, Dir.glob(&quot;./**/*.chunks&quot;))
      check_read_data(reader, &quot;foo-&quot; =&gt; {
        &quot;name&quot; =&gt; &quot;Foo?&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 1 }, { &quot;file&quot; =&gt; &quot;foo.chunks&quot;, &quot;line&quot; =&gt; 2 } ],
        &quot;containers&quot; =&gt; [ &quot;1&quot;, &quot;2&quot; ],
        &quot;contained&quot; =&gt; [ &quot;c&quot; ],
      })
    end

  protected

    def check_read_data(reader, chunks)
      chunks.each do |name, chunk|
        reader[name].should == chunk
      end
      reader.collect_unused_chunk_errors
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-reader-rb">
<span>lib/codnar/reader.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Read chunks from disk files.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Reader</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all chunks from the specified disk files to memory for later access by
name.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(errors, paths)
      <span class="Identifier">@errors</span> = errors
      <span class="Identifier">@chunks</span> = {}
      <span class="Identifier">@used</span> = {}
      paths.each <span class="Statement">do</span> |<span class="Identifier">path</span>|
        load_path_chunks(path)
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Fetch a chunk by its name.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">[]</span>(name)
      id = name.to_id
      <span class="Identifier">@used</span>[id] = <span class="Constant">true</span>
      <span class="Statement">return</span> <span class="Identifier">@chunks</span>[id] ||= (
        <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Missing chunk: </span><span class="Special">#{</span>name<span class="Special">}</span><span class="Special">&quot;</span>
        <span class="Type">Reader</span>.fake_chunk(name)
      )
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Collect errors for unused chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">collect_unused_chunk_errors</span>
      <span class="Identifier">@chunks</span>.each <span class="Statement">do</span> |<span class="Identifier">id</span>, <span class="Identifier">chunk</span>|
        <span class="Identifier">@errors</span>.push(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: Unused chunk: </span><span class="Special">#{</span>chunk.name<span class="Special">}</span><span class="Constant"> </span><span class="Special">#{</span><span class="Type">Reader</span>.locations_message(chunk)<span class="Special">}</span><span class="Special">&quot;</span>) <span class="Statement">unless</span> <span class="Identifier">@used</span>[id]
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all chunks from a disk file into memory.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">load_path_chunks</span>(path)
      <span class="Identifier">@errors</span>.in_path(path) <span class="Statement">do</span>
        chunks = <span class="Type">YAML</span>.load_file(path)
        merge_loaded_chunks(chunks)
        <span class="Identifier">@root_chunk</span> ||= chunks[<span class="Constant">0</span>].name
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge an array of chunks into memory.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">merge_loaded_chunks</span>(chunks)
      chunks.each <span class="Statement">do</span> |<span class="Identifier">new_chunk</span>|
        old_chunk = <span class="Identifier">@chunks</span>[id = new_chunk.name.to_id]
        <span class="Statement">if</span> old_chunk.nil?
          <span class="Identifier">@chunks</span>[id] = new_chunk
        <span class="Statement">elsif</span> <span class="Type">Reader</span>.same_chunk?(old_chunk, new_chunk)
          <span class="Type">Reader</span>.merge_same_chunks(old_chunk, new_chunk)
        <span class="Statement">else</span>
          <span class="Identifier">@errors</span>.push(<span class="Type">Reader</span>.different_chunks_error(old_chunk, new_chunk))
        <span class="Statement">end</span>
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge a new “same” chunk into an old one.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">merge_same_chunks</span>(old_chunk, new_chunk)
      old_chunk.locations = (old_chunk.locations + new_chunk.locations).uniq.sort <span class="Statement">do</span> |<span class="Identifier">first_location</span>, <span class="Identifier">second_location</span>|
        [ first_location.file.to_id, first_location.line ] &lt;=&gt; [ second_location.file.to_id, second_location.line ]
      <span class="Statement">end</span>
      old_chunk.containers = (old_chunk.containers + new_chunk.containers).uniq.sort { |<span class="Identifier">first_name</span>, <span class="Identifier">second_name</span>| first_name.to_id &lt;=&gt; second_name.to_id }
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Check whether two chunks contain the same “stuff”.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">same_chunk?</span>(old_chunk, new_chunk)
      <span class="Statement">return</span> <span class="Type">Reader</span>.chunk_payload(old_chunk) == <span class="Type">Reader</span>.chunk_payload(new_chunk)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return just the actual payload of a chunk for equality comparison.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">chunk_payload</span>(chunk)
      chunk = chunk.reject { |<span class="Identifier">key</span>, <span class="Identifier">value</span>| key == <span class="Special">&quot;</span><span class="Constant">locations</span><span class="Special">&quot;</span> || key == <span class="Special">&quot;</span><span class="Constant">name</span><span class="Special">&quot;</span> || key == <span class="Special">&quot;</span><span class="Constant">containers</span><span class="Special">&quot;</span> }
      chunk.contained.map! { |<span class="Identifier">name</span>| name.to_id }
      <span class="Statement">return</span> chunk
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Error message when two different chunks have the same name.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">different_chunks_error</span>(old_chunk, new_chunk)
      old_location = <span class="Type">Reader</span>.locations_message(old_chunk)
      new_location = <span class="Type">Reader</span>.locations_message(new_chunk)
      <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: Chunk: </span><span class="Special">#{</span>old_chunk.name<span class="Special">}</span><span class="Constant"> is different </span><span class="Special">#{</span>new_location<span class="Special">}</span><span class="Constant">, and </span><span class="Special">#{</span>old_location<span class="Special">}</span><span class="Special">&quot;</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Format a chunk’s location for an error message.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">locations_message</span>(chunk)
      locations = chunk.locations.map { |<span class="Identifier">location</span>| <span class="Special">&quot;</span><span class="Constant">in file: </span><span class="Special">#{</span>location.file<span class="Special">}</span><span class="Constant"> at line: </span><span class="Special">#{</span>location.line<span class="Special">}</span><span class="Special">&quot;</span> }
      <span class="Statement">return</span> locations.join(<span class="Special">&quot;</span><span class="Constant"> or </span><span class="Special">&quot;</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return a fake chunk for the specified name.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">fake_chunk</span>(name)
      <span class="Statement">return</span> {
        <span class="Special">&quot;</span><span class="Constant">name</span><span class="Special">&quot;</span> =&gt; name,
        <span class="Special">&quot;</span><span class="Constant">locations</span><span class="Special">&quot;</span> =&gt; [ { <span class="Special">&quot;</span><span class="Constant">file</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">MISSING</span><span class="Special">&quot;</span> } ],
        <span class="Special">&quot;</span><span class="Constant">contained</span><span class="Special">&quot;</span> =&gt; [],
        <span class="Special">&quot;</span><span class="Constant">containers</span><span class="Special">&quot;</span> =&gt; [],
        <span class="Special">&quot;</span><span class="Constant">html</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">&lt;div class='missing chunk error'&gt;</span><span class="Special">\n</span><span class="Constant">MISSING</span><span class="Special">\n</span><span class="Constant">&lt;/div&gt;</span><span class="Special">&quot;</span>
      }
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h2>Weaving chunks into HTML</h2>
<p>
Assembling the final HTML requires combining both the narrative documentation
and source code chunks. This is done top-down starting at a "root"
documentation chunk and recursively embedding nested documentation and code
chunks into it.
</p>
<h3>Weaving chunks together</h3>
<p>
When embedding a documentation chunk inside another documentation chunk, things
are pretty easy - we just need to insert the embedded chunk HTML into the
containing chunk. When embedding a source code chunk into the documentation,
however, we may want to wrap it in some boilerplate HTML, providing a header,
footer, borders, links, etc. Therefore, the HTML-sh syntax we use to embed a
chunk into the documentation is <code>&lt;embed src="..."
type="x-codnar/template-name"/&gt;</code>.
</p>
<p>
The templates are normal ERB templates. As a special and highly magical case,
the template named <code>file</code> simply embeds the specified file into the
documentation at that point. This is similar to the "server side include"
available in many web framework, or to a client-side <code>iframe</code> directive. This
really should have been part of HTML; why HTML allows unrestricted inclusion of
JavaScript code but denies the same ability to HTML and CSS code is beyond me.
</p>
<p>
At any rate, here is a simple test demonstrating applying different templates
to the embedded code chunks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-weave-configurations-rb">
<span>test/weave_configurations.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test the built-in weave configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestWeaveConfigurations &lt; TestWithFakeFS

    def test_weave_file
      Writer.write(&quot;chunks&quot;, {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [], &quot;contained&quot; =&gt; [],
        &quot;name&quot; =&gt; &quot;Top&quot;, &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent,
          &lt;h1&gt;Top&lt;/h1&gt;
          &lt;embed src=&quot;path&quot; type=&quot;x-codnar/file&quot;/&gt;
        EOF
      })
      File.open(&quot;path&quot;, &quot;w&quot;) { |file| file.puts(&quot;&lt;h2&gt;File&lt;/h2&gt;&quot;) }
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_INCLUDE).weave(&quot;include&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == &lt;&lt;-EOF.unindent
        &lt;h1&gt;Top&lt;/h1&gt;
        &lt;h2&gt;File&lt;/h2&gt;
      EOF
    end

    def test_weave_include
      Writer.write(&quot;chunks&quot;, chunks(&quot;include&quot;))
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_INCLUDE).weave(&quot;include&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == &lt;&lt;-EOF.unindent
        &lt;h1&gt;Top&lt;/h1&gt;
        &lt;h2&gt;Intermediate&lt;/h2&gt;
        &lt;h3&gt;Bottom&lt;/h3&gt;
      EOF
    end

    WOVEN_PLAIN_CHUNK = &lt;&lt;-EOF.unindent
      &lt;div class=&quot;plain chunk&quot;&gt;
      &lt;a name=&quot;top&quot;/&gt;
      &lt;h1&gt;Top&lt;/h1&gt;
      &lt;div class=&quot;plain chunk&quot;&gt;
      &lt;a name=&quot;intermediate&quot;/&gt;
      &lt;h2&gt;Intermediate&lt;/h2&gt;
      &lt;div class=&quot;plain chunk&quot;&gt;
      &lt;a name=&quot;bottom&quot;/&gt;
      &lt;h3&gt;Bottom&lt;/h3&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    EOF

    def test_weave_plain_chunk
      Writer.write(&quot;chunks&quot;, chunks(&quot;plain_chunk&quot;))
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_PLAIN_CHUNK).weave(&quot;plain_chunk&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == WOVEN_PLAIN_CHUNK
    end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Normally, one does not nest named_chunk_with_containers chunks this way,
but it serves as a test.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
    WOVEN_NAMED_CHUNK = &lt;&lt;-EOF.unindent
      &lt;div class=&quot;named_with_containers chunk&quot;&gt;
      &lt;div class=&quot;chunk name&quot;&gt;
      &lt;a name=&quot;top&quot;&gt;
      &lt;span&gt;Top&lt;/span&gt;
      &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk html&quot;&gt;
      &lt;h1&gt;Top&lt;/h1&gt;
      &lt;div class=&quot;named_with_containers chunk&quot;&gt;
      &lt;div class=&quot;chunk name&quot;&gt;
      &lt;a name=&quot;intermediate&quot;&gt;
      &lt;span&gt;Intermediate&lt;/span&gt;
      &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk html&quot;&gt;
      &lt;h2&gt;Intermediate&lt;/h2&gt;
      &lt;div class=&quot;named_with_containers chunk&quot;&gt;
      &lt;div class=&quot;chunk name&quot;&gt;
      &lt;a name=&quot;bottom&quot;&gt;
      &lt;span&gt;BOTTOM&lt;/span&gt;
      &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk html&quot;&gt;
      &lt;h3&gt;Bottom&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk containers&quot;&gt;
      &lt;span class=&quot;chunk containers header&quot;&gt;Contained in:&lt;/span&gt;
      &lt;ul class=&quot;chunk containers&quot;&gt;
      &lt;li class=&quot;chunk container&quot;&gt;
      &lt;a class=&quot;chunk container&quot; href=&quot;#intermediate&quot;&gt;Intermediate&lt;/a&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;chunk containers&quot;&gt;
      &lt;span class=&quot;chunk containers header&quot;&gt;Contained in:&lt;/span&gt;
      &lt;ul class=&quot;chunk containers&quot;&gt;
      &lt;li class=&quot;chunk container&quot;&gt;
      &lt;a class=&quot;chunk container&quot; href=&quot;#top&quot;&gt;Top&lt;/a&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    EOF

    def test_weave_named_chunk_with_containers
      Writer.write(&quot;chunks&quot;, chunks(&quot;named_chunk_with_containers&quot;))
      html = Weaver.new(@errors, [ &quot;chunks&quot; ], Configuration::WEAVE_NAMED_CHUNK_WITH_CONTAINERS).weave(&quot;named_chunk_with_containers&quot;, &quot;top&quot;)
      @errors.should == []
      html.should == WOVEN_NAMED_CHUNK
    end

  protected

    def chunks(template)
      return [ {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [ &quot;Intermediate&quot; ], &quot;contained&quot; =&gt; [], &quot;name&quot; =&gt; &quot;BOTTOM&quot;, &quot;html&quot; =&gt; &quot;&lt;h3&gt;Bottom&lt;/h3&gt;\n&quot;,
      }, {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [ &quot;Top&quot; ], &quot;contained&quot; =&gt; [ &quot;BOTTOM&quot; ],
        &quot;name&quot; =&gt; &quot;Intermediate&quot;, &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent,
          &lt;h2&gt;Intermediate&lt;/h2&gt;
          &lt;embed type='x-codnar/#{template}' src='bottom'&gt;
          &lt;/embed&gt;
        EOF
      }, {
        &quot;locations&quot; =&gt; [ &quot;file&quot; =&gt; &quot;chunk&quot; ], &quot;containers&quot; =&gt; [], &quot;contained&quot; =&gt; [ &quot;Intermediate&quot; ],
        &quot;name&quot; =&gt; &quot;Top&quot;, &quot;html&quot; =&gt; &lt;&lt;-EOF.unindent,
          &lt;h1&gt;Top&lt;/h1&gt;
          &lt;embed src=&quot;##INTERMEDIATE&quot; type=&quot;x-codnar/#{template}&quot;/&gt;
        EOF
      } ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-weaver-rb">
<span>lib/codnar/weaver.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave all chunks to a unified HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Weaver</span> &lt; <span class="Type">Reader</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all chunks from the specified disk files to memory for weaving using
the specified templates.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(errors, paths, templates)
      <span class="Statement">super</span>(errors, paths)
      <span class="Identifier">@templates</span> = templates
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave the HTML for a named chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">weave</span>(template, chunk_name = <span class="Identifier">@root_chunk</span>)
      <span class="Statement">return</span> process_file(chunk_name) <span class="Statement">if</span> template == <span class="Special">&quot;</span><span class="Constant">file</span><span class="Special">&quot;</span>
      <span class="Identifier">@last_chunk</span> = chunk = <span class="Constant">self</span>[chunk_name.to_id]
      expand_chunk_html(chunk)
      <span class="Statement">return</span> process_template(chunk, template)
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Due to <a
href="http://github.com/relevance/rcov/issues/#issue/43">github.com/relevance/rcov/issues/#issue/43</a>
the following regular expressions must be on a single line.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Detect embedded chunks (type= before src=).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="Type">TYPE_SRC_CHUNK</span> = <span class="Special">/</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant"> </span><span class="Special">]</span><span class="Special">*</span><span class="Constant"> &lt;embed </span><span class="Special">\s</span><span class="Special">+</span><span class="Constant"> type = </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> x-codnar</span><span class="Special">\/</span><span class="Constant"> </span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> </span><span class="Special">\s</span><span class="Special">+</span><span class="Constant"> src = </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> \#</span><span class="Special">*</span><span class="Constant"> </span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> </span><span class="Special">\s</span><span class="Special">*</span><span class="Constant"> </span><span class="Special">(?:</span><span class="Constant"> </span><span class="Special">\/</span><span class="Constant">&gt; </span><span class="Special">|</span><span class="Constant"> &gt; </span><span class="Special">\s</span><span class="Special">*</span><span class="Constant"> &lt;</span><span class="Special">\/</span><span class="Constant">embed&gt; </span><span class="Special">)</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant"> </span><span class="Special">]</span><span class="Special">*</span><span class="Constant"> </span><span class="Special">/x</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Detect embedded chunks (src= before type=).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="Type">SRC_TYPE_CHUNK</span> = <span class="Special">/</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant"> </span><span class="Special">]</span><span class="Special">*</span><span class="Constant"> &lt;embed </span><span class="Special">\s</span><span class="Special">+</span><span class="Constant"> src = </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> \#</span><span class="Special">*</span><span class="Constant"> </span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> </span><span class="Special">\s</span><span class="Special">+</span><span class="Constant"> type = </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> x-codnar</span><span class="Special">\/</span><span class="Constant"> </span><span class="Special">(</span><span class="Special">.</span><span class="Special">*?</span><span class="Special">)</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant">'\&quot;</span><span class="Special">]</span><span class="Constant"> </span><span class="Special">\s</span><span class="Special">*</span><span class="Constant"> </span><span class="Special">(?:</span><span class="Constant"> </span><span class="Special">\/</span><span class="Constant">&gt; </span><span class="Special">|</span><span class="Constant"> &gt; </span><span class="Special">\s</span><span class="Special">*</span><span class="Constant"> &lt;</span><span class="Special">\/</span><span class="Constant">embed&gt; </span><span class="Special">)</span><span class="Constant"> </span><span class="Special">[</span><span class="Constant"> </span><span class="Special">]</span><span class="Special">*</span><span class="Constant"> </span><span class="Special">/x</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Recursively expand all embedded chunks inside a container chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">expand_chunk_html</span>(chunk)
      html = chunk.html
      <span class="Identifier">@errors</span>.push(<span class="Special">&quot;</span><span class="Constant">No HTML in chunk: </span><span class="Special">#{</span>chunk.name<span class="Special">}</span><span class="Constant"> </span><span class="Special">#{</span><span class="Type">Weaver</span>.locations_message(chunk)<span class="Special">}</span><span class="Special">&quot;</span>) <span class="Statement">unless</span> html
      <span class="Comment">#! TRICKY: All &quot;container&quot; chunks are assumed to be whole-file chunks with</span>
      <span class="Comment">#! a single location. Which makes sense as these are documentation and not</span>
      <span class="Comment">#! code chunks. </span><span class="Todo">TODO</span><span class="Comment">: It would be nice to know the exact line number of</span>
      <span class="Comment">#! the chunk embedding directive for better pinpointing of any error.</span>
      <span class="Identifier">@errors</span>.in_path(chunk.locations[<span class="Constant">0</span>].file) <span class="Statement">do</span>
        chunk.expanded_html ||= expand_embedded_chunks(html || <span class="Special">&quot;&quot;</span>).chomp
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Recursively expand_embedded_chunks all embedded chunk inside an HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">expand_embedded_chunks</span>(html)
      <span class="Statement">return</span> html.gsub(<span class="Type">TYPE_SRC_CHUNK</span>) { |<span class="Identifier">match</span>| weave(<span class="Identifier">$1</span>, <span class="Identifier">$2</span>).chomp } \
                 .gsub(<span class="Type">SRC_TYPE_CHUNK</span>) { |<span class="Identifier">match</span>| weave(<span class="Identifier">$2</span>, <span class="Identifier">$1</span>).chomp }
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process the chunk using an ERB template prior to inclusion in container
chunk.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">process_template</span>(chunk, template_name)
      template_text = <span class="Identifier">@templates</span>[template_name] ||= (
        <span class="Identifier">@errors</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Missing ERB template: </span><span class="Special">#{</span>template_name<span class="Special">}</span><span class="Special">&quot;</span>
        <span class="Special">&quot;</span><span class="Constant">&lt;%= chunk.expanded_html %&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span>
      )
      <span class="Statement">return</span> (
        (
          chunk.erb ||= {}
        )[template_name] ||= <span class="Type">ERB</span>.new(template_text, <span class="Constant">nil</span>, <span class="Special">&quot;</span><span class="Constant">%</span><span class="Special">&quot;</span>)
      ).result(binding)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Process a disk file (invoked by the special “file” template).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">process_file</span>(path)
      <span class="Statement">begin</span>
        <span class="Statement">return</span> <span class="Type">File</span>.read(path)
      <span class="Statement">rescue</span> <span class="Type">Exception</span> =&gt; exception
        <span class="Identifier">@errors</span>.push(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: Reading file: </span><span class="Special">#{</span>path<span class="Special">}</span><span class="Constant"> exception: </span><span class="Special">#{</span>exception<span class="Special">}</span><span class="Constant"> </span><span class="Special">#{</span><span class="Type">Reader</span>.locations_message(<span class="Identifier">@last_chunk</span>)<span class="Special">}</span><span class="Special">&quot;</span>) <span class="Statement">if</span> <span class="Identifier">@last_chunk</span>
        <span class="Statement">return</span> <span class="Special">&quot;</span><span class="Constant">FILE: </span><span class="Special">#{</span>path<span class="Special">}</span><span class="Constant"> EXCEPTION: </span><span class="Special">#{</span>exception<span class="Special">}</span><span class="Special">&quot;</span>
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<p>
And here are the pre-defined weaving template configurations:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="built-in-weaving-templates">
<span>Built-in weaving templates</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave configuration providing a single simple “include” template.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">WEAVE_INCLUDE</span> = { <span class="Special">&quot;</span><span class="Constant">include</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">&lt;%= chunk.expanded_html %&gt;</span><span class="Special">\n</span><span class="Special">&quot;</span> }

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave chunks in the plainest possible way.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">WEAVE_PLAIN_CHUNK</span> = {
  <span class="Special">&quot;</span><span class="Constant">plain_chunk</span><span class="Special">&quot;</span> =&gt; &lt;&lt;-<span class="Special">EOF</span>.unindent,
<span class="Constant">    &lt;div class=&quot;plain chunk&quot;&gt;</span>
<span class="Constant">    &lt;a name=&quot;&lt;%= chunk.name.to_id %&gt;&quot;/&gt;</span>
<span class="Constant">    &lt;%= chunk.expanded_html %&gt;</span>
<span class="Constant">    &lt;/div&gt;</span>
<span class="Constant">  </span><span class="Special">EOF</span>
}

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave chunks with their name and the list of container chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="Type">WEAVE_NAMED_CHUNK_WITH_CONTAINERS</span> = {
  <span class="Special">&quot;</span><span class="Constant">named_chunk_with_containers</span><span class="Special">&quot;</span> =&gt; &lt;&lt;-<span class="Special">EOF</span>.unindent,
<span class="Constant">    &lt;div class=&quot;named_with_containers chunk&quot;&gt;</span>
<span class="Constant">    &lt;div class=&quot;chunk name&quot;&gt;</span>
<span class="Constant">    &lt;a name=&quot;&lt;%= chunk.name.to_id %&gt;&quot;&gt;</span>
<span class="Constant">    &lt;span&gt;&lt;%= CGI.escapeHTML(chunk.name) %&gt;&lt;/span&gt;</span>
<span class="Constant">    &lt;/a&gt;</span>
<span class="Constant">    &lt;/div&gt;</span>
<span class="Constant">    &lt;div class=&quot;chunk html&quot;&gt;</span>
<span class="Constant">    &lt;%= chunk.expanded_html %&gt;</span>
<span class="Constant">    &lt;/div&gt;</span>
<span class="Constant">    % if chunk.containers != []</span>
<span class="Constant">    &lt;div class=&quot;chunk containers&quot;&gt;</span>
<span class="Constant">    &lt;span class=&quot;chunk containers header&quot;&gt;Contained in:&lt;/span&gt;</span>
<span class="Constant">    &lt;ul class=&quot;chunk containers&quot;&gt;</span>
<span class="Constant">    % chunk.containers.each do |container|</span>
<span class="Constant">    &lt;li class=&quot;chunk container&quot;&gt;</span>
<span class="Constant">    &lt;a class=&quot;chunk container&quot; href=&quot;#&lt;%= container.to_id %&gt;&quot;&gt;&lt;%= CGI.escapeHTML(container) %&gt;&lt;/a&gt;</span>
<span class="Constant">    &lt;/li&gt;</span>
<span class="Constant">    % end</span>
<span class="Constant">    &lt;/ul&gt;</span>
<span class="Constant">    &lt;/div&gt;</span>
<span class="Constant">    % end</span>
<span class="Constant">    &lt;/div&gt;</span>
<span class="Constant">  </span><span class="Special">EOF</span>
}

</pre>
</div>
<div class="chunk containers">
<span class="chunk containers header">Contained in:</span>
<ul class="chunk containers">
<li class="chunk container">
<a class="chunk container" href="#lib-codnar-configuration-rb">lib/codnar/configuration.rb</a>
</li>
</ul>
</div>
</div>
</p>
<h2>Invoking the functionality</h2>
<p>
There are two ways to invoke Codnar's functionality - from the command line,
and (for Ruby projects) as integrated Rake tasks.
</p>
<h3>Command Line Applications</h3>
<p>
The base command line Application class handles execution from the command
line, with the usual standard options, as well as some Codnar-specific ones:
the ability to specify configuration files and/or built-in configurations, and
the ability to include additional extension code. Together, these allow
configuring and extending Codnar's behavior to cover the specific system's
needs.
</p>
<p>
In addition, the Application class also supports invocation from unit tests.
Here is a simple test demonstrating this mode of invocation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-run-application-rb">
<span>test/run_application.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running a Codnar Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestRunApplication &lt; TestWithFakeFS

    def test_do_nothing
      Application.with_argv(%w(dummy)) { Application.new(true).run }.should == 0
    end

    def test_print_version
      Application.with_argv(%w(-v -h -o nested/stdout dummy)) { Application.new(true).run }.should == 0
      File.read(&quot;nested/stdout&quot;).should == &quot;#{$0}: Version: #{Codnar::VERSION}\n&quot;
    end

    def test_print_help
      Application.with_argv(%w(-h -o stdout dummy)) { Application.new(true).run }.should == 0
      File.read(&quot;stdout&quot;).should.include?(&quot;OPTIONS&quot;)
    end

    def test_require_configuration_module
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The additional_module is read by Ruby and is not captured by FakeFS.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
      File.open(&quot;additional_configuration.yaml&quot;, &quot;w&quot;) { |file| file.puts(&quot;bar: updated_bar&quot;) }
      status = Application.with_argv(%w(-o stdout -I support -r additional_module -c ADDITIONAL additional_configuration.yaml -- dummy)) do
        run_print_configuration
      end
      YAML.load_file(&quot;stdout&quot;).should == { &quot;foo&quot; =&gt; &quot;original_foo&quot;, &quot;bar&quot; =&gt; &quot;updated_bar&quot; }
    end

    def test_require_missing_configuration
      status = Application.with_argv(%w(-e stderr -I support -r additional_module -c additional no-such-configuration -- dummy)) do
        run_print_configuration
      end
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Configuration: no-such-configuration is neither a disk file nor a known configuration\n&quot;
    end

  protected

    def run_print_configuration
      Application.new(true).run do |configuration|
        puts configuration.to_yaml
      end
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-application-rb">
<span>lib/codnar/application.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Base class for Codnar applications.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Application</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a Codnar application.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(is_test = <span class="Constant">nil</span>)
      <span class="Identifier">@errors</span> = <span class="Type">Errors</span>.new
      <span class="Identifier">@is_test</span> = !!is_test
      <span class="Identifier">@configuration</span> ||= {}
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the Codnar application, returning its status.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">run</span>(&amp;block)
      parse_options
      block.call(<span class="Identifier">@configuration</span>) <span class="Statement">if</span> block
      <span class="Statement">return</span> print_errors
    <span class="PreProc">rescue</span> <span class="Type">ExitException</span> =&gt; exception
      <span class="Statement">return</span> exception.status
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Execute a block with an overriden ARGV, typically for running an
application.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">with_argv</span>(argv)
      <span class="Statement">return</span> <span class="Type">Globals</span>.without_changes <span class="Statement">do</span>
        <span class="Identifier">ARGV</span>.replace(argv)
        <span class="Statement">yield</span>
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Parse the command line options of the program.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">parse_options</span>
      <span class="Identifier">@options</span> = <span class="Type">GetOptions</span>.new(<span class="Special">%w(</span><span class="Constant">help version output=string error=string include|I=@string require=@string configuration=@string</span><span class="Special">)</span>)
      redirect_files
      print_options
      load_modules
      merge_configurations
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Redirect standard output and error according to the parsed command line
options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">redirect_files</span>
      <span class="Identifier">$stdout</span> = <span class="Type">Application</span>::redirect_file(<span class="Identifier">$stdout</span>, <span class="Identifier">@options</span>.output)
      <span class="Identifier">$stderr</span> = <span class="Type">Application</span>::redirect_file(<span class="Identifier">$stderr</span>, <span class="Identifier">@options</span>.error)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Redirect a standard file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">redirect_file</span>(default, file)
      <span class="Statement">return</span> default <span class="Statement">if</span> file.nil? || file == <span class="Special">&quot;</span><span class="Constant">-</span><span class="Special">&quot;</span>
      <span class="Type">FileUtils</span>.mkdir_p(<span class="Type">File</span>.dirname(<span class="Type">File</span>.expand_path(file)))
      <span class="Statement">return</span> <span class="Type">File</span>.open(file, <span class="Special">&quot;</span><span class="Constant">w</span><span class="Special">&quot;</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print data about the program and exit according to the parsed command line
options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_options</span>
      print_version <span class="Statement">if</span> <span class="Identifier">@options</span>.version
      print_help <span class="Statement">if</span> <span class="Identifier">@options</span>.help
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the current Codnar version.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_version</span>
      puts(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: Version: </span><span class="Special">#{</span><span class="Type">Codnar</span>::<span class="Type">VERSION</span><span class="Special">}</span><span class="Special">&quot;</span>)
      <span class="Statement">exit</span>(<span class="Constant">0</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print a short help message listing the available command line options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help</span>(&amp;block)
      print_help_before_options
      print_standard_options
      print_help_after_options
      <span class="Statement">exit</span>(<span class="Constant">0</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message before the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help_before_options</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the standard Codnar options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_standard_options</span>
      print(&lt;&lt;-<span class="Special">EOF</span>.unindent)
<span class="Constant">        OPTIONS:</span>

<span class="Constant">          -h, --help                           Print this help message and exit.</span>
<span class="Constant">          -v, --version                        Print the version number (</span><span class="Special">#{</span><span class="Type">Codnar</span>::<span class="Type">VERSION</span><span class="Special">}</span><span class="Constant">) and exit.</span>
<span class="Constant">          -o, --output &lt;path&gt;|-                Redirect standard output to the &lt;path&gt;.</span>
<span class="Constant">          -e, --error &lt;path&gt;|-                 Redirect standard error to the &lt;path&gt;.</span>
<span class="Constant">          -I, --include &lt;path&gt;...              Add &lt;path&gt;(s) to Ruby's libs search path.</span>
<span class="Constant">          -r, --require &lt;path&gt;...              Ruby require the code in the &lt;path&gt;(s).</span>
<span class="Constant">          -c, --configuration &lt;NAME&gt;|&lt;path&gt;... Load named or disk file configuration(s).</span>
<span class="Constant">      </span><span class="Special">EOF</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message after the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help_after_options</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load all requested modules.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">load_modules</span>
      (<span class="Identifier">@options</span>.include || []).reverse.each <span class="Statement">do</span> |<span class="Identifier">path</span>|
        <span class="Identifier">$:</span>.unshift(path)
      <span class="Statement">end</span>
      (<span class="Identifier">@options</span>.require || []).each <span class="Statement">do</span> |<span class="Identifier">path</span>|
        <span class="PreProc">require</span> path
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Merge all the specified configuration data into one mapping.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">merge_configurations</span>
      configurations = <span class="Identifier">@options</span>.configuration || []
      <span class="Identifier">@configuration</span> = configurations.reduce(<span class="Identifier">@configuration</span>) <span class="Statement">do</span> |<span class="Identifier">configuration</span>, <span class="Identifier">name_or_path</span>|
        named_configuration = load_configuration(name_or_path)
        configuration.deep_merge(named_configuration)
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Load a configuration either from the available builtin data or from a disk
file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">load_configuration</span>(name_or_path)
      <span class="Statement">return</span> <span class="Type">YAML</span>.load_file(name_or_path) <span class="Statement">if</span> <span class="Type">File</span>.exist?(name_or_path)
      name, arguments = name_or_path.split(<span class="Special">'</span><span class="Constant">:</span><span class="Special">'</span>)
      value = configuration_value(name, arguments)
      value = value.call(*arguments) <span class="Statement">unless</span> <span class="Type">Hash</span> === value
      <span class="Statement">return</span> value
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Compute the value of a named built-in configuration.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">configuration_value</span>(name, arguments)
      <span class="Statement">begin</span>
        value = <span class="Type">Codnar</span>::<span class="Type">Configuration</span>.const_get(name.upcase)
        <span class="Statement">return</span> value <span class="Statement">if</span> value
      <span class="Statement">rescue</span>
        value = <span class="Constant">nil</span>
      <span class="Statement">end</span>
      <span class="Identifier">$stderr</span>.puts(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: Configuration: </span><span class="Special">#{</span>name<span class="Special">}</span><span class="Constant"> is neither a disk file nor a known configuration</span><span class="Special">&quot;</span>)
      <span class="Statement">exit</span>(<span class="Constant">1</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print all the collected errors.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_errors</span>
      <span class="Identifier">@errors</span>.each <span class="Statement">do</span> |<span class="Identifier">error</span>|
        <span class="Identifier">$stderr</span>.puts(error)
      <span class="Statement">end</span>
      <span class="Statement">return</span> <span class="Identifier">@errors</span>.size
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Exit the application, unless we are running inside a test.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">exit</span>(status)
      <span class="Type">Kernel</span>.exit(status) <span class="Statement">unless</span> <span class="Identifier">@is_test</span>
      <span class="Statement">raise</span> <span class="Type">ExitException</span>.new(status)
    <span class="PreProc">end</span>

  end

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Exception used to exit when running inside tests.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">ExitException</span> &lt; <span class="Type">Exception</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The exit status.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="Statement">attr_reader</span> <span class="Constant">:status</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a new exception to indicate exiting the program with some status.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>(status)
      <span class="Identifier">@status</span> = status
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<p>
To invoke an application in tests in a controlled way, we need to preserve the
state of certain global variables around the invocation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-globals-rb">
<span>lib/codnar/globals.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Save and restore the global variables when running an application inside a
test.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Globals</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run some code without affecting the global state.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">without_changes</span>(&amp;block)
      state = <span class="Type">Globals</span>.new
      <span class="Statement">begin</span>
        <span class="Statement">return</span> block.call
      <span class="Statement">ensure</span>
        state.restore
      <span class="Statement">end</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Restore the relevant global variables.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">restore</span>
      <span class="Identifier">$stdin</span> = <span class="Type">Globals</span>.restore_file(<span class="Identifier">$stdin</span>, <span class="Identifier">@original_stdin</span>)
      <span class="Identifier">$stdout</span> = <span class="Type">Globals</span>.restore_file(<span class="Identifier">$stdout</span>, <span class="Identifier">@original_stdout</span>)
      <span class="Identifier">$stderr</span> = <span class="Type">Globals</span>.restore_file(<span class="Identifier">$stderr</span>, <span class="Identifier">@original_stderr</span>)
      <span class="Identifier">ARGV</span>.replace(<span class="Identifier">@original_argv</span>)
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Take a snapshot of the relevant global variables.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">initialize</span>
      <span class="Identifier">@original_stdin</span> = <span class="Identifier">$stdin</span>
      <span class="Identifier">@original_stdout</span> = <span class="Identifier">$stdout</span>
      <span class="Identifier">@original_stderr</span> = <span class="Identifier">$stderr</span>
      <span class="Identifier">@original_argv</span> = <span class="Identifier">ARGV</span>.dup
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Restore a specific global file variable to its original state.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">restore_file</span>(current, original)
      current.close <span class="Statement">unless</span> current == original
      <span class="Statement">return</span> original
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h4>Application for splitting files</h4>
<p>
Here is a simple test demonstrating invoking the command-line application for
splitting files:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-run-split-rb">
<span>test/run_split.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running the Split Codnar Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestRunSplit &lt; TestWithFakeFS

    def test_print_help
      Application.with_argv(%w(-h -o stdout)) { Split.new(true).run }.should == 0
      help = File.read(&quot;stdout&quot;)
      [ &quot;codnar-split&quot;, &quot;OPTIONS&quot;, &quot;DESCRIPTION&quot; ].each { |text| help.should.include?(text) }
    end

    def test_run_split
      File.open(&quot;input&quot;, &quot;w&quot;) { |file| file.puts(&quot;&lt;foo&gt;&quot;) }
      Application.with_argv(%w(-o stdout input)) { Split.new(true).run }.should == 0
      YAML.load_file(&quot;stdout&quot;).should == [ {
        &quot;name&quot; =&gt; &quot;input&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;input&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;html&quot; =&gt; &quot;&lt;foo&gt;&quot;,
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
      } ]
    end

    def test_run_split_no_file
      Application.with_argv(%w(-e stderr)) { Split.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: No input file to split\n&quot;
    end

    def test_run_split_many_file
      Application.with_argv(%w(-e stderr one two)) { Split.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Too many input files to split\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-split-rb">
<span>lib/codnar/split.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split application.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Split</span> &lt; <span class="Type">Application</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the weaving Codnar application, returning its status.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">run</span>
      <span class="Statement">super</span> { split }
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Parse the command line options of the program.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">parse_options</span>
      <span class="Statement">super</span>
      <span class="Statement">case</span> <span class="Identifier">ARGV</span>.size
      <span class="Statement">when</span> <span class="Constant">1</span> <span class="Statement">then</span> <span class="Statement">return</span>
      <span class="Statement">when</span> <span class="Constant">0</span> <span class="Statement">then</span> <span class="Identifier">$stderr</span>.puts(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: No input file to split</span><span class="Special">&quot;</span>)
      <span class="Statement">else</span> <span class="Identifier">$stderr</span>.puts(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: Too many input files to split</span><span class="Special">&quot;</span>)
      <span class="Statement">end</span>
      <span class="Statement">exit</span>(<span class="Constant">1</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Split the specified input file into chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">split</span>
      <span class="Identifier">@configuration</span> = <span class="Type">Codnar</span>::<span class="Type">Configuration</span>::<span class="Type">SPLIT_HTML_DOCUMENTATION</span> <span class="Statement">if</span> <span class="Identifier">@configuration</span> == {}
      splitter = <span class="Type">Splitter</span>.new(<span class="Identifier">@errors</span>, <span class="Identifier">@configuration</span>)
      print(splitter.chunks(<span class="Identifier">ARGV</span>[<span class="Constant">0</span>]).to_yaml)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message before the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help_before_options</span>
      print(&lt;&lt;-<span class="Special">EOF</span>.unindent)
<span class="Constant">        codnar-split - Split documentation or code files to chunks.</span>

<span class="Constant">      </span><span class="Special">EOF</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message after the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help_after_options</span>
      print(&lt;&lt;-<span class="Special">EOF</span>.unindent(<span class="Constant">2</span>))
<span class="Constant">          &lt;path&gt;                               Documentation or code file to split.</span>

<span class="Constant">        DESCRIPTION:</span>

<span class="Constant">          Split the documentation of file into chunks that are printed in YAML format to</span>
<span class="Constant">          the output (to be read by codnar-weave). Many file formats can be split</span>
<span class="Constant">          depending on the specified configuration. The default configuration is called</span>
<span class="Constant">          SPLIT_HTML_DOCUMENTATION, and it preserves the whole file as a single formatted</span>
<span class="Constant">          HTML documentation chunk. This isn't very useful.</span>

<span class="Constant">          The configuration needs to specify a set of line classification patterns,</span>
<span class="Constant">          parsing states and pattern-based transitions between them, the initial state,</span>
<span class="Constant">          and expressions for formatting classified lines to HTML. See the Codnar</span>
<span class="Constant">          documentation for details.</span>
<span class="Constant">      </span><span class="Special">EOF</span>
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the actual command-line application script:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="bin-codnar-split">
<span>bin/codnar-split</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">#!/bin/ruby -w</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar</span><span class="Special">&quot;</span>

<span class="Statement">exit</span> <span class="Type">Codnar</span>::<span class="Type">Split</span>.new.run
</pre>
</div>
</div>
</p>
<h4>Application for weaving chunks</h4>
<p>
Here is a simple test demonstrating invoking the command-line application for
weaving chunk to HTML:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-run-weave-rb">
<span>test/run_weave.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test running the Weave Codnar Application.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestRunWeave &lt; TestWithFakeFS

    def test_print_help
      Application.with_argv(%w(-h -o stdout)) { Weave.new(true).run }.should == 0
      help = File.read(&quot;stdout&quot;)
      [ &quot;codnar-weave&quot;, &quot;OPTIONS&quot;, &quot;DESCRIPTION&quot; ].each { |text| help.should.include?(text) }
    end

    ROOT_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;root&quot;,
      &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;root&quot;, &quot;line&quot; =&gt; 1 } ],
      &quot;html&quot; =&gt; &quot;Root\n&lt;embed src='included' type='x-codnar/include'/&gt;\n&quot;
    } ]

    INCLUDED_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;included&quot;,
      &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;included&quot;, &quot;line&quot; =&gt; 1 } ],
      &quot;html&quot; =&gt; &quot;Included&quot;
    } ]

    def test_run_weave
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(ROOT_CHUNKS.to_yaml) }
      File.open(&quot;included&quot;, &quot;w&quot;) { |file| file.write(INCLUDED_CHUNKS.to_yaml) }
      Application.with_argv(%w(-o stdout root included)) { Weave.new(true).run }.should == 0
      File.read(&quot;stdout&quot;).should == &quot;Root\nIncluded\n&quot;
    end

    def test_run_weave_missing_chunk
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(ROOT_CHUNKS.to_yaml) }
      Application.with_argv(%w(-e stderr -o stdout root)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Missing chunk: included in file: root\n&quot;
    end

    def test_run_weave_unused_chunk
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(ROOT_CHUNKS.to_yaml) }
      File.open(&quot;included&quot;, &quot;w&quot;) { |file| file.write(INCLUDED_CHUNKS.to_yaml) }
      Application.with_argv(%w(-e stderr -o stdout included root)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Unused chunk: root in file: root at line: 1\n&quot;
    end

    def test_run_weave_no_chunks
      Application.with_argv(%w(-e stderr)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: No chunk files to weave\n&quot;
    end

    FILE_CHUNKS = [ {
      &quot;name&quot; =&gt; &quot;root&quot;,
      &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;root&quot;, &quot;line&quot; =&gt; 1 } ],
      &quot;html&quot; =&gt; &quot;Root\n&lt;embed src='included.file' type='x-codnar/file'/&gt;\n&quot;
    } ]

    def test_run_weave_missing_file
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(FILE_CHUNKS.to_yaml) }
      Application.with_argv(%w(-e stderr -o stdout root)) { Weave.new(true).run }.should == 1
      File.read(&quot;stderr&quot;).should == &quot;#{$0}: Reading file: included.file exception: No such file or directory - No such file or directory -  in file: root at line: 1\n&quot;
      File.read(&quot;stdout&quot;).should == &quot;Root\nFILE: included.file EXCEPTION: No such file or directory - No such file or directory - \n&quot;
    end

    def test_run_weave_existing_file
      File.open(&quot;root&quot;, &quot;w&quot;) { |file| file.write(FILE_CHUNKS.to_yaml) }
      File.open(&quot;included.file&quot;, &quot;w&quot;) { |file| file.write(&quot;included file\n&quot;) }
      Application.with_argv(%w(-e stderr -o stdout root)) { Weave.new(true).run }.should == 0
      File.read(&quot;stdout&quot;).should == &quot;Root\nincluded file\n&quot;
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
Here is the implementation:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-weave-rb">
<span>lib/codnar/weave.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave application.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">class</span> <span class="Type">Weave</span> &lt; <span class="Type">Application</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the weaving Codnar application, returning its status.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">run</span>
      <span class="Statement">super</span> { weave }
    <span class="PreProc">end</span>

  <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Parse the command line options of the program.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">parse_options</span>
      <span class="Statement">super</span>
      <span class="Statement">return</span> <span class="Statement">if</span> <span class="Identifier">ARGV</span>.size &gt; <span class="Constant">0</span>
      <span class="Identifier">$stderr</span>.puts(<span class="Special">&quot;</span><span class="Special">#{</span><span class="Identifier">$0</span><span class="Special">}</span><span class="Constant">: No chunk files to weave</span><span class="Special">&quot;</span>)
      <span class="Statement">exit</span>(<span class="Constant">1</span>)
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Weave all the chunks together to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">weave</span>
      <span class="Identifier">@configuration</span> = <span class="Type">Codnar</span>::<span class="Type">Configuration</span>::<span class="Type">WEAVE_INCLUDE</span> <span class="Statement">if</span> <span class="Identifier">@configuration</span> == {}
      weaver = <span class="Type">Weaver</span>.new(<span class="Identifier">@errors</span>, <span class="Identifier">ARGV</span>, <span class="Identifier">@configuration</span>)
      puts(weaver.weave(<span class="Special">&quot;</span><span class="Constant">include</span><span class="Special">&quot;</span>))
      weaver.collect_unused_chunk_errors
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message before the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help_before_options</span>
      print(&lt;&lt;-<span class="Special">EOF</span>.unindent)
<span class="Constant">        codnar-weave - Weave documentation chunks to a single HTML.</span>

<span class="Constant">      </span><span class="Special">EOF</span>
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Print the part of the help message after the standard options.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Identifier">print_help_after_options</span>
      print(&lt;&lt;-<span class="Special">EOF</span>.unindent(<span class="Constant">2</span>))
<span class="Constant">          &lt;main-path&gt; &lt;chunks-path&gt;...         Chunk files to weave together.</span>

<span class="Constant">        DESCRIPTION:</span>

<span class="Constant">          Weave chunks in all chunk files (from codnar-split) to a single HTML that is</span>
<span class="Constant">          printed to the output. The first file is the main documentation file that is</span>
<span class="Constant">          expected to include all the rest of the chunks via directives of the format:</span>

<span class="Constant">            &lt;embed src=&quot;chunk-name&quot; type=&quot;x-codnar/template-name&quot;&gt;&lt;/embed&gt;</span>

<span class="Constant">          Where the template-name is a key in the configuration, whose value is an ERB</span>
<span class="Constant">          template for embedding the named chunk into the documentation.</span>

<span class="Constant">          If no configuration is specified, the WEAVE_INCLUDE configuration is assumed.</span>
<span class="Constant">          This configuration contains a single template named &quot;include&quot;, which simply</span>
<span class="Constant">          includes the named chunk into the generated HTML.</span>
<span class="Constant">      </span><span class="Special">EOF</span>
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<p>
And here is the actual command-line application script:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="bin-codnar-weave">
<span>bin/codnar-weave</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">#!/bin/ruby -w</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar</span><span class="Special">&quot;</span>

<span class="Statement">exit</span> <span class="Type">Codnar</span>::<span class="Type">Weave</span>.new.run
</pre>
</div>
</div>
</p>
<h3>Rake Integration</h3>
<p>
For Ruby projects (or any other project using Rake), it is also possible to
invoke Codnar using Rake tasks. Here is a simple test demonstrating using the
Rake tasks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="test-rake-tasks-rb">
<span>test/rake_tasks.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
require &quot;codnar/rake&quot;
require &quot;test/spec&quot;
require &quot;with_fakefs&quot;

module Codnar

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Test rake tasks.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  class TestRakeTasks &lt; TestWithFakeFS

    def setup
      super
      @original_rake = ::Rake.application
      @rake = ::Rake::Application.new
      ::Rake.application = @rake
    end

    def teardown
      super
      ::Rake.application = @original_rake
    end

    def test_default
      run_rake
      test_results
    end

  protected

    def run_rake
      File.open(&quot;foo&quot;, &quot;w&quot;) { |file| file.puts(&quot;foo&quot;) }
      Rake::SplitTask.new([ &quot;foo&quot; ], [])
      Rake::WeaveTask.new(&quot;foo&quot;, [])
      @rake[&quot;codnar&quot;].invoke
    end

    def test_results
      chunk_file = Rake.chunks_dir + &quot;/foo&quot;
      YAML.load_file(chunk_file).should == [ {
        &quot;html&quot; =&gt; &quot;foo&quot;,
        &quot;name&quot; =&gt; &quot;foo&quot;,
        &quot;locations&quot; =&gt; [ { &quot;file&quot; =&gt; &quot;foo&quot;, &quot;line&quot; =&gt; 1 } ],
        &quot;containers&quot; =&gt; [],
        &quot;contained&quot; =&gt; [],
      } ]
      File.read(&quot;codnar.html&quot;).should == &quot;foo\n&quot;
      Rake.chunk_files.should == [ chunk_file ]
    end

  end

end
</pre>
</div>
</div>
</p>
<p>
To use these tasks in a Rakefile, one needs to <code>require 'codnar/rake'</code>. The
code implements a singleton that holds the global state shared between tasks:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rake-rb">
<span>lib/codnar/rake.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rake</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rake/tasklib</span><span class="Special">&quot;</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/rake/split_task</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/rake/weave_task</span><span class="Special">&quot;</span>

<span class="PreProc">module</span> <span class="Type">Codnar</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This module contains all the Codnar Rake tasks code.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="PreProc">module</span> <span class="Type">Rake</span>

    <span class="PreProc">class</span> &lt;&lt; <span class="Constant">self</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The root folder to store all chunk files under.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="Statement">attr_accessor</span> <span class="Constant">:chunks_dir</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
The list of split chunk files for later weaving.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="Statement">attr_accessor</span> <span class="Constant">:chunk_files</span>

    end

    <span class="Type">Rake</span>.chunk_files = []
    <span class="Type">Rake</span>.chunks_dir = <span class="Special">&quot;</span><span class="Constant">chunks</span><span class="Special">&quot;</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Compute options for invoking an application.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">application_options</span>(output, configurations)
      options = [ <span class="Special">&quot;</span><span class="Constant">-o</span><span class="Special">&quot;</span>, output ]
      options += [ <span class="Special">&quot;</span><span class="Constant">-c</span><span class="Special">&quot;</span> ] + configurations.map { |<span class="Identifier">configuration</span>| configuration.to_s } + [ <span class="Special">&quot;</span><span class="Constant">--</span><span class="Special">&quot;</span> ] <span class="Statement">if</span> configurations.size &gt; <span class="Constant">0</span>
      <span class="Statement">return</span> options
    <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Return the list of actual configuration files (as opposed to names of
built-in configurations) for use as dependencies.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">configuration_files</span>(configurations)
      <span class="Statement">return</span> configurations.find_all { |<span class="Identifier">configuration</span>| <span class="Type">File</span>.exists?(configuration.to_s) }
    <span class="PreProc">end</span>

  end

end
</pre>
</div>
</div>
</p>
<h4>Task for splitting files</h4>
<p>
To split one or more files to chunks, create a new SplitTask. Multiple such
tasks may be created; this is required if different files need to be split
using different configurations.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rake-split-task-rb">
<span>lib/codnar/rake/split_task.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

  <span class="PreProc">module</span> <span class="Type">Rake</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A Rake task for splitting source files to chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">class</span> <span class="Type">SplitTask</span> &lt; ::<span class="Type">Rake</span>::<span class="Type">TaskLib</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a new Rake task for splitting source files to chunks. Each of the
specified disk files is split using the specified set of configurations.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">initialize</span>(paths, configurations)
        <span class="Identifier">@configurations</span> = configurations
        paths.each <span class="Statement">do</span> |<span class="Identifier">path</span>|
          define_tasks(path)
        <span class="Statement">end</span>
      <span class="PreProc">end</span>

    <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the tasks for splitting a single source file to chunks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">define_tasks</span>(path)
        output = <span class="Type">Rake</span>.chunks_dir + <span class="Special">&quot;</span><span class="Constant">/</span><span class="Special">&quot;</span> + path
        define_split_file_task(path, output)
        <span class="Type">SplitTask</span>.define_common_tasks
        <span class="Type">SplitTask</span>.connect_common_tasks(output)
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the actual task for splitting the source file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">define_split_file_task</span>(path, output)
        ::<span class="Type">Rake</span>::<span class="Type">FileTask</span>.define_task(output =&gt; [ path ] + <span class="Type">Rake</span>.configuration_files(<span class="Identifier">@configurations</span>)) <span class="Statement">do</span>
          run_split_application(path, output)
        <span class="Statement">end</span>
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the Split application for a single source file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">run_split_application</span>(path, output)
        options = <span class="Type">Rake</span>.application_options(output, <span class="Identifier">@configurations</span>)
        options &lt;&lt; path
        <span class="Type">Application</span>.with_argv(options) { <span class="Type">Split</span>.new.run }
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define common Rake split tasks. This method may be invoked several times,
only the first invocation actually defined the tasks. The common tasks are
codnar_split (for splitting all the source files) and clean_codnar (for
getting rid of the chunks directory).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">define_common_tasks</span>
        <span class="Identifier">@defined_common_tasks</span> ||= <span class="Type">SplitTask</span>.create_common_tasks
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Actually create common Rake split tasks.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">create_common_tasks</span>
        desc <span class="Special">&quot;</span><span class="Constant">Split all files into chunks</span><span class="Special">&quot;</span>
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Special">&quot;</span><span class="Constant">codnar_split</span><span class="Special">&quot;</span>)
        desc <span class="Special">&quot;</span><span class="Constant">Clean all split chunks</span><span class="Special">&quot;</span>
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Special">&quot;</span><span class="Constant">clean_codnar</span><span class="Special">&quot;</span>) { rm_rf(<span class="Type">Rake</span>.chunks_dir) }
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Constant">:clean</span> =&gt; <span class="Special">&quot;</span><span class="Constant">clean_codnar</span><span class="Special">&quot;</span>)
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Connect the task for splitting a single source file to the common task of
splitting all source files.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Constant">self</span>.<span class="Identifier">connect_common_tasks</span>(output)
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Special">&quot;</span><span class="Constant">codnar_split</span><span class="Special">&quot;</span> =&gt; output)
        <span class="Type">Rake</span>::chunk_files &lt;&lt; output
      <span class="PreProc">end</span>

    end

  end

end
</pre>
</div>
</div>
</p>
<h4>Task for weaving chunks</h4>
<p>
To weave the chunks together, create a single WeaveTask.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-rake-weave-task-rb">
<span>lib/codnar/rake/weave_task.rb</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>

  <span class="PreProc">module</span> <span class="Type">Rake</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>    </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
A Rake task for weaving chunks to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
    <span class="PreProc">class</span> <span class="Type">WeaveTask</span> &lt; ::<span class="Type">Rake</span>::<span class="Type">TaskLib</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Create a Rake task for weaving chunks to a single HTML. The root source
file is expected to embed all the chunks into the output HTML. The chunks
are loaded from the results of all the previous created SplitTask-s.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">initialize</span>(root, configurations, output = <span class="Special">&quot;</span><span class="Constant">codnar.html</span><span class="Special">&quot;</span>)
        <span class="Identifier">@root</span> = <span class="Type">Rake</span>.chunks_dir + <span class="Special">&quot;</span><span class="Constant">/</span><span class="Special">&quot;</span> + root
        <span class="Identifier">@output</span> = output
        <span class="Identifier">@configurations</span> = configurations
        define_tasks
      <span class="PreProc">end</span>

    <span class="Statement">protected</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the tasks for weaving the chunks to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">define_tasks</span>
        define_weave_task
        connect_common_tasks
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Define the actual task for weaving the chunks to a single HTML.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">define_weave_task</span>
        desc <span class="Special">&quot;</span><span class="Constant">Weave chunks into HTML</span><span class="Special">&quot;</span> <span class="Statement">unless</span> ::<span class="Type">Rake</span>.application.last_comment
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Special">&quot;</span><span class="Constant">codnar_weave</span><span class="Special">&quot;</span> =&gt; <span class="Identifier">@output</span>)
        ::<span class="Type">Rake</span>::<span class="Type">FileTask</span>.define_task(<span class="Identifier">@output</span> =&gt; <span class="Type">Rake</span>.chunk_files + <span class="Type">Rake</span>.configuration_files(<span class="Identifier">@configurations</span>)) <span class="Statement">do</span>
          run_weave_application
        <span class="Statement">end</span>
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Run the Weave application for a single source file.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">run_weave_application</span>
        options = <span class="Type">Rake</span>.application_options(<span class="Identifier">@output</span>, <span class="Identifier">@configurations</span>)
        options &lt;&lt; <span class="Identifier">@root</span>
        options += <span class="Type">Rake</span>.chunk_files.reject { |<span class="Identifier">chunk</span>| chunk == <span class="Identifier">@root</span> }
        <span class="Type">Application</span>.with_argv(options) { <span class="Type">Weave</span>.new.run }
      <span class="PreProc">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>      </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Connect the task for cleaning up after weaving (clobber_codnar) to the
common task of cleaning up everything (clobber).
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
      <span class="PreProc">def</span> <span class="Identifier">connect_common_tasks</span>
        desc <span class="Special">&quot;</span><span class="Constant">Build the code narrative HTML</span><span class="Special">&quot;</span>
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Constant">:codnar</span> =&gt; <span class="Special">&quot;</span><span class="Constant">codnar_weave</span><span class="Special">&quot;</span>)
        desc <span class="Special">&quot;</span><span class="Constant">Remove woven HTML documentation</span><span class="Special">&quot;</span>
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Special">&quot;</span><span class="Constant">clobber_codnar</span><span class="Special">&quot;</span>) { rm_rf(<span class="Identifier">@output</span>) }
        ::<span class="Type">Rake</span>::<span class="Type">Task</span>.define_task(<span class="Constant">:clobber</span> =&gt; <span class="Special">&quot;</span><span class="Constant">clobber_codnar</span><span class="Special">&quot;</span>)
      <span class="PreProc">end</span>

    end

  end

end
</pre>
</div>
</div>
</p>
<h2>Building the Codnar gem</h2>
<p>
The following Rakefile is in charge of building the gem, with the help of some
tools described below.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="rakefile">
<span>Rakefile</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="Identifier">$:</span> &lt;&lt; <span class="Type">File</span>.dirname(<span class="Constant">__FILE__</span>) + <span class="Special">&quot;</span><span class="Constant">/lib</span><span class="Special">&quot;</span>

<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">codnar/rake</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rake/clean</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rake/gempackagetask</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rake/rdoctask</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rake/testtask</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">rcov/rcovtask</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">reek/rake/task</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">roodi</span><span class="Special">&quot;</span>
<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">roodi_task</span><span class="Special">&quot;</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Overall tasks
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

task <span class="Constant">:default</span> =&gt; <span class="Constant">:all</span>

desc <span class="Special">&quot;</span><span class="Constant">Verify, document, package</span><span class="Special">&quot;</span>
task <span class="Constant">:all</span> =&gt; [ <span class="Constant">:verify</span>, <span class="Constant">:doc</span>, <span class="Constant">:gem</span> ]

desc <span class="Special">&quot;</span><span class="Constant">Generate all documentation</span><span class="Special">&quot;</span>
task <span class="Constant">:doc</span> =&gt; [ <span class="Constant">:rdoc</span>, <span class="Constant">:codnar</span> ]

desc <span class="Special">&quot;</span><span class="Constant">Test, coverage, analyze code</span><span class="Special">&quot;</span>
task <span class="Constant">:verify</span> =&gt; [ <span class="Constant">:rcov</span>, <span class="Constant">:reek</span>, <span class="Constant">:roodi</span>, <span class="Constant">:flay</span>, <span class="Constant">:saikuro</span> ]

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Source file lists
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

patterns = {
  <span class="Special">&quot;</span><span class="Constant">bin</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">bin/*</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">css</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">doc/*.css</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">doc</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">doc/*</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">javascript</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">doc/*.js</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">lib</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">lib/**/*.rb</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">test</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">test/*.rb</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">testlib</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">test/lib/*.rb</span><span class="Special">&quot;</span>,
  <span class="Special">&quot;</span><span class="Constant">tools</span><span class="Special">&quot;</span> =&gt; <span class="Special">&quot;</span><span class="Constant">tools/*</span><span class="Special">&quot;</span>,
}
files = patterns.merge(patterns) { |<span class="Identifier">key</span>, <span class="Identifier">pattern</span>| <span class="Type">FileList</span>[pattern] }


</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Gem specification and packaging
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

spec = <span class="Type">Gem</span>::<span class="Type">Specification</span>.new <span class="Statement">do</span> |<span class="Identifier">s</span>|

  s.name = <span class="Special">&quot;</span><span class="Constant">codnar</span><span class="Special">&quot;</span>
  s.version = <span class="Type">Codnar</span>::<span class="Type">VERSION</span>

  s.homepage = <span class="Special">&quot;</span><span class="Constant"><a href="http://codnar.rubygems.org">http://codnar.rubygems.org</a></span><span class="Special">&quot;</span>

  s.summary = <span class="Special">&quot;</span><span class="Constant">Code narrator - an inverse literate programming tool.</span><span class="Special">&quot;</span>
  s.description = (&lt;&lt;-<span class="Special">EOF</span>).gsub(<span class="Special">/</span><span class="Special">^</span><span class="Special">\s</span><span class="Special">+</span><span class="Special">/</span>, <span class="Special">&quot;&quot;</span>).chomp.gsub(<span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant"> </span><span class="Special">&quot;</span>)
<span class="Constant">    Code Narrator (Codnar) is an inverse literate programming tool. It splits the</span>
<span class="Constant">    source files into &quot;chunks&quot; (including structured comments) and weaves them back</span>
<span class="Constant">    into a narrative that describes the overall system.</span>
<span class="Constant">  </span><span class="Special">EOF</span>

  s.author = <span class="Special">&quot;</span><span class="Constant">Oren Ben-Kiki</span><span class="Special">&quot;</span>
  s.email = <span class="Special">&quot;</span><span class="Constant">rubygems-oren@ben-kiki.org</span><span class="Special">&quot;</span>

  s.requirements &lt;&lt; <span class="Special">&quot;</span><span class="Constant">GVim for syntax highlighting.</span><span class="Special">&quot;</span>

  s.add_dependency(<span class="Special">&quot;</span><span class="Constant">andand</span><span class="Special">&quot;</span>)
  s.add_dependency(<span class="Special">&quot;</span><span class="Constant">getoptions</span><span class="Special">&quot;</span>)
  s.add_dependency(<span class="Special">&quot;</span><span class="Constant">rake</span><span class="Special">&quot;</span>)
  s.add_dependency(<span class="Special">&quot;</span><span class="Constant">rdiscount</span><span class="Special">&quot;</span>)
  s.add_dependency(<span class="Special">&quot;</span><span class="Constant">rdoc</span><span class="Special">&quot;</span>)

  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">fakefs</span><span class="Special">&quot;</span>)
  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">flay</span><span class="Special">&quot;</span>)
  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">rcov</span><span class="Special">&quot;</span>)
  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">reek</span><span class="Special">&quot;</span>)
  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">roodi</span><span class="Special">&quot;</span>)
  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">Saikuro</span><span class="Special">&quot;</span>)
  s.add_development_dependency(<span class="Special">&quot;</span><span class="Constant">test-spec</span><span class="Special">&quot;</span>)

  s.files = files.lib + files.bin + files.doc
  s.test_files = files.test + files.testlib
  s.executables = files.bin.map { |<span class="Identifier">path</span>| path.sub(<span class="Special">&quot;</span><span class="Constant">bin/</span><span class="Special">&quot;</span>, <span class="Special">&quot;&quot;</span>) }

  s.extra_rdoc_files = [ <span class="Special">&quot;</span><span class="Constant">README.rdoc</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">LICENSE</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">ChangeLog</span><span class="Special">&quot;</span> ]
  s.rdoc_options &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--title</span><span class="Special">&quot;</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">Code narrator </span><span class="Special">#{</span>s.version<span class="Special">}</span><span class="Special">&quot;</span>
  s.rdoc_options &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--main</span><span class="Special">&quot;</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">README.rdoc</span><span class="Special">&quot;</span>
  s.rdoc_options &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--line-numbers</span><span class="Special">&quot;</span>
  s.rdoc_options &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--all</span><span class="Special">&quot;</span>
  s.rdoc_options &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--quiet</span><span class="Special">&quot;</span>

<span class="Statement">end</span>

<span class="Type">Rake</span>::<span class="Type">GemPackageTask</span>.new(spec) { |<span class="Identifier">package</span>| }

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Unit tests
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

<span class="Type">Rcov</span>::<span class="Type">RcovTask</span>.new(<span class="Special">&quot;</span><span class="Constant">rcov</span><span class="Special">&quot;</span>) <span class="Statement">do</span> |<span class="Identifier">task</span>|
  task.output_dir = <span class="Special">&quot;</span><span class="Constant">rcov</span><span class="Special">&quot;</span>
  task.test_files = files.test
  task.libs &lt;&lt; <span class="Special">&quot;</span><span class="Constant">lib</span><span class="Special">&quot;</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">test/lib</span><span class="Special">&quot;</span>
  task.rcov_opts &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--failure-threshold</span><span class="Special">&quot;</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">100</span><span class="Special">&quot;</span>
  (files.lib + files.test + files.testlib).each <span class="Statement">do</span> |<span class="Identifier">file</span>|
    task.rcov_opts &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--include-file</span><span class="Special">&quot;</span> &lt;&lt; file
  <span class="Statement">end</span>
<span class="Statement">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Code analysis
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

<span class="Type">Reek</span>::<span class="Type">Rake</span>::<span class="Type">Task</span>.new <span class="Statement">do</span> |<span class="Identifier">task</span>|
  task.reek_opts &lt;&lt; <span class="Special">&quot;</span><span class="Constant">--quiet</span><span class="Special">&quot;</span>
  task.source_files = files.lib + files.bin + files.test + files.testlib
<span class="Statement">end</span>

<span class="Type">RoodiTask</span>.new <span class="Statement">do</span> |<span class="Identifier">task</span>|
  task.patterns = patterns.values
  task.config = <span class="Special">&quot;</span><span class="Constant">roodi.config</span><span class="Special">&quot;</span>
<span class="Statement">end</span>

<span class="Type">Rake</span>::<span class="Type">TestTask</span>.new(<span class="Special">&quot;</span><span class="Constant">test</span><span class="Special">&quot;</span>) <span class="Statement">do</span> |<span class="Identifier">task</span>|
  task.test_files = files.test
  task.libs &lt;&lt; <span class="Special">&quot;</span><span class="Constant">lib</span><span class="Special">&quot;</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">test/lib</span><span class="Special">&quot;</span>
<span class="Statement">end</span>

desc <span class="Special">&quot;</span><span class="Constant">Check for duplicated code with Flay</span><span class="Special">&quot;</span>
task <span class="Constant">:flay</span> <span class="Statement">do</span>
  result = <span class="Type">IO</span>.popen(<span class="Special">&quot;</span><span class="Constant">flay lib</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">r</span><span class="Special">&quot;</span>).read.chomp
  <span class="Statement">unless</span> result == <span class="Special">&quot;</span><span class="Constant">Total score (lower is better) = 0</span><span class="Special">\n</span><span class="Special">&quot;</span>
    print result
    <span class="Statement">raise</span> <span class="Special">&quot;</span><span class="Constant">Flay found code duplication.</span><span class="Special">&quot;</span>
  <span class="Statement">end</span>
<span class="Statement">end</span>

<span class="Type">CLOBBER</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">saikuro</span><span class="Special">&quot;</span>

desc <span class="Special">&quot;</span><span class="Constant">Check for complex code with Saikuro</span><span class="Special">&quot;</span>
task <span class="Constant">:saikuro</span> <span class="Statement">do</span>
  system(<span class="Special">&quot;</span><span class="Constant">saikuro -c -t -i lib -y 0 -e 10 -o saikuro/ &gt; /dev/null</span><span class="Special">&quot;</span>)
  result = <span class="Type">File</span>.read(<span class="Special">&quot;</span><span class="Constant">saikuro/index_cyclo.html</span><span class="Special">&quot;</span>)
  <span class="Statement">if</span> result.include?(<span class="Special">&quot;</span><span class="Constant">Errors and Warnings</span><span class="Special">&quot;</span>)
    <span class="Statement">raise</span> <span class="Special">&quot;</span><span class="Constant">Saikuro found complicated code.</span><span class="Special">&quot;</span>
  <span class="Statement">end</span>
<span class="Statement">end</span>

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Documentation
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>

<span class="Type">Rake</span>::<span class="Type">RDocTask</span>.new <span class="Statement">do</span> |<span class="Identifier">rdoc</span>|
  rdoc.rdoc_files &lt;&lt; <span class="Special">&quot;</span><span class="Constant">LICENSE</span><span class="Special">&quot;</span> &lt;&lt; <span class="Special">&quot;</span><span class="Constant">README.rdoc</span><span class="Special">&quot;</span>
  rdoc.rdoc_files += files.bin + files.lib + files.test + files.testlib
  rdoc.main = <span class="Special">&quot;</span><span class="Constant">README.rdoc</span><span class="Special">&quot;</span>
  rdoc.rdoc_dir = <span class="Special">&quot;</span><span class="Constant">rdoc</span><span class="Special">&quot;</span>
  rdoc.options = spec.rdoc_options
<span class="Statement">end</span>

codnar_configurations = [ <span class="Constant">:classify_shell_comments</span>, <span class="Constant">:format_rdoc_comments</span> ]
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(files.bin + files.lib + files.testlib + [ <span class="Special">&quot;</span><span class="Constant">Rakefile</span><span class="Special">&quot;</span>, <span class="Special">&quot;</span><span class="Constant">tools/codnar-changelog</span><span class="Special">&quot;</span> ],
                            codnar_configurations + [ <span class="Constant">:chunk_by_vim_regions</span>, <span class="Special">&quot;</span><span class="Constant">css_code_syntax:ruby</span><span class="Special">&quot;</span> ])
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(files.javascript, codnar_configurations + [ <span class="Special">&quot;</span><span class="Constant">css_code_syntax:javascript</span><span class="Special">&quot;</span> ])
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(files.css, codnar_configurations + [ <span class="Special">&quot;</span><span class="Constant">css_code_syntax:css</span><span class="Special">&quot;</span> ])
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(files.test + files.tools - [ <span class="Special">&quot;</span><span class="Constant">tools/codnar-changelog</span><span class="Special">&quot;</span> ], codnar_configurations)
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(spec.files.find_all { |<span class="Identifier">file</span>| file.end_with?(<span class="Special">&quot;</span><span class="Constant">.html</span><span class="Special">&quot;</span>) }, [ <span class="Constant">:split_html_documentation</span> ])
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(spec.files.find_all { |<span class="Identifier">file</span>| file.end_with?(<span class="Special">&quot;</span><span class="Constant">.rdoc</span><span class="Special">&quot;</span>) }, [ <span class="Constant">:split_rdoc_documentation</span> ])
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">SplitTask</span>.new(spec.files.find_all { |<span class="Identifier">file</span>| file.end_with?(<span class="Special">&quot;</span><span class="Constant">.markdown</span><span class="Special">&quot;</span>) }, [ <span class="Constant">:split_markdown_documentation</span> ])
<span class="Type">Codnar</span>::<span class="Type">Rake</span>::<span class="Type">WeaveTask</span>.new(<span class="Special">&quot;</span><span class="Constant">doc/root.html</span><span class="Special">&quot;</span>, [ <span class="Constant">:weave_include</span>, <span class="Constant">:weave_named_chunk_with_containers</span> ])
</pre>
</div>
</div>
</p>
<h3>Automatic gem version number</h3>
<p>
The gem version number is taken from the following tool, with combination with
a running version number extracted from <code>git</code>:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="tools-codnar-version">
<span>tools/codnar-version</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
#!/bin/sh

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Major and minor revision numbers.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
export MAJOR=0
export MINOR=1

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This is only reliable as long as one developer is doing commits on one
machine. Which, so far, is the case.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
export COMMIT=`git rev-list --all | wc -l`

</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This file makes the data available to the Ruby code.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
cat &lt;&lt;EOF | sed 's/\r//g'
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This module contains all the code narrator code.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
module Codnar
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This version number.
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
  VERSION = &quot;$MAJOR.$MINOR.$COMMIT&quot;
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Edit tools/codnar-version to update this file!
</p>
</div>
</td>
</tr>
</table>
<pre class='code'>
end
EOF
</pre>
</div>
</div>
</p>
<p>
And here is the current generated version file:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="lib-codnar-version-rb">
<span>lib/codnar/version.rb</span>
</a>
</div>
<div class="chunk html">
<table class='layout'>
<tr>
<td class='indentation'>
<pre></pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This module contains all the code narrator code.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
<span class="PreProc">module</span> <span class="Type">Codnar</span>
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
This version number.
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
  <span class="Type">VERSION</span> = <span class="Special">&quot;</span><span class="Constant">0.1.52</span><span class="Special">&quot;</span>
</pre>
<table class='layout'>
<tr>
<td class='indentation'>
<pre>  </pre>
</td>
<td class='html'>
<div class='rdoc comment markup'>
<p>
Edit tools/codnar-version to update this file!
</p>
</div>
</td>
</tr>
</table>
<pre class='ruby code syntax'>
end
</pre>
</div>
</div>
</p>
<h3>Automatic change log</h3>
<p>
A standard format change log file is maintained by the following tool:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="tools-codnar-changelog">
<span>tools/codnar-changelog</span>
</a>
</div>
<div class="chunk html">
<pre class='ruby code syntax'>
<span class="PreProc">#!/usr/bin/ruby</span>

subjects_by_id = {}
sorted_ids = []

log_lines = <span class="Special">`</span><span class="Constant">git log --pretty='format:%ci::%an &lt;%ae&gt;::%s'</span><span class="Special">`</span>

log_lines.each <span class="Statement">do</span> |<span class="Identifier">log_line</span>|
  date, author, subject = log_line.chomp.split(<span class="Special">&quot;</span><span class="Constant">::</span><span class="Special">&quot;</span>)
  date, time, zone = date.split(<span class="Special">&quot;</span><span class="Constant"> </span><span class="Special">&quot;</span>)
  id = <span class="Special">&quot;</span><span class="Special">#{</span>date<span class="Special">}</span><span class="Special">\t</span><span class="Special">#{</span>author<span class="Special">}</span><span class="Special">&quot;</span>
  sorted_ids &lt;&lt; id
  subjects_by_id[id] ||= []
  subjects_by_id[id] &lt;&lt; subject
<span class="Statement">end</span>

sorted_ids.uniq.each <span class="Statement">do</span> |<span class="Identifier">id</span>|
  subjects = subjects_by_id[id]
  puts <span class="Special">&quot;</span><span class="Special">#{</span>id<span class="Special">}</span><span class="Special">\n\n</span><span class="Special">&quot;</span>
  puts subjects.map { |<span class="Identifier">subject</span>| <span class="Special">&quot;</span><span class="Special">\t</span><span class="Constant">* </span><span class="Special">#{</span>subject<span class="Special">}</span><span class="Special">&quot;</span> }.join(<span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span>)
  puts <span class="Special">&quot;</span><span class="Special">\n</span><span class="Special">&quot;</span>
<span class="Statement">end</span>
</pre>
</div>
</div>
</p>
<h3>Automated commit procedure</h3>
<p>
The above two tools and the build process in general assumes that every commit
to <code>git</code> (on the main branch, anyway) is done by the following automated
procedure:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="tools-codnar-commit">
<span>tools/codnar-commit</span>
</a>
</div>
<div class="chunk html">
<pre class='code'>
#!/bin/sh
true \
&amp;&amp; git add . \
&amp;&amp; rake clobber \
&amp;&amp; rake verify \
&amp;&amp; git commit &quot;$@&quot; \
&amp;&amp; tools/codnar-version &gt; lib/codnar/version.rb \
&amp;&amp; git add lib/codnar/version.rb \
&amp;&amp; tools/codnar-changelog &gt; ChangeLog \
&amp;&amp; git add ChangeLog \
&amp;&amp; rake verify gem \
&amp;&amp; git commit --amend
</pre>
</div>
</div>
</p>
<h2>Formatting generated HTML</h2>
<p>
The generated HTML requires some tweaking to yield aesthetic, readable results.
This tweaking consists of using Javascript to generate a table of content, and
using CSS to make the HTML look better.
</p>
<h3>Javascript table of content</h3>
<p>
The following code is not very efficient or elegant but it does a basic job of
iunjecting a table of content into the generated HTML.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="doc-contents-js">
<span>doc/contents.js</span>
</a>
</div>
<div class="chunk html">
<pre class='javascript code syntax'>
<span class="Comment">/*</span>
<span class="Comment"> * Quick-and-dirty JS for inserting a table of content inside a DIV with the id</span>
<span class="Comment"> * &quot;contents&quot;. The table of content is a series of nested UL and LI elements,</span>
<span class="Comment"> * prefixed with an H1 containing the text &quot;0 Contents&quot;. This H1 comes in</span>
<span class="Comment"> * addition to the single static H1 expected by HTML best practices. It looks</span>
<span class="Comment"> * &quot;right&quot; and should not confuse search engines etc. since they do not execute</span>
<span class="Comment"> * Javascript code.</span>
<span class="Comment"> */</span>
<span class="Statement">if</span> (<span class="Statement">document</span>.getElementById) onload = <span class="Identifier">function</span> () <span class="Identifier">{</span>
  <span class="Identifier">var</span> contents = <span class="Statement">document</span>.getElementById(<span class="Constant">&quot;contents&quot;</span>);
  <span class="Identifier">var</span> lists = contents_lists();
  contents.appendChild(contents_header()); <span class="Comment">// TRICKY: Must be done after contents_lists().</span>
  contents.appendChild(lists);
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Create a table of contents H1.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> contents_header() <span class="Identifier">{</span>
  <span class="Identifier">var</span> h = <span class="Statement">document</span>.createElement(<span class="Constant">&quot;h1&quot;</span>);
  <span class="Identifier">var</span> text = <span class="Statement">document</span>.createTextNode(<span class="Constant">&quot;Contents&quot;</span>);
  h.appendChild(text);
  <span class="Statement">return</span> h;
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Create nested UL/LI lists for the table of content.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> contents_lists() <span class="Identifier">{</span>
  <span class="Identifier">var</span> container;
  <span class="Identifier">var</span> indices = <span class="Identifier">[]</span>;
  foreach_h_element(<span class="Identifier">function</span> (h, level) <span class="Identifier">{</span>
    container = pop_container(container, indices, level);
    container = push_container(container, indices, level);
    <span class="Identifier">var</span> id = indices.join(<span class="Constant">&quot;.&quot;</span>);
    container.appendChild(list_element(id, h));
    h.insertBefore(header_anchor(id), h.firstChild);
  <span class="Identifier">}</span>);
  <span class="Statement">return</span> pop_container(container, indices, 1);
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Apply a lambda to all H elements in the DOM. We skip the single H1 element;</span>
<span class="Comment"> * otherwise it would just have the index &quot;1&quot; which would be prefixed to all</span>
<span class="Comment"> * other headers.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> foreach_h_element(lambda) <span class="Identifier">{</span>
  <span class="Identifier">var</span> elements = <span class="Statement">document</span>.getElementsByTagName(<span class="Constant">&quot;*&quot;</span>);
  <span class="Statement">for</span> (<span class="Identifier">var</span> e <span class="Statement">in</span> elements) <span class="Identifier">{</span>
    <span class="Identifier">var</span> h = elements<span class="Identifier">[</span>e<span class="Identifier">]</span>;
    <span class="Statement">if</span> (!<span class="Constant">/^h[2-9]$/i</span>.test(h.tagName)) <span class="Statement">continue</span>;
    <span class="Identifier">var</span> level = h.tagName.substring(1, 2) - 1;
    lambda(h, level);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Pop indices (and UL containers) until reaching up to a given level.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> pop_container(container, indices, level) <span class="Identifier">{</span>
  <span class="Statement">while</span> (indices.length &gt; level) <span class="Identifier">{</span>
    container = container.parentNode;
    indices.pop();
  <span class="Identifier">}</span>
  <span class="Statement">return</span> container;
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Push indices (and UL containers) until reaching doen to a given level.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> push_container(container, indices, level) <span class="Identifier">{</span>
  <span class="Statement">while</span> (indices.length &lt; level) <span class="Identifier">{</span>
    <span class="Comment">// TRICKY: push a 0 for the very last new level, so the ++ at the end</span>
    <span class="Comment">// will turn it into a 1.</span>
    indices.push(indices.level &lt; level - 1);
    <span class="Identifier">var</span> ul = <span class="Statement">document</span>.createElement(<span class="Constant">&quot;ul&quot;</span>);
    <span class="Statement">if</span> (container) <span class="Identifier">{</span>
      container.appendChild(ul);
    <span class="Identifier">}</span>
    container = ul;
  <span class="Identifier">}</span>
  indices<span class="Identifier">[</span>indices.length - 1<span class="Identifier">]</span>++;
  <span class="Statement">return</span> container;
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Create a LI for an H element with some id.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> list_element(id, h) <span class="Identifier">{</span>
  <span class="Identifier">var</span> a = <span class="Statement">document</span>.createElement(<span class="Constant">&quot;a&quot;</span>);
  a.href = <span class="Constant">&quot;#&quot;</span> + id;
  a.innerHTML = id + <span class="Constant">&quot;&amp;nbsp;&quot;</span> + h.innerHTML;
  <span class="Identifier">var</span> li = <span class="Statement">document</span>.createElement(<span class="Constant">&quot;li&quot;</span>);
  li.appendChild(a);
  <span class="Statement">return</span> li;
<span class="Identifier">}</span>

<span class="Comment">/*</span>
<span class="Comment"> * Create an anchor for an H element with some id.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> header_anchor(id) <span class="Identifier">{</span>
  <span class="Identifier">var</span> text = <span class="Statement">document</span>.createTextNode(id + <span class="Constant">&quot; &quot;</span>);
  <span class="Identifier">var</span> a = <span class="Statement">document</span>.createElement(<span class="Constant">&quot;a&quot;</span>);
  a.id = id;
  a.appendChild(text);
  <span class="Statement">return</span> a;
<span class="Identifier">}</span>
</pre>
</div>
</div>
</p>
<h3>CSS files</h3>
<p>
To avoid dealing with the different default styles used by different browsers,
we employ the YUI CSS <a href="http://developer.yahoo.com/yui/reset/">reset</a> file:
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="doc-reset-css">
<span>doc/reset.css</span>
</a>
</div>
<div class="chunk html">
<pre class='css code syntax'>
<span class="Comment">/*</span>
<span class="Comment">Copyright (c) 2010, Yahoo! Inc. All rights reserved.</span>
<span class="Comment">Code licensed under the BSD License:</span>
<span class="Comment"><a href="http://developer.yahoo.com/yui/license.html">http://developer.yahoo.com/yui/license.html</a></span>
<span class="Comment">version: 2.8.2r1</span>
<span class="Comment">*/</span>
<span class="Comment">/**</span>
<span class="Comment"> * YUI Reset</span>
<span class="Comment"> * @module reset</span>
<span class="Comment"> * @namespace</span>
<span class="Comment"> * @requires </span>
<span class="Comment"> */</span>
<span class="Statement">html</span> <span class="Identifier">{</span>
        <span class="Type">color</span>: <span class="Constant">#000</span>;
        <span class="Type">background</span>: <span class="Constant">#FFF</span>;
<span class="Identifier">}</span>

<span class="Statement">body</span>,
<span class="Statement">div</span>,
<span class="Statement">dl</span>,
<span class="Statement">dt</span>,
<span class="Statement">dd</span>,
<span class="Statement">ul</span>,
<span class="Statement">ol</span>,
<span class="Statement">li</span>,
<span class="Statement">h1</span>,
<span class="Statement">h2</span>,
<span class="Statement">h3</span>,
<span class="Statement">h4</span>,
<span class="Statement">h5</span>,
<span class="Statement">h6</span>,
<span class="Statement">pre</span>,
<span class="Statement">code</span>,
<span class="Statement">form</span>,
<span class="Statement">fieldset</span>,
<span class="Statement">legend</span>,
<span class="Statement">input</span>,
<span class="Statement">button</span>,
<span class="Statement">textarea</span>,
<span class="Statement">p</span>,
<span class="Statement">blockquote</span>,
<span class="Statement">th</span>,
<span class="Statement">td</span> <span class="Identifier">{</span>
        <span class="Type">margin</span>: <span class="Constant">0</span>;
        <span class="Type">padding</span>: <span class="Constant">0</span>;
<span class="Identifier">}</span>

<span class="Statement">table</span> <span class="Identifier">{</span>
        <span class="Type">border-collapse</span>: <span class="Type">collapse</span>;
        <span class="Type">border-spacing</span>: <span class="Constant">0</span>;
<span class="Identifier">}</span>

<span class="Statement">fieldset</span>,
<span class="Statement">img</span> <span class="Identifier">{</span>
        <span class="Type">border</span>: <span class="Constant">0</span>;
<span class="Identifier">}</span>

<span class="Statement">address</span>,
<span class="Statement">caption</span>,
<span class="Statement">cite</span>,
<span class="Statement">code</span>,
<span class="Statement">dfn</span>,
<span class="Statement">em</span>,
<span class="Statement">strong</span>,
<span class="Statement">th</span>,
<span class="Statement">var</span>,
<span class="Statement">optgroup</span> <span class="Identifier">{</span>
        <span class="Type">font-style</span>: <span class="Type">inherit</span>;
        <span class="Type">font-weight</span>: <span class="Type">inherit</span>;
<span class="Identifier">}</span>

<span class="Statement">del</span>,
<span class="Statement">ins</span> <span class="Identifier">{</span>
        <span class="Type">text-decoration</span>: <span class="Type">none</span>;
<span class="Identifier">}</span>

<span class="Statement">li</span> <span class="Identifier">{</span>
        <span class="Type">list-style</span>: <span class="Type">none</span>;
<span class="Identifier">}</span>

<span class="Statement">caption</span>,
<span class="Statement">th</span> <span class="Identifier">{</span>
        <span class="Type">text-align</span>: <span class="Type">left</span>;
<span class="Identifier">}</span>

<span class="Statement">h1</span>,
<span class="Statement">h2</span>,
<span class="Statement">h3</span>,
<span class="Statement">h4</span>,
<span class="Statement">h5</span>,
<span class="Statement">h6</span> <span class="Identifier">{</span>
        <span class="Type">font-size</span>: <span class="Constant">100%</span>;
        <span class="Type">font-weight</span>: <span class="Type">normal</span>;
<span class="Identifier">}</span>

<span class="Statement">q</span>:<span class="PreProc">before</span>,
<span class="Statement">q</span>:<span class="PreProc">after</span> <span class="Identifier">{</span>
        <span class="Type">content</span>: <span class="Constant">''</span>;
<span class="Identifier">}</span>

<span class="Statement">abbr</span>,
<span class="Statement">acronym</span> <span class="Identifier">{</span>
        <span class="Type">border</span>: <span class="Constant">0</span>;
        <span class="Type">font-variant</span>: <span class="Type">normal</span>;
<span class="Identifier">}</span>

<span class="Statement">sup</span> <span class="Identifier">{</span>
        <span class="Type">vertical-align</span>: <span class="Type">baseline</span>;
<span class="Identifier">}</span>

<span class="Statement">sub</span> <span class="Identifier">{</span>
        <span class="Type">vertical-align</span>: <span class="Type">baseline</span>;
<span class="Identifier">}</span>

<span class="Comment">/*because legend doesn't inherit in IE */</span>
<span class="Statement">legend</span> <span class="Identifier">{</span>
        <span class="Type">color</span>: <span class="Constant">#000</span>;
<span class="Identifier">}</span>

<span class="Statement">input</span>,
<span class="Statement">button</span>,
<span class="Statement">textarea</span>,
<span class="Statement">select</span>,
<span class="Statement">optgroup</span>,
<span class="Statement">option</span> <span class="Identifier">{</span>
        <span class="Type">font-family</span>: <span class="Type">inherit</span>;
        <span class="Type">font-size</span>: <span class="Type">inherit</span>;
        <span class="Type">font-style</span>: <span class="Type">inherit</span>;
        <span class="Type">font-weight</span>: <span class="Type">inherit</span>;
<span class="Identifier">}</span>

<span class="Comment">/*@purpose To enable resizing for IE */</span>
<span class="Comment">/*@branch For IE6-Win, IE7-Win */</span>
<span class="Statement">input</span>,
<span class="Statement">button</span>,
<span class="Statement">textarea</span>,
<span class="Statement">select</span> <span class="Identifier">{</span>
        *<span class="Type">font-size</span>: <span class="Constant">100%</span>;
<span class="Identifier">}</span>



</pre>
</div>
</div>
</p>
<p>
This requires us to restore the default look and feel of the standard HTML
elements, using the YUI <a href="http://developer.yahoo.com/yui/base/">base</a> CSS style
file. Resetting and restoring the default CSS styles is inelegant, but it is
the only current way to get a consistent presentation of HTML.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="doc-base-css">
<span>doc/base.css</span>
</a>
</div>
<div class="chunk html">
<pre class='css code syntax'>
<span class="Comment">/*</span>
<span class="Comment">Copyright (c) 2010, Yahoo! Inc. All rights reserved.</span>
<span class="Comment">Code licensed under the BSD License:</span>
<span class="Comment"><a href="http://developer.yahoo.com/yui/license.html">http://developer.yahoo.com/yui/license.html</a></span>
<span class="Comment">version: 2.8.2r1</span>
<span class="Comment">*/</span>
<span class="Comment">/**</span>
<span class="Comment"> * YUI Base</span>
<span class="Comment"> * @module base</span>
<span class="Comment"> * @namespace yui-</span>
<span class="Comment"> * @requires reset, fonts</span>
<span class="Comment">*/</span>

<span class="Statement">body</span> <span class="Identifier">{</span>
        <span class="Comment">/* For breathing room between content and viewport. */</span>
        <span class="Type">margin</span>:<span class="Constant">10px</span>;
<span class="Identifier">}</span>

<span class="Statement">h1</span> <span class="Identifier">{</span>
        <span class="Comment">/* 18px via YUI Fonts CSS foundation. */</span>
        <span class="Type">font-size</span>: <span class="Constant">138.5%</span>;
<span class="Identifier">}</span>

<span class="Statement">h2</span> <span class="Identifier">{</span>
        <span class="Comment">/* 16px via YUI Fonts CSS foundation. */</span>
        <span class="Type">font-size</span>: <span class="Constant">123.1%</span>;
<span class="Identifier">}</span>

<span class="Statement">h3</span> <span class="Identifier">{</span>
        <span class="Comment">/* 14px via YUI Fonts CSS foundation. */</span>
        <span class="Type">font-size</span>: <span class="Constant">108%</span>;
<span class="Identifier">}</span>

<span class="Statement">h1</span>,<span class="Statement">h2</span>,<span class="Statement">h3</span> <span class="Identifier">{</span>
        <span class="Comment">/* Top &amp; bottom margin based on font size. */</span>
        <span class="Type">margin</span>: <span class="Constant">1em</span> <span class="Constant">0</span>;
<span class="Identifier">}</span>

<span class="Statement">h1</span>,<span class="Statement">h2</span>,<span class="Statement">h3</span>,<span class="Statement">h4</span>,<span class="Statement">h5</span>,<span class="Statement">h6</span>,<span class="Statement">strong</span>,<span class="Statement">dt</span> <span class="Identifier">{</span>
        <span class="Comment">/* Bringing boldness back to headers and the strong element. */</span>
        <span class="Type">font-weight</span>: <span class="Type">bold</span>;
<span class="Identifier">}</span>
<span class="Statement">optgroup</span> <span class="Identifier">{</span>
        <span class="Type">font-weight</span>:<span class="Type">normal</span>;
<span class="Identifier">}</span>

<span class="Statement">abbr</span>,<span class="Statement">acronym</span> <span class="Identifier">{</span>
        <span class="Comment">/* Indicating to users that more info is available. */</span>
        <span class="Type">border-bottom</span>: <span class="Constant">1px</span> <span class="Type">dotted</span> <span class="Constant">#000</span>;
        <span class="Type">cursor</span>: <span class="Type">help</span>;
<span class="Identifier">}</span>

<span class="Statement">em</span> <span class="Identifier">{</span>
        <span class="Comment">/* Bringing italics back to the em element. */</span>
        <span class="Type">font-style</span>: <span class="Type">italic</span>;
<span class="Identifier">}</span>

<span class="Statement">del</span> <span class="Identifier">{</span>
        <span class="Comment">/* Striking deleted phrases. */</span>
        <span class="Type">text-decoration</span>: <span class="Type">line-through</span>;
<span class="Identifier">}</span>

<span class="Statement">blockquote</span>,<span class="Statement">ul</span>,<span class="Statement">ol</span>,<span class="Statement">dl</span> <span class="Identifier">{</span>
        <span class="Comment">/* Giving blockquotes and lists room to breath. */</span>
        <span class="Type">margin</span>: <span class="Constant">1em</span>;
<span class="Identifier">}</span>

<span class="Statement">ol</span>,<span class="Statement">ul</span>,<span class="Statement">dl</span> <span class="Identifier">{</span>
        <span class="Comment">/* Bringing lists on to the page with breathing room. */</span>
        <span class="Type">margin-left</span>: <span class="Constant">2em</span>;
<span class="Identifier">}</span>

<span class="Statement">ol</span> <span class="Statement">li</span> <span class="Identifier">{</span>
        <span class="Comment">/* Giving OL's LIs generated numbers. */</span>
        <span class="Type">list-style</span>: <span class="Type">decimal</span> <span class="Type">outside</span>;
<span class="Identifier">}</span>

<span class="Statement">ul</span> <span class="Statement">li</span> <span class="Identifier">{</span>
        <span class="Comment">/* Giving UL's LIs generated disc markers. */</span>
        <span class="Type">list-style</span>: <span class="Type">disc</span> <span class="Type">outside</span>;
<span class="Identifier">}</span>

<span class="Statement">dl</span> <span class="Statement">dd</span> <span class="Identifier">{</span>
        <span class="Comment">/* Giving UL's LIs generated numbers. */</span>
        <span class="Type">margin-left</span>: <span class="Constant">1em</span>;
<span class="Identifier">}</span>

<span class="Statement">th</span>,<span class="Statement">td</span> <span class="Identifier">{</span>
        <span class="Comment">/* Borders and padding to make the table readable. */</span>
        <span class="Type">border</span>: <span class="Constant">1px</span> <span class="Type">solid</span> <span class="Constant">#000</span>;
        <span class="Type">padding</span>: .<span class="Constant">5em</span>;
<span class="Identifier">}</span>

<span class="Statement">th</span> <span class="Identifier">{</span>
        <span class="Comment">/* Distinguishing table headers from data cells. */</span>
        <span class="Type">font-weight</span>: <span class="Type">bold</span>;
        <span class="Type">text-align</span>: <span class="Type">center</span>;
<span class="Identifier">}</span>

<span class="Statement">caption</span> <span class="Identifier">{</span>
        <span class="Comment">/* Coordinated margin to match cell's padding. */</span>
        <span class="Type">margin-bottom</span>: .<span class="Constant">5em</span>;
        <span class="Comment">/* Centered so it doesn't blend in to other content. */</span>
        <span class="Type">text-align</span>: <span class="Type">center</span>;
<span class="Identifier">}</span>

<span class="Statement">sup</span> <span class="Identifier">{</span>
        <span class="Comment">/* to preserve line-height and selector appearance */</span>
        <span class="Type">vertical-align</span>: <span class="Type">super</span>;
<span class="Identifier">}</span>

<span class="Statement">sub</span> <span class="Identifier">{</span>
        <span class="Comment">/* to preserve line-height and selector appearance */</span>
        <span class="Type">vertical-align</span>: <span class="Type">sub</span>;
<span class="Identifier">}</span>

<span class="Statement">p</span>,
<span class="Statement">fieldset</span>,
<span class="Statement">table</span>,
<span class="Statement">pre</span> <span class="Identifier">{</span>
        <span class="Comment">/* So things don't run into each other. */</span>
        <span class="Type">margin-bottom</span>: <span class="Constant">1em</span>;
<span class="Identifier">}</span>
<span class="Comment">/* Opera requires 1px of passing to render with contemporary native chrome */</span>
<span class="Statement">button</span>,
<span class="Statement">input</span><span class="Special">[</span>type<span class="Special">=</span><span class="Constant">&quot;checkbox&quot;</span><span class="Special">]</span>,
<span class="Statement">input</span><span class="Special">[</span>type<span class="Special">=</span><span class="Constant">&quot;radio&quot;</span><span class="Special">]</span>,
<span class="Statement">input</span><span class="Special">[</span>type<span class="Special">=</span><span class="Constant">&quot;reset&quot;</span><span class="Special">]</span>,
<span class="Statement">input</span><span class="Special">[</span>type<span class="Special">=</span><span class="Constant">&quot;submit&quot;</span><span class="Special">]</span> <span class="Identifier">{</span>
        <span class="Type">padding</span>:<span class="Constant">1px</span>;
<span class="Identifier">}</span>
</pre>
</div>
</div>
</p>
<p>
Finally, we can apply styles specific to our HTML. Some of these override the
default styles established by the base CSS file above. We do this instead of
directly tweaking the base CSS file, to allow easy upgrade to new versions
if/when YUI release any.
</p>
<p>
<div class="named_with_containers chunk">
<div class="chunk name">
<a name="doc-style-css">
<span>doc/style.css</span>
</a>
</div>
<div class="chunk html">
<pre class='css code syntax'>
<span class="Comment">/* Margin &amp; Padding */</span>

<span class="Statement">div</span><span class="Identifier">.chunk.name</span>,
<span class="Statement">div</span><span class="Identifier">.chunk.html</span>,
<span class="Statement">div</span><span class="Identifier">.chunk.containers</span>,
<span class="Statement">div</span><span class="Identifier">.chunk</span> <span class="Statement">table</span>,
<span class="Statement">div</span><span class="Identifier">.chunk</span> <span class="Statement">td</span>,
<span class="Statement">div</span><span class="Identifier">.chunk</span> <span class="Statement">pre</span> <span class="Identifier">{</span>
  <span class="Type">margin</span>: <span class="Constant">0</span>;
  <span class="Type">padding</span>: <span class="Constant">0</span>;
<span class="Identifier">}</span>
<span class="Statement">div</span><span class="Identifier">.chunk</span> <span class="Statement">*</span>:last-child <span class="Identifier">{</span>
  <span class="Type">margin-bottom</span>: <span class="Constant">0</span>;
<span class="Identifier">}</span>
<span class="Statement">h4</span>, <span class="Statement">h5</span>, <span class="Statement">h6</span>,
<span class="Statement">div</span><span class="Identifier">.chunk</span>,
<span class="Statement">div</span><span class="Identifier">.comment</span> <span class="Statement">pre</span> <span class="Identifier">{</span>
  <span class="Type">margin</span>: <span class="Constant">1em</span> <span class="Constant">0</span>;
<span class="Identifier">}</span>
<span class="Statement">pre</span>,
<span class="Statement">div</span><span class="Identifier">.comment</span>,
<span class="Statement">div</span><span class="Identifier">.chunk.html</span> <span class="Identifier">{</span>
  <span class="Type">padding</span>: <span class="Constant">0.33em</span>;
<span class="Identifier">}</span>

<span class="Comment">/* Table of content */</span>

<span class="Statement">div</span><span class="Identifier">#contents</span> <span class="Statement">ul</span> <span class="Identifier">{</span>
  <span class="Type">margin-top</span>: <span class="Constant">0</span>;
  <span class="Type">margin-bottom</span>: <span class="Constant">0</span>;
  <span class="Type">padding</span>: <span class="Constant">0</span>;
<span class="Identifier">}</span>

<span class="Statement">div</span><span class="Identifier">#contents</span> <span class="Statement">li</span> <span class="Identifier">{</span>
  <span class="Type">list-style-type</span>: <span class="Type">none</span>;
<span class="Identifier">}</span>

<span class="Comment">/* Lists */</span>

<span class="Statement">ul</span><span class="Identifier">.chunk.containers</span> <span class="Identifier">{</span>
  <span class="Type">padding</span>: <span class="Constant">0</span>;
  <span class="Type">margin</span>: <span class="Constant">0</span>;
  <span class="Type">display</span>: <span class="Type">inline</span>;
<span class="Identifier">}</span>
<span class="Statement">ul</span><span class="Identifier">.chunk.containers</span> <span class="Statement">li</span> <span class="Identifier">{</span>
  <span class="Type">display</span>: <span class="Type">inline</span>;
  <span class="Type">list-style-type</span>: <span class="Type">none</span>;
<span class="Identifier">}</span>

<span class="Comment">/* Borders */</span>

<span class="Statement">table</span><span class="Identifier">.layout</span> <span class="Statement">td</span><span class="Identifier">.indentation</span> <span class="Identifier">{</span>
  <span class="Type">border</span>: <span class="Type">none</span>;
<span class="Identifier">}</span>
<span class="Statement">pre</span>,
<span class="Statement">div</span><span class="Identifier">.chunk.html</span> <span class="Identifier">{</span>
  <span class="Type">border</span>: <span class="Constant">1px</span> <span class="Type">solid</span> <span class="Constant">#000</span>;
<span class="Identifier">}</span>
<span class="Statement">div</span><span class="Identifier">.chunk</span> <span class="Statement">pre</span> <span class="Identifier">{</span>
  <span class="Type">border</span>: <span class="Type">none</span>;
<span class="Identifier">}</span>

<span class="Comment">/* Colors */</span>

<span class="Statement">table</span><span class="Identifier">.layout</span> <span class="Statement">td</span><span class="Identifier">.html</span> <span class="Identifier">{</span>
  <span class="Type">background-color</span>: Beige;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.Constant</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: Crimson;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.Identifier</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: <span class="Constant">Teal</span>;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.PreProc</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: Indigo;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.Special</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: <span class="Constant">Navy</span>;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.Statement</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: <span class="Constant">Maroon</span>;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.Type</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: <span class="Constant">Green</span>;
<span class="Identifier">}</span>
<span class="Statement">span</span><span class="Identifier">.Comment</span> <span class="Identifier">{</span>
  <span class="Type">color</span>: <span class="Constant">Purple</span>;
<span class="Identifier">}</span>

<span class="Comment">/* Fonts */</span>

<span class="Statement">body</span> <span class="Identifier">{</span>
  <span class="Type">font-family</span>: <span class="Type">Sans-Serif</span>;
<span class="Identifier">}</span>
<span class="Statement">pre</span> <span class="Identifier">{</span>
  <span class="Type">font-family</span>: Consolas, <span class="Type">Monospace</span>;
<span class="Identifier">}</span>
<span class="Statement">div</span><span class="Identifier">.chunk.name</span> <span class="Identifier">{</span>
  <span class="Type">font-weight</span>: <span class="Type">bold</span>;
<span class="Identifier">}</span>
</pre>
</div>
</div>
</p>
</div>
</body>
</html>
